This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: backend, docker-compose*, mise.toml, README.md, development.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
backend/
  app/
    alembic/
      versions/
        1a31ce608336_add_cascade_delete_relationships.py
        9c0a54914c78_add_max_length_for_string_varchar_.py
        d98dd8ec85a3_edit_replace_id_integers_in_all_models_.py
        e2412789c190_initialize_models.py
      env.py
      migration_template.py.mako
      modular_table_migration_example.py
      README
      README_MODULAR.md
      script.py.mako
    api/
      deps.py
      main.py
    core/
      config.py
      db.py
      events.py
      logging.py
      security.py
    email-templates/
      build/
        new_account.html
        reset_password.html
        test_email.html
      src/
        new_account.mjml
        reset_password.mjml
        test_email.mjml
    modules/
      auth/
        api/
          routes.py
        domain/
          models.py
        repository/
          auth_repo.py
        services/
          auth_service.py
        __init__.py
        dependencies.py
      email/
        api/
          routes.py
        domain/
          models.py
        services/
          email_event_handlers.py
          email_service.py
        __init__.py
        dependencies.py
      items/
        api/
          routes.py
        domain/
          models.py
        repository/
          item_repo.py
        services/
          item_service.py
        __init__.py
        dependencies.py
      users/
        api/
          routes.py
        domain/
          events.py
          models.py
        repository/
          user_repo.py
        services/
          user_service.py
        __init__.py
        dependencies.py
    shared/
      exceptions.py
      models.py
      utils.py
    tests/
      api/
        blackbox/
          __init__.py
          .env
          client_utils.py
          conftest.py
          dependencies.py
          pytest.ini
          README.md
          test_api_contract.py
          test_authorization.py
          test_basic.py
          test_user_lifecycle.py
          test_utils.py
      scripts/
        test_backend_pre_start.py
        test_test_pre_start.py
      services/
        test_user_service.py
      utils/
        item.py
        user.py
        utils.py
      conftest.py
    backend_pre_start.py
    initial_data.py
    main.py
    tests_pre_start.py
  examples/
    module_example/
      api/
        __init__.py
        routes.py
      domain/
        __init__.py
        events.py
        models.py
      repository/
        __init__.py
        example_repo.py
      services/
        __init__.py
        event_handlers.py
        example_service.py
      __init__.py
    __init__.py
    README.md
  scripts/
    format.sh
    lint.sh
    prestart.sh
    run_blackbox_tests.sh
    test.sh
    tests-start.sh
  tests/
    core/
      test_events.py
    modules/
      email/
        services/
          test_email_event_handlers.py
      integration/
        test_user_email_integration.py
      shared/
        test_model_imports.py
      users/
        domain/
          test_user_events.py
        services/
          test_user_service_events.py
  .dockerignore
  .gitignore
  alembic.ini
  BLACKBOX_TESTS.md
  CODE_STYLE_GUIDE.md
  Dockerfile
  EVENT_SYSTEM.md
  EXTENDING_ARCHITECTURE.md
  MODULAR_MONOLITH_IMPLEMENTATION.md
  MODULAR_MONOLITH_PLAN.md
  pyproject.toml
  pytest.ini
  README.md
  TEST_PLAN.md
development.md
docker-compose.override.yml
docker-compose.traefik.yml
docker-compose.yml
mise.toml
README.md

================================================================
Files
================================================================

================
File: backend/app/alembic/versions/1a31ce608336_add_cascade_delete_relationships.py
================
"""Add cascade delete relationships

Revision ID: 1a31ce608336
Revises: d98dd8ec85a3
Create Date: 2024-07-31 22:24:34.447891

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel.sql.sqltypes


# revision identifiers, used by Alembic.
revision = '1a31ce608336'
down_revision = 'd98dd8ec85a3'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('item', 'owner_id',
               existing_type=sa.UUID(),
               nullable=False)
    op.drop_constraint('item_owner_id_fkey', 'item', type_='foreignkey')
    op.create_foreign_key(None, 'item', 'user', ['owner_id'], ['id'], ondelete='CASCADE')
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'item', type_='foreignkey')
    op.create_foreign_key('item_owner_id_fkey', 'item', 'user', ['owner_id'], ['id'])
    op.alter_column('item', 'owner_id',
               existing_type=sa.UUID(),
               nullable=True)
    # ### end Alembic commands ###

================
File: backend/app/alembic/versions/9c0a54914c78_add_max_length_for_string_varchar_.py
================
"""Add max length for string(varchar) fields in User and Items models

Revision ID: 9c0a54914c78
Revises: e2412789c190
Create Date: 2024-06-17 14:42:44.639457

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel.sql.sqltypes


# revision identifiers, used by Alembic.
revision = '9c0a54914c78'
down_revision = 'e2412789c190'
branch_labels = None
depends_on = None


def upgrade():
    # Adjust the length of the email field in the User table
    op.alter_column('user', 'email',
               existing_type=sa.String(),
               type_=sa.String(length=255),
               existing_nullable=False)

    # Adjust the length of the full_name field in the User table
    op.alter_column('user', 'full_name',
               existing_type=sa.String(),
               type_=sa.String(length=255),
               existing_nullable=True)

    # Adjust the length of the title field in the Item table
    op.alter_column('item', 'title',
               existing_type=sa.String(),
               type_=sa.String(length=255),
               existing_nullable=False)

    # Adjust the length of the description field in the Item table
    op.alter_column('item', 'description',
               existing_type=sa.String(),
               type_=sa.String(length=255),
               existing_nullable=True)


def downgrade():
    # Revert the length of the email field in the User table
    op.alter_column('user', 'email',
               existing_type=sa.String(length=255),
               type_=sa.String(),
               existing_nullable=False)

    # Revert the length of the full_name field in the User table
    op.alter_column('user', 'full_name',
               existing_type=sa.String(length=255),
               type_=sa.String(),
               existing_nullable=True)

    # Revert the length of the title field in the Item table
    op.alter_column('item', 'title',
               existing_type=sa.String(length=255),
               type_=sa.String(),
               existing_nullable=False)

    # Revert the length of the description field in the Item table
    op.alter_column('item', 'description',
               existing_type=sa.String(length=255),
               type_=sa.String(),
               existing_nullable=True)

================
File: backend/app/alembic/versions/d98dd8ec85a3_edit_replace_id_integers_in_all_models_.py
================
"""Edit replace id integers in all models to use UUID instead

Revision ID: d98dd8ec85a3
Revises: 9c0a54914c78
Create Date: 2024-07-19 04:08:04.000976

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel.sql.sqltypes
from sqlalchemy.dialects import postgresql


# revision identifiers, used by Alembic.
revision = 'd98dd8ec85a3'
down_revision = '9c0a54914c78'
branch_labels = None
depends_on = None


def upgrade():
    # Ensure uuid-ossp extension is available
    op.execute('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"')

    # Create a new UUID column with a default UUID value
    op.add_column('user', sa.Column('new_id', postgresql.UUID(as_uuid=True), default=sa.text('uuid_generate_v4()')))
    op.add_column('item', sa.Column('new_id', postgresql.UUID(as_uuid=True), default=sa.text('uuid_generate_v4()')))
    op.add_column('item', sa.Column('new_owner_id', postgresql.UUID(as_uuid=True), nullable=True))

    # Populate the new columns with UUIDs
    op.execute('UPDATE "user" SET new_id = uuid_generate_v4()')
    op.execute('UPDATE item SET new_id = uuid_generate_v4()')
    op.execute('UPDATE item SET new_owner_id = (SELECT new_id FROM "user" WHERE "user".id = item.owner_id)')

    # Set the new_id as not nullable
    op.alter_column('user', 'new_id', nullable=False)
    op.alter_column('item', 'new_id', nullable=False)

    # Drop old columns and rename new columns
    op.drop_constraint('item_owner_id_fkey', 'item', type_='foreignkey')
    op.drop_column('item', 'owner_id')
    op.alter_column('item', 'new_owner_id', new_column_name='owner_id')

    op.drop_column('user', 'id')
    op.alter_column('user', 'new_id', new_column_name='id')

    op.drop_column('item', 'id')
    op.alter_column('item', 'new_id', new_column_name='id')

    # Create primary key constraint
    op.create_primary_key('user_pkey', 'user', ['id'])
    op.create_primary_key('item_pkey', 'item', ['id'])

    # Recreate foreign key constraint
    op.create_foreign_key('item_owner_id_fkey', 'item', 'user', ['owner_id'], ['id'])

def downgrade():
    # Reverse the upgrade process
    op.add_column('user', sa.Column('old_id', sa.Integer, autoincrement=True))
    op.add_column('item', sa.Column('old_id', sa.Integer, autoincrement=True))
    op.add_column('item', sa.Column('old_owner_id', sa.Integer, nullable=True))

    # Populate the old columns with default values
    # Generate sequences for the integer IDs if not exist
    op.execute('CREATE SEQUENCE IF NOT EXISTS user_id_seq AS INTEGER OWNED BY "user".old_id')
    op.execute('CREATE SEQUENCE IF NOT EXISTS item_id_seq AS INTEGER OWNED BY item.old_id')

    op.execute('SELECT setval(\'user_id_seq\', COALESCE((SELECT MAX(old_id) + 1 FROM "user"), 1), false)')
    op.execute('SELECT setval(\'item_id_seq\', COALESCE((SELECT MAX(old_id) + 1 FROM item), 1), false)')

    op.execute('UPDATE "user" SET old_id = nextval(\'user_id_seq\')')
    op.execute('UPDATE item SET old_id = nextval(\'item_id_seq\'), old_owner_id = (SELECT old_id FROM "user" WHERE "user".id = item.owner_id)')

    # Drop new columns and rename old columns back
    op.drop_constraint('item_owner_id_fkey', 'item', type_='foreignkey')
    op.drop_column('item', 'owner_id')
    op.alter_column('item', 'old_owner_id', new_column_name='owner_id')

    op.drop_column('user', 'id')
    op.alter_column('user', 'old_id', new_column_name='id')

    op.drop_column('item', 'id')
    op.alter_column('item', 'old_id', new_column_name='id')

    # Create primary key constraint
    op.create_primary_key('user_pkey', 'user', ['id'])
    op.create_primary_key('item_pkey', 'item', ['id'])

    # Recreate foreign key constraint
    op.create_foreign_key('item_owner_id_fkey', 'item', 'user', ['owner_id'], ['id'])

================
File: backend/app/alembic/versions/e2412789c190_initialize_models.py
================
"""Initialize models

Revision ID: e2412789c190
Revises:
Create Date: 2023-11-24 22:55:43.195942

"""
import sqlalchemy as sa
import sqlmodel.sql.sqltypes
from alembic import op

# revision identifiers, used by Alembic.
revision = "e2412789c190"
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "user",
        sa.Column("email", sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column("is_active", sa.Boolean(), nullable=False),
        sa.Column("is_superuser", sa.Boolean(), nullable=False),
        sa.Column("full_name", sqlmodel.sql.sqltypes.AutoString(), nullable=True),
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column(
            "hashed_password", sqlmodel.sql.sqltypes.AutoString(), nullable=False
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(op.f("ix_user_email"), "user", ["email"], unique=True)
    op.create_table(
        "item",
        sa.Column("description", sqlmodel.sql.sqltypes.AutoString(), nullable=True),
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("title", sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column("owner_id", sa.Integer(), nullable=False),
        sa.ForeignKeyConstraint(
            ["owner_id"],
            ["user.id"],
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("item")
    op.drop_index(op.f("ix_user_email"), table_name="user")
    op.drop_table("user")
    # ### end Alembic commands ###

================
File: backend/app/alembic/migration_template.py.mako
================
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade database schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade database schema."""
    ${downgrades if downgrades else "pass"}

================
File: backend/app/alembic/modular_table_migration_example.py
================
"""
Example migration for modular table models.

This is an example of how to create a migration for modular table models.
"""
import uuid
from typing import Optional

import sqlalchemy as sa
from alembic import op
from sqlalchemy.dialects.postgresql import UUID
from sqlmodel import SQLModel, Field, Relationship

# revision identifiers, used by Alembic.
revision = 'example_modular_migration'
down_revision = None
branch_labels = None
depends_on = None


# Define models for reference (not used in migration)
class UserBase(SQLModel):
    """Base user model with common properties."""
    email: str = Field(unique=True, index=True, max_length=255)
    is_active: bool = True
    is_superuser: bool = False
    full_name: Optional[str] = Field(default=None, max_length=255)


class User(UserBase, table=True):
    """Database model for a user."""
    __tablename__ = "user"
    
    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    hashed_password: str


def upgrade() -> None:
    """
    Upgrade database schema.
    
    This is an example of how to create a migration for modular table models.
    In a real migration, you would use op.create_table(), op.add_column(), etc.
    """
    # Example: Create a new table
    op.create_table(
        'example_table',
        sa.Column('id', UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('description', sa.String(255), nullable=True),
        sa.Column('user_id', UUID(as_uuid=True), sa.ForeignKey('user.id'), nullable=False),
    )
    
    # Example: Add a column to an existing table
    op.add_column('user', sa.Column('last_login', sa.DateTime(), nullable=True))
    
    # Example: Create an index
    op.create_index(op.f('ix_example_table_name'), 'example_table', ['name'], unique=False)


def downgrade() -> None:
    """
    Downgrade database schema.
    
    This is the reverse of the upgrade function.
    """
    # Example: Drop index
    op.drop_index(op.f('ix_example_table_name'), table_name='example_table')
    
    # Example: Drop column
    op.drop_column('user', 'last_login')
    
    # Example: Drop table
    op.drop_table('example_table')

================
File: backend/app/alembic/README
================
Generic single-database configuration.

================
File: backend/app/alembic/README_MODULAR.md
================
# Alembic in Modular Monolith Architecture

This document explains how to use Alembic with the modular monolith architecture.

## Overview

In our modular monolith architecture, models are distributed across multiple modules. This presents a challenge for Alembic, which needs to be aware of all models to generate migrations correctly.

## Current Approach

During the transition to a fully modular architecture, we're using a hybrid approach:

1. **Legacy Table Models**: We continue to import table models (with `table=True`) from `app.models` to avoid duplicate table definitions.
2. **Non-Table Models**: We import non-table models (without `table=True`) from their respective modules.

## Generating Migrations

To generate a migration:

```bash
# From the project root directory
alembic revision --autogenerate -m "description_of_changes"
```

## Applying Migrations

To apply migrations:

```bash
# Apply all pending migrations
alembic upgrade head

# Apply a specific number of migrations
alembic upgrade +1

# Rollback a specific number of migrations
alembic downgrade -1
```

## Future Approach

Once all model references have been updated to use the modular structure, we'll update the Alembic environment to import table models from their respective modules.

The transition plan is:

1. Update all code to use the modular imports
2. Remove the legacy models from `app.models`
3. Uncomment the table model definitions in each module
4. Update the Alembic environment to import from modules

## Handling Module-Specific Migrations

For module-specific migrations that don't affect the database schema (e.g., data migrations), you can create empty migrations:

```bash
alembic revision -m "data_migration_for_module_x"
```

Then edit the generated file to include your custom migration logic.

## Best Practices

1. **Run Tests After Migrations**: Always run tests after applying migrations to ensure the application still works.
2. **Keep Migrations Small**: Make small, focused changes to make migrations easier to understand and troubleshoot.
3. **Document Complex Migrations**: Add comments to explain complex migration logic.
4. **Version Control**: Always commit migration files to version control.

## Troubleshooting

If you encounter issues with Alembic:

1. **Import Errors**: Ensure all models are properly imported in `env.py`.
2. **Duplicate Tables**: Check for duplicate table definitions (models with the same `__tablename__`).
3. **Missing Dependencies**: Ensure all required packages are installed.
4. **Python Path**: Make sure the Python path includes the application root directory.

================
File: backend/app/alembic/script.py.mako
================
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel.sql.sqltypes
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

================
File: backend/app/email-templates/build/new_account.html
================
<!doctype html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"><head><title></title><!--[if !mso]><!-- --><meta http-equiv="X-UA-Compatible" content="IE=edge"><!--<![endif]--><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><style type="text/css">#outlook a { padding:0; }
          .ReadMsgBody { width:100%; }
          .ExternalClass { width:100%; }
          .ExternalClass * { line-height:100%; }
          body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }
          table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }
          img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }
          p { display:block;margin:13px 0; }</style><!--[if !mso]><!--><style type="text/css">@media only screen and (max-width:480px) {
            @-ms-viewport { width:320px; }
            @viewport { width:320px; }
          }</style><!--<![endif]--><!--[if mso]>
        <xml>
        <o:OfficeDocumentSettings>
          <o:AllowPNG/>
          <o:PixelsPerInch>96</o:PixelsPerInch>
        </o:OfficeDocumentSettings>
        </xml>
        <![endif]--><!--[if lte mso 11]>
        <style type="text/css">
          .outlook-group-fix { width:100% !important; }
        </style>
        <![endif]--><!--[if !mso]><!--><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700" rel="stylesheet" type="text/css"><style type="text/css">@import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);</style><!--<![endif]--><style type="text/css">@media only screen and (min-width:480px) {
        .mj-column-per-100 { width:100% !important; max-width: 100%; }
      }</style><style type="text/css"></style></head><body style="background-color:#fafbfc;"><div style="background-color:#fafbfc;"><!--[if mso | IE]><table align="center" border="0" cellpadding="0" cellspacing="0" class="" style="width:600px;" width="600" ><tr><td style="line-height:0px;font-size:0px;mso-line-height-rule:exactly;"><![endif]--><div style="background:#ffffff;background-color:#ffffff;Margin:0px auto;max-width:600px;"><table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="background:#ffffff;background-color:#ffffff;width:100%;"><tbody><tr><td style="direction:ltr;font-size:0px;padding:40px 20px;text-align:center;vertical-align:top;"><!--[if mso | IE]><table role="presentation" border="0" cellpadding="0" cellspacing="0"><tr><td class="" style="vertical-align:middle;width:560px;" ><![endif]--><div class="mj-column-per-100 outlook-group-fix" style="font-size:13px;text-align:left;direction:ltr;display:inline-block;vertical-align:middle;width:100%;"><table border="0" cellpadding="0" cellspacing="0" role="presentation" style="vertical-align:middle;" width="100%"><tr><td align="center" style="font-size:0px;padding:35px;word-break:break-word;"><div style="font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:20px;line-height:1;text-align:center;color:#333333;">{{ project_name }} - New Account</div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;"><span>Welcome to your new account!</span></div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;">Here are your account details:</div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;">Username: {{ username }}</div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;">Password: {{ password }}</div></td></tr><tr><td align="center" vertical-align="middle" style="font-size:0px;padding:15px 30px;word-break:break-word;"><table border="0" cellpadding="0" cellspacing="0" role="presentation" style="border-collapse:separate;line-height:100%;"><tr><td align="center" bgcolor="#009688" role="presentation" style="border:none;border-radius:8px;cursor:auto;padding:10px 25px;background:#009688;" valign="middle"><a href="{{ link }}" style="background:#009688;color:#ffffff;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:18px;font-weight:normal;line-height:120%;Margin:0;text-decoration:none;text-transform:none;" target="_blank">Go to Dashboard</a></td></tr></table></td></tr><tr><td style="font-size:0px;padding:10px 25px;word-break:break-word;"><p style="border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:100%;"></p><!--[if mso | IE]><table align="center" border="0" cellpadding="0" cellspacing="0" style="border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:510px;" role="presentation" width="510px" ><tr><td style="height:0;line-height:0;"> &nbsp;
</td></tr></table><![endif]--></td></tr></table></div><!--[if mso | IE]></td></tr></table><![endif]--></td></tr></tbody></table></div><!--[if mso | IE]></td></tr></table><![endif]--></div></body></html>

================
File: backend/app/email-templates/build/reset_password.html
================
<!doctype html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"><head><title></title><!--[if !mso]><!-- --><meta http-equiv="X-UA-Compatible" content="IE=edge"><!--<![endif]--><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><style type="text/css">#outlook a { padding:0; }
          .ReadMsgBody { width:100%; }
          .ExternalClass { width:100%; }
          .ExternalClass * { line-height:100%; }
          body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }
          table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }
          img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }
          p { display:block;margin:13px 0; }</style><!--[if !mso]><!--><style type="text/css">@media only screen and (max-width:480px) {
            @-ms-viewport { width:320px; }
            @viewport { width:320px; }
          }</style><!--<![endif]--><!--[if mso]>
        <xml>
        <o:OfficeDocumentSettings>
          <o:AllowPNG/>
          <o:PixelsPerInch>96</o:PixelsPerInch>
        </o:OfficeDocumentSettings>
        </xml>
        <![endif]--><!--[if lte mso 11]>
        <style type="text/css">
          .outlook-group-fix { width:100% !important; }
        </style>
        <![endif]--><!--[if !mso]><!--><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700" rel="stylesheet" type="text/css"><style type="text/css">@import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);</style><!--<![endif]--><style type="text/css">@media only screen and (min-width:480px) {
        .mj-column-per-100 { width:100% !important; max-width: 100%; }
      }</style><style type="text/css"></style></head><body style="background-color:#fafbfc;"><div style="background-color:#fafbfc;"><!--[if mso | IE]><table align="center" border="0" cellpadding="0" cellspacing="0" class="" style="width:600px;" width="600" ><tr><td style="line-height:0px;font-size:0px;mso-line-height-rule:exactly;"><![endif]--><div style="background:#ffffff;background-color:#ffffff;Margin:0px auto;max-width:600px;"><table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="background:#ffffff;background-color:#ffffff;width:100%;"><tbody><tr><td style="direction:ltr;font-size:0px;padding:40px 20px;text-align:center;vertical-align:top;"><!--[if mso | IE]><table role="presentation" border="0" cellpadding="0" cellspacing="0"><tr><td class="" style="vertical-align:middle;width:560px;" ><![endif]--><div class="mj-column-per-100 outlook-group-fix" style="font-size:13px;text-align:left;direction:ltr;display:inline-block;vertical-align:middle;width:100%;"><table border="0" cellpadding="0" cellspacing="0" role="presentation" style="vertical-align:middle;" width="100%"><tr><td align="center" style="font-size:0px;padding:35px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:20px;line-height:1;text-align:center;color:#333333;">{{ project_name }} - Password Recovery</div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;"><span>Hello {{ username }}</span></div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;">We've received a request to reset your password. You can do it by clicking the button below:</div></td></tr><tr><td align="center" vertical-align="middle" style="font-size:0px;padding:15px 30px;word-break:break-word;"><table border="0" cellpadding="0" cellspacing="0" role="presentation" style="border-collapse:separate;line-height:100%;"><tr><td align="center" bgcolor="#009688" role="presentation" style="border:none;border-radius:8px;cursor:auto;padding:10px 25px;background:#009688;" valign="middle"><a href="{{ link }}" style="background:#009688;color:#ffffff;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:18px;font-weight:normal;line-height:120%;Margin:0;text-decoration:none;text-transform:none;" target="_blank">Reset password</a></td></tr></table></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;">Or copy and paste the following link into your browser:</div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;"><a href="{{ link }}">{{ link }}</a></div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;">This password will expire in {{ valid_hours }} hours.</div></td></tr><tr><td style="font-size:0px;padding:10px 25px;word-break:break-word;"><p style="border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:100%;"></p><!--[if mso | IE]><table align="center" border="0" cellpadding="0" cellspacing="0" style="border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:510px;" role="presentation" width="510px" ><tr><td style="height:0;line-height:0;"> &nbsp;
</td></tr></table><![endif]--></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:14px;line-height:1;text-align:center;color:#555555;">If you didn't request a password recovery you can disregard this email.</div></td></tr></table></div><!--[if mso | IE]></td></tr></table><![endif]--></td></tr></tbody></table></div><!--[if mso | IE]></td></tr></table><![endif]--></div></body></html>

================
File: backend/app/email-templates/build/test_email.html
================
<!doctype html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"><head><title></title><!--[if !mso]><!-- --><meta http-equiv="X-UA-Compatible" content="IE=edge"><!--<![endif]--><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><style type="text/css">#outlook a { padding:0; }
          .ReadMsgBody { width:100%; }
          .ExternalClass { width:100%; }
          .ExternalClass * { line-height:100%; }
          body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }
          table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }
          img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }
          p { display:block;margin:13px 0; }</style><!--[if !mso]><!--><style type="text/css">@media only screen and (max-width:480px) {
            @-ms-viewport { width:320px; }
            @viewport { width:320px; }
          }</style><!--<![endif]--><!--[if mso]>
        <xml>
        <o:OfficeDocumentSettings>
          <o:AllowPNG/>
          <o:PixelsPerInch>96</o:PixelsPerInch>
        </o:OfficeDocumentSettings>
        </xml>
        <![endif]--><!--[if lte mso 11]>
        <style type="text/css">
          .outlook-group-fix { width:100% !important; }
        </style>
        <![endif]--><style type="text/css">@media only screen and (min-width:480px) {
        .mj-column-per-100 { width:100% !important; max-width: 100%; }
      }</style><style type="text/css"></style></head><body style="background-color:#fafbfc;"><div style="background-color:#fafbfc;"><!--[if mso | IE]><table align="center" border="0" cellpadding="0" cellspacing="0" class="" style="width:600px;" width="600" ><tr><td style="line-height:0px;font-size:0px;mso-line-height-rule:exactly;"><![endif]--><div style="background:#ffffff;background-color:#ffffff;Margin:0px auto;max-width:600px;"><table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="background:#ffffff;background-color:#ffffff;width:100%;"><tbody><tr><td style="direction:ltr;font-size:0px;padding:40px 20px;text-align:center;vertical-align:top;"><!--[if mso | IE]><table role="presentation" border="0" cellpadding="0" cellspacing="0"><tr><td class="" style="vertical-align:middle;width:560px;" ><![endif]--><div class="mj-column-per-100 outlook-group-fix" style="font-size:13px;text-align:left;direction:ltr;display:inline-block;vertical-align:middle;width:100%;"><table border="0" cellpadding="0" cellspacing="0" role="presentation" style="vertical-align:middle;" width="100%"><tr><td align="center" style="font-size:0px;padding:35px;word-break:break-word;"><div style="font-family:Arial, Helvetica, sans-serif;font-size:20px;line-height:1;text-align:center;color:#333333;">{{ project_name }}</div></td></tr><tr><td align="center" style="font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;"><div style="font-family:, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;"><span>Test email for: {{ email }}</span></div></td></tr><tr><td style="font-size:0px;padding:10px 25px;word-break:break-word;"><p style="border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:100%;"></p><!--[if mso | IE]><table align="center" border="0" cellpadding="0" cellspacing="0" style="border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:510px;" role="presentation" width="510px" ><tr><td style="height:0;line-height:0;"> &nbsp;
</td></tr></table><![endif]--></td></tr></table></div><!--[if mso | IE]></td></tr></table><![endif]--></td></tr></tbody></table></div><!--[if mso | IE]></td></tr></table><![endif]--></div></body></html>

================
File: backend/app/email-templates/src/new_account.mjml
================
<mjml>
  <mj-body background-color="#fafbfc">
    <mj-section background-color="#fff" padding="40px 20px">
      <mj-column vertical-align="middle" width="100%">
        <mj-text align="center" padding="35px" font-size="20px" color="#333">{{ project_name }} - New Account</mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555"><span>Welcome to your new account!</span></mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555">Here are your account details:</mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555">Username: {{ username }}</mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555">Password: {{ password }}</mj-text>
        <mj-button align="center" font-size="18px" background-color="#009688" border-radius="8px" color="#fff" href="{{ link }}" padding="15px 30px">Go to Dashboard</mj-button>
        <mj-divider border-color="#ccc" border-width="2px"></mj-divider>
      </mj-column>
    </mj-section>
  </mj-body>
</mjml>

================
File: backend/app/email-templates/src/reset_password.mjml
================
<mjml>
  <mj-body background-color="#fafbfc">
    <mj-section background-color="#fff" padding="40px 20px">
      <mj-column vertical-align="middle" width="100%">
        <mj-text align="center" padding="35px" font-size="20px" font-family="Arial, Helvetica, sans-serif" color="#333">{{ project_name }} - Password Recovery</mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555"><span>Hello {{ username }}</span></mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555">We've received a request to reset your password. You can do it by clicking the button below:</mj-text>
        <mj-button align="center" font-size="18px" background-color="#009688" border-radius="8px" color="#fff" href="{{ link }}" padding="15px 30px">Reset password</mj-button>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555">Or copy and paste the following link into your browser:</mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555"><a href="{{ link }}">{{ link }}</a></mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555">This password will expire in {{ valid_hours }} hours.</mj-text>
        <mj-divider border-color="#ccc" border-width="2px"></mj-divider>
        <mj-text align="center" font-size="14px" padding-left="25px" padding-right="25px" font-family="Arial, Helvetica, sans-serif" color="#555">If you didn't request a password recovery you can disregard this email.</mj-text>
      </mj-column>
    </mj-section>
  </mj-body>
</mjml>

================
File: backend/app/email-templates/src/test_email.mjml
================
<mjml>
  <mj-body background-color="#fafbfc">
    <mj-section background-color="#fff" padding="40px 20px">
      <mj-column vertical-align="middle" width="100%">
        <mj-text align="center" padding="35px" font-size="20px" font-family="Arial, Helvetica, sans-serif" color="#333">{{ project_name }}</mj-text>
        <mj-text align="center" font-size="16px" padding-left="25px" padding-right="25px" font-family=", sans-serif" color="#555"><span>Test email for: {{ email }}</span></mj-text>
        <mj-divider border-color="#ccc" border-width="2px"></mj-divider>
      </mj-column>
    </mj-section>
  </mj-body>
</mjml>

================
File: backend/app/modules/email/services/email_event_handlers.py
================
"""
Email event handlers.

This module contains event handlers for email-related events.
"""
from app.core.events import event_handler
from app.core.logging import get_logger
from app.modules.email.services.email_service import EmailService
from app.modules.users.domain.events import UserCreatedEvent

# Configure logger
logger = get_logger("email_event_handlers")


def get_email_service() -> EmailService:
    """
    Get email service instance.
    
    Returns:
        EmailService instance
    """
    return EmailService()


@event_handler("user.created")
def handle_user_created_event(event: UserCreatedEvent) -> None:
    """
    Handle user created event by sending welcome email.
    
    Args:
        event: User created event
    """
    logger.info(f"Handling user.created event for user {event.user_id}")
    
    # Get email service
    email_service = get_email_service()
    
    # Send welcome email
    # Note: We don't have the actual password here, so we use a placeholder
    # The password is only known at creation time and not stored in plain text
    success = email_service.send_new_account_email(
        email_to=event.email,
        username=event.email,  # Using email as username
        password="**********"  # Password is masked in welcome email
    )
    
    if success:
        logger.info(f"Welcome email sent to {event.email}")
    else:
        logger.error(f"Failed to send welcome email to {event.email}")

================
File: backend/app/modules/users/domain/events.py
================
"""
User domain events.

This module defines events related to user operations.
"""
import uuid
from typing import Optional

from app.core.events import EventBase, publish_event


class UserCreatedEvent(EventBase):
    """
    Event emitted when a new user is created.
    
    This event is published after a user is successfully created
    and can be used by other modules to perform actions like
    sending welcome emails.
    """
    event_type: str = "user.created"
    user_id: uuid.UUID
    email: str
    full_name: Optional[str] = None
    
    def publish(self) -> None:
        """
        Publish this event to all registered handlers.
        
        This is a convenience method to make publishing events cleaner.
        """
        publish_event(self)

================
File: backend/app/tests/scripts/test_backend_pre_start.py
================
from unittest.mock import MagicMock, patch

from sqlmodel import select

from app.backend_pre_start import init, logger


def test_init_successful_connection() -> None:
    engine_mock = MagicMock()

    session_mock = MagicMock()
    exec_mock = MagicMock(return_value=True)
    session_mock.configure_mock(**{"exec.return_value": exec_mock})

    with (
        patch("sqlmodel.Session", return_value=session_mock),
        patch.object(logger, "info"),
        patch.object(logger, "error"),
        patch.object(logger, "warn"),
    ):
        try:
            init(engine_mock)
            connection_successful = True
        except Exception:
            connection_successful = False

        assert (
            connection_successful
        ), "The database connection should be successful and not raise an exception."

        assert session_mock.exec.called_once_with(
            select(1)
        ), "The session should execute a select statement once."

================
File: backend/app/tests/scripts/test_test_pre_start.py
================
from unittest.mock import MagicMock, patch

from sqlmodel import select

from app.tests_pre_start import init, logger


def test_init_successful_connection() -> None:
    engine_mock = MagicMock()

    session_mock = MagicMock()
    exec_mock = MagicMock(return_value=True)
    session_mock.configure_mock(**{"exec.return_value": exec_mock})

    with (
        patch("sqlmodel.Session", return_value=session_mock),
        patch.object(logger, "info"),
        patch.object(logger, "error"),
        patch.object(logger, "warn"),
    ):
        try:
            init(engine_mock)
            connection_successful = True
        except Exception:
            connection_successful = False

        assert (
            connection_successful
        ), "The database connection should be successful and not raise an exception."

        assert session_mock.exec.called_once_with(
            select(1)
        ), "The session should execute a select statement once."

================
File: backend/app/tests/utils/item.py
================
from sqlmodel import Session

from app.modules.items.domain.models import Item, ItemCreate
from app.modules.items.repository.item_repo import ItemRepository
from app.modules.items.services.item_service import ItemService
from app.tests.utils.user import create_random_user
from app.tests.utils.utils import random_lower_string


def create_random_item(db: Session) -> Item:
    user = create_random_user(db)
    owner_id = user.id
    assert owner_id is not None
    title = random_lower_string()
    description = random_lower_string()
    item_in = ItemCreate(title=title, description=description)
    item_repo = ItemRepository(db)
    item_service = ItemService(item_repo)
    return item_service.create_item(owner_id=owner_id, item_create=item_in)

================
File: backend/app/tests/utils/user.py
================
from fastapi.testclient import TestClient
from sqlmodel import Session

from app.core.config import settings
from app.modules.users.domain.models import User, UserCreate, UserUpdate
from app.modules.users.repository.user_repo import UserRepository
from app.modules.users.services.user_service import UserService
from app.tests.utils.utils import random_email, random_lower_string


def user_authentication_headers(
    *, client: TestClient, email: str, password: str
) -> dict[str, str]:
    data = {"username": email, "password": password}

    r = client.post(f"{settings.API_V1_STR}/login/access-token", data=data)
    response = r.json()
    auth_token = response["access_token"]
    headers = {"Authorization": f"Bearer {auth_token}"}
    return headers


def create_random_user(db: Session) -> User:
    email = random_email()
    password = random_lower_string()
    user_in = UserCreate(email=email, password=password)
    user_repo = UserRepository(db)
    user_service = UserService(user_repo)
    user = user_service.create_user(user_create=user_in)
    return user


def authentication_token_from_email(
    *, client: TestClient, email: str, db: Session
) -> dict[str, str]:
    """
    Return a valid token for the user with given email.

    If the user doesn't exist it is created first.
    """
    password = random_lower_string()
    user_repo = UserRepository(db)
    user_service = UserService(user_repo)

    user = user_service.get_by_email(email=email)
    if not user:
        user_in_create = UserCreate(email=email, password=password)
        user = user_service.create_user(user_create=user_in_create)
    else:
        user_in_update = UserUpdate(password=password)
        if not user.id:
            raise Exception("User id not set")
        user = user_service.update_user(user_id=user.id, user_update=user_in_update)

    return user_authentication_headers(client=client, email=email, password=password)

================
File: backend/app/tests/utils/utils.py
================
import random
import string

from fastapi.testclient import TestClient

from app.core.config import settings


def random_lower_string() -> str:
    return "".join(random.choices(string.ascii_lowercase, k=32))


def random_email() -> str:
    return f"{random_lower_string()}@{random_lower_string()}.com"


def get_superuser_token_headers(client: TestClient) -> dict[str, str]:
    login_data = {
        "username": settings.FIRST_SUPERUSER,
        "password": settings.FIRST_SUPERUSER_PASSWORD,
    }
    r = client.post(f"{settings.API_V1_STR}/login/access-token", data=login_data)
    tokens = r.json()
    a_token = tokens["access_token"]
    headers = {"Authorization": f"Bearer {a_token}"}
    return headers

================
File: backend/app/backend_pre_start.py
================
import logging

from sqlalchemy import Engine
from sqlmodel import Session, select
from tenacity import after_log, before_log, retry, stop_after_attempt, wait_fixed

from app.core.db import engine

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

max_tries = 60 * 5  # 5 minutes
wait_seconds = 1


@retry(
    stop=stop_after_attempt(max_tries),
    wait=wait_fixed(wait_seconds),
    before=before_log(logger, logging.INFO),
    after=after_log(logger, logging.WARN),
)
def init(db_engine: Engine) -> None:
    try:
        with Session(db_engine) as session:
            # Try to create session to check if DB is awake
            session.exec(select(1))
    except Exception as e:
        logger.error(e)
        raise e


def main() -> None:
    logger.info("Initializing service")
    init(engine)
    logger.info("Service finished initializing")


if __name__ == "__main__":
    main()

================
File: backend/app/initial_data.py
================
import logging

from sqlmodel import Session

from app.core.db import engine, init_db

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def init() -> None:
    with Session(engine) as session:
        init_db(session)


def main() -> None:
    logger.info("Creating initial data")
    init()
    logger.info("Initial data created")


if __name__ == "__main__":
    main()

================
File: backend/app/tests_pre_start.py
================
import logging

from sqlalchemy import Engine
from sqlmodel import Session, select
from tenacity import after_log, before_log, retry, stop_after_attempt, wait_fixed

from app.core.db import engine

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

max_tries = 60 * 5  # 5 minutes
wait_seconds = 1


@retry(
    stop=stop_after_attempt(max_tries),
    wait=wait_fixed(wait_seconds),
    before=before_log(logger, logging.INFO),
    after=after_log(logger, logging.WARN),
)
def init(db_engine: Engine) -> None:
    try:
        # Try to create session to check if DB is awake
        with Session(db_engine) as session:
            session.exec(select(1))
    except Exception as e:
        logger.error(e)
        raise e


def main() -> None:
    logger.info("Initializing service")
    init(engine)
    logger.info("Service finished initializing")


if __name__ == "__main__":
    main()

================
File: backend/examples/module_example/api/__init__.py
================
"""
Example API package.

This package contains API routes for the example module.
"""

================
File: backend/examples/module_example/api/routes.py
================
"""
Example API routes.

This module provides API endpoints for the example module.
"""
import uuid
from typing import Any

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import CurrentUser, SessionDep
from app.shared.exceptions import NotFoundException
from app.shared.models import Message
from backend.examples.module_example.domain.models import (
    ProductCreate,
    ProductPublic,
    ProductsPublic,
    ProductUpdate,
)
from backend.examples.module_example.repository.example_repo import ExampleRepository
from backend.examples.module_example.services.example_service import ExampleService

# Create router
router = APIRouter(prefix="/examples", tags=["examples"])


# Dependencies
def get_example_service(session: SessionDep) -> ExampleService:
    """
    Get example service.
    
    Args:
        session: Database session
        
    Returns:
        Example service
    """
    example_repo = ExampleRepository(session)
    return ExampleService(example_repo)


# Routes
@router.get("/", response_model=ProductsPublic)
def read_products(
    session: SessionDep,
    current_user: CurrentUser,
    example_service: ExampleService = Depends(get_example_service),
    skip: int = 0,
    limit: int = 100,
) -> Any:
    """
    Retrieve products.
    
    Args:
        session: Database session
        current_user: Current user
        example_service: Example service
        skip: Number of records to skip
        limit: Maximum number of records to return
        
    Returns:
        List of products
    """
    products = example_service.get_multi(skip=skip, limit=limit)
    count = len(products)  # For simplicity, using length instead of count query
    return example_service.to_public_list(products, count)


@router.post("/", response_model=ProductPublic, status_code=status.HTTP_201_CREATED)
def create_product(
    *,
    session: SessionDep,
    current_user: CurrentUser,
    product_in: ProductCreate,
    example_service: ExampleService = Depends(get_example_service),
) -> Any:
    """
    Create new product.
    
    Args:
        session: Database session
        current_user: Current user
        product_in: Product creation data
        example_service: Example service
        
    Returns:
        Created product
    """
    product = example_service.create_product(product_in)
    return example_service.to_public(product)


@router.get("/{product_id}", response_model=ProductPublic)
def read_product(
    product_id: uuid.UUID,
    session: SessionDep,
    current_user: CurrentUser,
    example_service: ExampleService = Depends(get_example_service),
) -> Any:
    """
    Get product by ID.
    
    Args:
        product_id: Product ID
        session: Database session
        current_user: Current user
        example_service: Example service
        
    Returns:
        Product
        
    Raises:
        HTTPException: If product not found
    """
    try:
        product = example_service.get_by_id(product_id)
        return example_service.to_public(product)
    except NotFoundException as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.put("/{product_id}", response_model=ProductPublic)
def update_product(
    *,
    product_id: uuid.UUID,
    session: SessionDep,
    current_user: CurrentUser,
    product_in: ProductUpdate,
    example_service: ExampleService = Depends(get_example_service),
) -> Any:
    """
    Update product.
    
    Args:
        product_id: Product ID
        session: Database session
        current_user: Current user
        product_in: Product update data
        example_service: Example service
        
    Returns:
        Updated product
        
    Raises:
        HTTPException: If product not found
    """
    try:
        product = example_service.update_product(product_id, product_in)
        return example_service.to_public(product)
    except NotFoundException as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.delete("/{product_id}", response_model=Message)
def delete_product(
    product_id: uuid.UUID,
    session: SessionDep,
    current_user: CurrentUser,
    example_service: ExampleService = Depends(get_example_service),
) -> Any:
    """
    Delete product.
    
    Args:
        product_id: Product ID
        session: Database session
        current_user: Current user
        example_service: Example service
        
    Returns:
        Success message
        
    Raises:
        HTTPException: If product not found
    """
    try:
        example_service.delete_product(product_id)
        return Message(message="Product deleted successfully")
    except NotFoundException as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

================
File: backend/examples/module_example/domain/__init__.py
================
"""
Example domain package.

This package contains domain models and events for the example module.
"""

================
File: backend/examples/module_example/domain/events.py
================
"""
Example domain events.

This module contains domain events related to the example module.
"""
import uuid
from typing import Optional

from app.core.events import EventBase


class ProductCreatedEvent(EventBase):
    """Event published when a product is created."""
    event_type: str = "product.created"
    product_id: uuid.UUID
    name: str
    price: float
    
    def publish(self) -> None:
        """Publish the event."""
        from app.core.events import publish_event
        publish_event(self)


class ProductUpdatedEvent(EventBase):
    """Event published when a product is updated."""
    event_type: str = "product.updated"
    product_id: uuid.UUID
    name: Optional[str] = None
    price: Optional[float] = None
    
    def publish(self) -> None:
        """Publish the event."""
        from app.core.events import publish_event
        publish_event(self)


class ProductDeletedEvent(EventBase):
    """Event published when a product is deleted."""
    event_type: str = "product.deleted"
    product_id: uuid.UUID
    
    def publish(self) -> None:
        """Publish the event."""
        from app.core.events import publish_event
        publish_event(self)

================
File: backend/examples/module_example/domain/models.py
================
"""
Example domain models.

This module contains domain models related to the example module.
"""
import uuid
from typing import List, Optional

from sqlmodel import Field, SQLModel

from app.shared.models import BaseModel


# Define your models here
class ProductBase(SQLModel):
    """Base product model with common properties."""
    name: str = Field(max_length=255)
    description: Optional[str] = Field(default=None, max_length=255)
    price: float = Field(gt=0)
    in_stock: bool = True


class ProductCreate(ProductBase):
    """Model for creating a product."""
    pass


class ProductUpdate(ProductBase):
    """Model for updating a product."""
    name: Optional[str] = Field(default=None, max_length=255)  # type: ignore
    description: Optional[str] = Field(default=None, max_length=255)
    price: Optional[float] = Field(default=None, gt=0)  # type: ignore
    in_stock: Optional[bool] = None  # type: ignore


class Product(ProductBase, BaseModel, table=True):
    """Database model for a product."""
    __tablename__ = "product"

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)


class ProductPublic(ProductBase):
    """Public product model for API responses."""
    id: uuid.UUID


class ProductsPublic(SQLModel):
    """List of public products for API responses."""
    data: List[ProductPublic]
    count: int

================
File: backend/examples/module_example/repository/__init__.py
================
"""
Example repository package.

This package contains repository implementations for the example module.
"""

================
File: backend/examples/module_example/repository/example_repo.py
================
"""
Example repository.

This module provides data access for the example module.
"""
import uuid
from typing import List, Optional

from sqlmodel import Session, select

# For demonstration purposes, we'll use a mock Product class
# In a real implementation, you would use the legacy model during transition
class Product:
    """Mock Product class for demonstration."""
    def __init__(self, id=None, name=None, description=None, price=None, in_stock=True):
        self.id = id or uuid.uuid4()
        self.name = name
        self.description = description
        self.price = price
        self.in_stock = in_stock


class ExampleRepository:
    """Repository for example module."""
    
    def __init__(self, session: Session):
        """
        Initialize repository with database session.
        
        Args:
            session: Database session
        """
        self.session = session
        # For demonstration, we'll use an in-memory store
        self.products = {}
    
    def get_by_id(self, product_id: uuid.UUID) -> Product:
        """
        Get product by ID.
        
        Args:
            product_id: Product ID
            
        Returns:
            Product
            
        Raises:
            NotFoundException: If product not found
        """
        product = self.products.get(product_id)
        if not product:
            from app.shared.exceptions import NotFoundException
            raise NotFoundException(f"Product with ID {product_id} not found")
        return product
    
    def get_multi(self, *, skip: int = 0, limit: int = 100) -> List[Product]:
        """
        Get multiple products.
        
        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            List of products
        """
        products = list(self.products.values())
        return products[skip:skip+limit]
    
    def count(self) -> int:
        """
        Count total products.
        
        Returns:
            Total count
        """
        return len(self.products)
    
    def create(self, product: Product) -> Product:
        """
        Create new product.
        
        Args:
            product: Product to create
            
        Returns:
            Created product
        """
        # In a real implementation, you would add to the database
        # For demonstration, we'll add to our in-memory store
        self.products[product.id] = product
        return product
    
    def update(self, product: Product) -> Product:
        """
        Update product.
        
        Args:
            product: Product to update
            
        Returns:
            Updated product
        """
        # In a real implementation, you would update in the database
        # For demonstration, we'll update our in-memory store
        self.products[product.id] = product
        return product
    
    def delete(self, product_id: uuid.UUID) -> None:
        """
        Delete product.
        
        Args:
            product_id: Product ID
            
        Raises:
            NotFoundException: If product not found
        """
        # Check if product exists
        self.get_by_id(product_id)
        # In a real implementation, you would delete from the database
        # For demonstration, we'll delete from our in-memory store
        del self.products[product_id]

================
File: backend/examples/module_example/services/__init__.py
================
"""
Example services package.

This package contains service implementations for the example module.
"""

================
File: backend/examples/module_example/services/event_handlers.py
================
"""
Example event handlers.

This module contains event handlers for the example module.
"""
from app.core.events import event_handler
from app.core.logging import get_logger
from app.modules.users.domain.events import UserCreatedEvent

# Initialize logger
logger = get_logger("example_event_handlers")


@event_handler("user.created")
def handle_user_created(event: UserCreatedEvent) -> None:
    """
    Handle user created event.
    
    This is an example of how to subscribe to events from other modules.
    
    Args:
        event: User created event
    """
    logger.info(f"Example module received user.created event for user {event.user_id}")
    # In a real implementation, you might create a default product for the new user
    # or perform some other business logic

================
File: backend/examples/module_example/services/example_service.py
================
"""
Example service.

This module provides business logic for the example module.
"""
import uuid
from typing import List, Optional

from app.core.logging import get_logger
from backend.examples.module_example.domain.events import (
    ProductCreatedEvent,
    ProductDeletedEvent,
    ProductUpdatedEvent,
)
from backend.examples.module_example.domain.models import (
    ProductCreate,
    ProductPublic,
    ProductsPublic,
    ProductUpdate,
)
from backend.examples.module_example.repository.example_repo import (
    ExampleRepository,
    Product,
)

# Initialize logger
logger = get_logger("example_service")


class ExampleService:
    """Service for example module."""
    
    def __init__(self, example_repo: ExampleRepository):
        """
        Initialize service with repository.
        
        Args:
            example_repo: Example repository
        """
        self.example_repo = example_repo
    
    def get_by_id(self, product_id: uuid.UUID) -> Product:
        """
        Get product by ID.
        
        Args:
            product_id: Product ID
            
        Returns:
            Product
            
        Raises:
            NotFoundException: If product not found
        """
        return self.example_repo.get_by_id(product_id)
    
    def get_multi(self, *, skip: int = 0, limit: int = 100) -> List[Product]:
        """
        Get multiple products.
        
        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            List of products
        """
        return self.example_repo.get_multi(skip=skip, limit=limit)
    
    def create_product(self, product_create: ProductCreate) -> Product:
        """
        Create new product.
        
        Args:
            product_create: Product creation data
            
        Returns:
            Created product
        """
        # Create product using the mock model for demonstration
        product = Product(
            name=product_create.name,
            description=product_create.description,
            price=product_create.price,
            in_stock=product_create.in_stock,
        )
        
        created_product = self.example_repo.create(product)
        logger.info(f"Created product with ID {created_product.id}")
        
        # Publish event
        event = ProductCreatedEvent(
            product_id=created_product.id,
            name=created_product.name,
            price=created_product.price,
        )
        event.publish()
        
        return created_product
    
    def update_product(
        self, product_id: uuid.UUID, product_update: ProductUpdate
    ) -> Product:
        """
        Update product.
        
        Args:
            product_id: Product ID
            product_update: Product update data
            
        Returns:
            Updated product
            
        Raises:
            NotFoundException: If product not found
        """
        product = self.get_by_id(product_id)
        
        # Update fields if provided
        update_data = product_update.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(product, field, value)
        
        updated_product = self.example_repo.update(product)
        logger.info(f"Updated product with ID {updated_product.id}")
        
        # Publish event
        event = ProductUpdatedEvent(
            product_id=updated_product.id,
            name=updated_product.name if "name" in update_data else None,
            price=updated_product.price if "price" in update_data else None,
        )
        event.publish()
        
        return updated_product
    
    def delete_product(self, product_id: uuid.UUID) -> None:
        """
        Delete product.
        
        Args:
            product_id: Product ID
            
        Raises:
            NotFoundException: If product not found
        """
        self.example_repo.delete(product_id)
        logger.info(f"Deleted product with ID {product_id}")
        
        # Publish event
        event = ProductDeletedEvent(product_id=product_id)
        event.publish()
    
    # Public model conversions
    
    def to_public(self, product: Product) -> ProductPublic:
        """
        Convert product to public model.
        
        Args:
            product: Product to convert
            
        Returns:
            Public product
        """
        return ProductPublic(
            id=product.id,
            name=product.name,
            description=product.description,
            price=product.price,
            in_stock=product.in_stock,
        )
    
    def to_public_list(self, products: List[Product], count: int) -> ProductsPublic:
        """
        Convert list of products to public model.
        
        Args:
            products: Products to convert
            count: Total count
            
        Returns:
            Public products list
        """
        return ProductsPublic(
            data=[self.to_public(product) for product in products],
            count=count,
        )

================
File: backend/examples/module_example/__init__.py
================
"""
Example module initialization.

This module demonstrates how to create a new module in the modular monolith architecture.
"""
from fastapi import FastAPI

from app.core.config import settings
from app.core.logging import get_logger

# Initialize logger
logger = get_logger("example_module")


def init_example_module(app: FastAPI) -> None:
    """
    Initialize example module.

    This function registers all routes and initializes the module.

    Args:
        app: FastAPI application
    """
    from backend.examples.module_example.api.routes import router as example_router

    # Include the router in the application
    app.include_router(example_router, prefix=settings.API_V1_STR)

    logger.info("Example module initialized")

================
File: backend/examples/__init__.py
================
"""
Examples package.

This package contains examples of how to extend the modular monolith architecture.
"""

================
File: backend/examples/README.md
================
# Examples

This directory contains examples of how to extend the modular monolith architecture.

## Module Example

The `module_example` directory demonstrates how to create a new module in the modular monolith architecture. It includes:

- Module initialization
- Domain models and events
- Repository implementation
- Service implementation
- API routes
- Event handlers

### Using the Example

To use this example in a real project:

1. Copy the `module_example` directory to `app/modules/your_module_name`
2. Rename all occurrences of "example" to your module name
3. Update the module initialization in `app/api/main.py`
4. Implement your business logic

### Key Features Demonstrated

- **Domain Models**: How to define domain models for your module
- **Events**: How to publish and subscribe to events
- **Repository Pattern**: How to implement data access
- **Service Layer**: How to implement business logic
- **API Routes**: How to expose functionality via REST API
- **Dependency Injection**: How to use FastAPI's dependency injection

## Event System Example

The example module demonstrates how to use the event system:

- **Publishing Events**: See `services/example_service.py` for examples of publishing events
- **Subscribing to Events**: See `services/event_handlers.py` for an example of subscribing to events

### Event Flow

1. An event is published from a service (e.g., `ProductCreatedEvent`)
2. The event is processed by the event system
3. Any registered handlers for that event type are called

## Best Practices Demonstrated

- **Separation of Concerns**: Each layer has a specific responsibility
- **Domain-Driven Design**: Models and events are defined in the domain layer
- **Repository Pattern**: Data access is abstracted behind repositories
- **Service Layer**: Business logic is implemented in services
- **Dependency Injection**: Dependencies are injected rather than imported directly
- **Event-Driven Communication**: Modules communicate via events

================
File: backend/scripts/format.sh
================
#!/bin/sh -e
set -x

ruff check app scripts --fix
ruff format app scripts

================
File: backend/scripts/lint.sh
================
#!/usr/bin/env bash

set -e
set -x

mypy app
ruff check app
ruff format app --check

================
File: backend/scripts/prestart.sh
================
#! /usr/bin/env bash

set -e
set -x

# Let the DB start
python app/backend_pre_start.py

# Run migrations
alembic upgrade head

# Create initial data in DB
python app/initial_data.py

================
File: backend/scripts/test.sh
================
#!/usr/bin/env bash

set -e
set -x

coverage run --source=app -m pytest
coverage report --show-missing
coverage html --title "${@-coverage}"

================
File: backend/scripts/tests-start.sh
================
#! /usr/bin/env bash
set -e
set -x

python app/tests_pre_start.py

bash scripts/test.sh "$@"

================
File: backend/tests/core/test_events.py
================
"""
Tests for the event system.

This module tests the core event system functionality.
"""
import asyncio
from unittest.mock import MagicMock, patch

import pytest
from pydantic import BaseModel

from app.core.events import (
    EventBase,
    event_handler,
    publish_event,
    subscribe_to_event,
    unsubscribe_from_event,
)


# Sample event classes for testing - not actual test classes
class SampleEvent(EventBase):
    """Sample event class for testing."""
    event_type: str = "test.event"
    data: str


class SampleEventWithPayload(EventBase):
    """Sample event with additional payload for testing."""
    event_type: str = "test.event.payload"
    id: int
    name: str
    details: dict


def test_event_base_initialization():
    """Test EventBase initialization."""
    # Arrange & Act
    event = SampleEvent(data="test data")

    # Assert
    assert event.event_type == "test.event"
    assert event.data == "test data"
    assert isinstance(event, EventBase)
    assert isinstance(event, BaseModel)


def test_event_with_payload_initialization():
    """Test event with payload initialization."""
    # Arrange & Act
    event = SampleEventWithPayload(
        id=1,
        name="test",
        details={"key": "value"}
    )

    # Assert
    assert event.event_type == "test.event.payload"
    assert event.id == 1
    assert event.name == "test"
    assert event.details == {"key": "value"}


def test_subscribe_and_publish_event():
    """Test subscribing to and publishing an event."""
    # Arrange
    mock_handler = MagicMock()
    mock_handler.__name__ = "mock_handler"  # Add __name__ attribute
    event = SampleEvent(data="test data")

    # Act
    subscribe_to_event("test.event", mock_handler)
    publish_event(event)

    # Assert
    mock_handler.assert_called_once_with(event)

    # Cleanup
    unsubscribe_from_event("test.event", mock_handler)


def test_unsubscribe_from_event():
    """Test unsubscribing from an event."""
    # Arrange
    mock_handler = MagicMock()
    mock_handler.__name__ = "mock_handler"  # Add __name__ attribute
    event = SampleEvent(data="test data")
    subscribe_to_event("test.event", mock_handler)

    # Act
    unsubscribe_from_event("test.event", mock_handler)
    publish_event(event)

    # Assert
    mock_handler.assert_not_called()


def test_multiple_handlers_for_event():
    """Test multiple handlers for the same event."""
    # Arrange
    mock_handler1 = MagicMock()
    mock_handler1.__name__ = "mock_handler1"  # Add __name__ attribute
    mock_handler2 = MagicMock()
    mock_handler2.__name__ = "mock_handler2"  # Add __name__ attribute
    event = SampleEvent(data="test data")

    # Act
    subscribe_to_event("test.event", mock_handler1)
    subscribe_to_event("test.event", mock_handler2)
    publish_event(event)

    # Assert
    mock_handler1.assert_called_once_with(event)
    mock_handler2.assert_called_once_with(event)

    # Cleanup
    unsubscribe_from_event("test.event", mock_handler1)
    unsubscribe_from_event("test.event", mock_handler2)


def test_event_handler_decorator():
    """Test event_handler decorator."""
    # Arrange
    mock_function = MagicMock()
    mock_function.__name__ = "mock_function"  # Add __name__ attribute

    # Act
    # We need to use the decorated function to avoid linting warnings
    decorated_function = event_handler("test.event")(mock_function)
    assert decorated_function == mock_function  # Verify decorator returns original function

    event = SampleEvent(data="test data")
    publish_event(event)

    # Assert
    mock_function.assert_called_once_with(event)

    # Cleanup
    unsubscribe_from_event("test.event", mock_function)


@pytest.mark.anyio(backends=["asyncio"])
async def test_async_event_handler():
    """Test async event handler."""
    # Arrange
    result = []

    async def async_handler(event):
        await asyncio.sleep(0.1)
        result.append(event.data)

    event = SampleEvent(data="async test")

    # Act
    subscribe_to_event("test.event", async_handler)
    publish_event(event)

    # Wait for async handler to complete
    await asyncio.sleep(0.2)

    # Assert
    assert result == ["async test"]

    # Cleanup
    unsubscribe_from_event("test.event", async_handler)


def test_error_in_handler_doesnt_affect_others():
    """Test that an error in one handler doesn't affect others."""
    # Arrange
    # Use a named function to avoid linting warnings about unused parameters
    def failing_handler(_):
        """Handler that always fails."""
        raise Exception("Test exception")

    success_handler = MagicMock()
    success_handler.__name__ = "success_handler"  # Add __name__ attribute
    event = SampleEvent(data="test data")

    # Act
    subscribe_to_event("test.event", failing_handler)
    subscribe_to_event("test.event", success_handler)

    with patch("app.core.events.logger") as mock_logger:
        publish_event(event)

    # Assert
    success_handler.assert_called_once_with(event)
    mock_logger.exception.assert_called_once()

    # Cleanup
    unsubscribe_from_event("test.event", failing_handler)
    unsubscribe_from_event("test.event", success_handler)


def test_publish_event_with_no_handlers():
    """Test publishing an event with no handlers."""
    # Arrange
    event = SampleEventWithPayload(id=1, name="test", details={})

    # Act & Assert (should not raise any exceptions)
    with patch("app.core.events.logger") as mock_logger:
        publish_event(event)

    # Verify debug log was called
    mock_logger.debug.assert_called_once()

================
File: backend/tests/modules/email/services/test_email_event_handlers.py
================
"""
Tests for email event handlers.
"""
import uuid
from unittest.mock import MagicMock, patch

import pytest

from app.modules.email.services.email_event_handlers import handle_user_created_event
from app.modules.users.domain.events import UserCreatedEvent


@pytest.fixture
def mock_email_service():
    """Fixture for mocked email service."""
    service = MagicMock()
    service.send_new_account_email.return_value = True
    return service


def test_handle_user_created_event(mock_email_service):
    """Test that user created event handler sends welcome email."""
    # Arrange
    user_id = uuid.uuid4()
    email = "test@example.com"
    full_name = "Test User"
    event = UserCreatedEvent(user_id=user_id, email=email, full_name=full_name)
    
    # Act
    with patch("app.modules.email.services.email_event_handlers.get_email_service", 
               return_value=mock_email_service):
        handle_user_created_event(event)
    
    # Assert
    mock_email_service.send_new_account_email.assert_called_once_with(
        email_to=email,
        username=email,  # Using email as username
        password="**********"  # Password is masked in welcome email
    )

================
File: backend/tests/modules/integration/test_user_email_integration.py
================
"""
Integration tests for user and email modules.

This module tests the integration between the user and email modules
via the event system.
"""
import uuid
from unittest.mock import MagicMock, patch

import pytest
from sqlmodel import Session

from app.modules.email.services.email_event_handlers import handle_user_created_event
from app.modules.users.domain.events import UserCreatedEvent
from app.modules.users.domain.models import UserCreate
from app.modules.users.repository.user_repo import UserRepository
from app.modules.users.services.user_service import UserService


@pytest.fixture
def mock_user_repo():
    """Fixture for mocked user repository."""
    repo = MagicMock(spec=UserRepository)

    # Mock the exists_by_email method to return False (user doesn't exist)
    repo.exists_by_email.return_value = False

    # Create a mock user with a fixed UUID for testing
    user_id = uuid.uuid4()
    user = MagicMock()
    user.id = user_id
    user.email = "test@example.com"
    user.full_name = "Test User"

    # Mock the create method to return the user
    repo.create.return_value = user

    return repo, user


@pytest.fixture
def mock_email_service():
    """Fixture for mocked email service."""
    service = MagicMock()
    service.send_new_account_email.return_value = True
    return service


def test_user_creation_triggers_email_via_event(mock_user_repo, mock_email_service):
    """
    Test that creating a user triggers an email via the event system.

    This is an integration test that verifies the event flow from
    user creation to email sending.
    """
    # Arrange
    mock_repo, mock_user = mock_user_repo
    user_service = UserService(mock_repo)

    user_create = UserCreate(
        email="test@example.com",
        password="password123",
        full_name="Test User",
        is_superuser=False,
        is_active=True,
    )

    # Mock the event publishing to capture the event
    with patch("app.modules.users.domain.events.publish_event") as mock_publish:
        # Act - Create the user
        user_service.create_user(user_create)

        # Assert - Verify event was published
        mock_publish.assert_called_once()

        # Get the published event
        event = mock_publish.call_args[0][0]
        assert isinstance(event, UserCreatedEvent)
        assert event.user_id == mock_user.id
        assert event.email == mock_user.email
        assert event.full_name == mock_user.full_name

        # Now test that the email handler processes this event correctly
        with patch("app.modules.email.services.email_event_handlers.get_email_service",
                   return_value=mock_email_service):
            # Act - Handle the event
            handle_user_created_event(event)

            # Assert - Verify email was sent
            mock_email_service.send_new_account_email.assert_called_once_with(
                email_to=mock_user.email,
                username=mock_user.email,
                password="**********"
            )

================
File: backend/tests/modules/shared/test_model_imports.py
================
"""
Tests for model imports.

This module tests that models can be imported from their modular locations.
"""
import pytest

# Test shared models
def test_shared_models_imports():
    """Test that shared models can be imported from app.shared.models."""
    from app.shared.models import Message, BaseModel, TimestampedModel, UUIDModel, PaginatedResponse
    
    assert Message
    assert BaseModel
    assert TimestampedModel
    assert UUIDModel
    assert PaginatedResponse


# Test auth models
def test_auth_models_imports():
    """Test that auth models can be imported from app.modules.auth.domain.models."""
    from app.modules.auth.domain.models import (
        TokenPayload,
        Token,
        NewPassword,
        PasswordReset,
        LoginRequest,
        RefreshToken,
    )
    
    assert TokenPayload
    assert Token
    assert NewPassword
    assert PasswordReset
    assert LoginRequest
    assert RefreshToken


# Test users models (non-table models)
def test_users_models_imports():
    """Test that user models can be imported from app.modules.users.domain.models."""
    from app.modules.users.domain.models import (
        UserBase,
        UserCreate,
        UserRegister,
        UserUpdate,
        UserUpdateMe,
        UpdatePassword,
        UserPublic,
        UsersPublic,
    )
    
    assert UserBase
    assert UserCreate
    assert UserRegister
    assert UserUpdate
    assert UserUpdateMe
    assert UpdatePassword
    assert UserPublic
    assert UsersPublic


# Test items models (non-table models)
def test_items_models_imports():
    """Test that item models can be imported from app.modules.items.domain.models."""
    from app.modules.items.domain.models import (
        ItemBase,
        ItemCreate,
        ItemUpdate,
        ItemPublic,
        ItemsPublic,
    )
    
    assert ItemBase
    assert ItemCreate
    assert ItemUpdate
    assert ItemPublic
    assert ItemsPublic


# Test email models
def test_email_models_imports():
    """Test that email models can be imported from app.modules.email.domain.models."""
    from app.modules.email.domain.models import (
        EmailTemplateType,
        EmailContent,
        EmailRequest,
        TemplateData,
    )
    
    assert EmailTemplateType
    assert EmailContent
    assert EmailRequest
    assert TemplateData

================
File: backend/tests/modules/users/domain/test_user_events.py
================
"""
Tests for user domain events.
"""
import uuid
from unittest.mock import patch

import pytest

from app.core.events import EventBase
from app.modules.users.domain.events import UserCreatedEvent
from app.modules.users.domain.models import UserPublic


def test_user_created_event_init():
    """Test UserCreatedEvent initialization."""
    # Arrange
    user_id = uuid.uuid4()
    email = "test@example.com"

    # Act
    event = UserCreatedEvent(user_id=user_id, email=email)

    # Assert
    assert event.event_type == "user.created"
    assert event.user_id == user_id
    assert event.email == email
    assert isinstance(event, EventBase)


def test_user_created_event_publish():
    """Test UserCreatedEvent publish method."""
    # Arrange
    user_id = uuid.uuid4()
    email = "test@example.com"
    event = UserCreatedEvent(user_id=user_id, email=email)

    # Act
    with patch("app.modules.users.domain.events.publish_event") as mock_publish_event:
        event.publish()

        # Assert
        mock_publish_event.assert_called_once_with(event)

================
File: backend/tests/modules/users/services/test_user_service_events.py
================
"""
Tests for user service event publishing.
"""
import uuid
from unittest.mock import MagicMock, patch

import pytest

from app.modules.users.domain.events import UserCreatedEvent
from app.modules.users.domain.models import UserCreate
from app.modules.users.repository.user_repo import UserRepository
from app.modules.users.services.user_service import UserService


@pytest.fixture
def mock_user_repo():
    """Fixture for mocked user repository."""
    repo = MagicMock(spec=UserRepository)

    # Mock the exists_by_email method to return False (user doesn't exist)
    repo.exists_by_email.return_value = False

    # Create a mock user instead of a real User instance
    user_id = uuid.uuid4()
    user = MagicMock()
    user.id = user_id
    user.email = "test@example.com"
    user.full_name = "Test User"

    repo.create.return_value = user

    return repo, user


def test_create_user_publishes_event(mock_user_repo):
    """Test that creating a user publishes a UserCreatedEvent."""
    # Arrange
    mock_repo, mock_user = mock_user_repo
    user_service = UserService(mock_repo)

    user_create = UserCreate(
        email="test@example.com",
        password="password123",
        full_name="Test User",
        is_superuser=False,
        is_active=True,
    )

    # Act & Assert
    with patch("app.modules.users.services.user_service.UserCreatedEvent") as mock_event_class:
        mock_event = MagicMock()
        mock_event_class.return_value = mock_event

        # Act
        user_service.create_user(user_create)

        # Assert
        mock_event_class.assert_called_once_with(
            user_id=mock_user.id,
            email=mock_user.email,
            full_name=mock_user.full_name,
        )
        mock_event.publish.assert_called_once()

================
File: backend/.dockerignore
================
# Python
__pycache__
app.egg-info
*.pyc
.mypy_cache
.coverage
htmlcov
.venv

================
File: backend/alembic.ini
================
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = app/alembic

# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# timezone to use when rendering the date
# within the migration file as well as the filename.
# string value is passed to dateutil.tz.gettz()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
#truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; this defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path
# version_locations = %(here)s/bar %(here)s/bat alembic/versions

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

================
File: backend/CODE_STYLE_GUIDE.md
================
# Code Style Guide

This document outlines the code style guidelines for the modular monolith architecture.

## General Principles

1. **Consistency**: Follow consistent patterns throughout the codebase
2. **Readability**: Write code that is easy to read and understand
3. **Maintainability**: Write code that is easy to maintain and extend
4. **Testability**: Write code that is easy to test

## Python Style Guidelines

### Imports

1. **Import Order**:
   - Standard library imports first
   - Third-party imports second
   - Application imports third
   - Sort imports alphabetically within each group

   ```python
   # Standard library imports
   import os
   import uuid
   from datetime import datetime
   from typing import Any, Dict, List, Optional

   # Third-party imports
   from fastapi import APIRouter, Depends, HTTPException, status
   from pydantic import EmailStr
   from sqlmodel import Session, select

   # Application imports
   from app.core.config import settings
   from app.core.logging import get_logger
   from app.modules.users.domain.models import UserCreate, UserPublic
   ```

2. **Import Style**:
   - Use absolute imports rather than relative imports
   - Import specific classes and functions rather than entire modules
   - Avoid wildcard imports (`from module import *`)

   ```python
   # Good
   from app.core.config import settings
   
   # Avoid
   from app.core import config
   config.settings
   
   # Bad
   from app.core.config import *
   ```

### Type Hints

1. **Use Type Hints**:
   - Add type hints to all function parameters and return values
   - Use `Optional` for parameters that can be `None`
   - Use `Any` sparingly and only when necessary

   ```python
   def get_user_by_id(user_id: uuid.UUID) -> Optional[User]:
       """Get user by ID."""
       return user_repo.get_by_id(user_id)
   ```

2. **Type Hint Style**:
   - Use `list[str]` instead of `List[str]` (Python 3.9+)
   - Use `dict[str, Any]` instead of `Dict[str, Any]` (Python 3.9+)
   - Use `Optional[str]` instead of `str | None` for clarity

   ```python
   # Good
   def get_items(skip: int = 0, limit: int = 100) -> list[Item]:
       """Get items with pagination."""
       return item_repo.get_multi(skip=skip, limit=limit)
   
   # Avoid
   def get_items(skip: int = 0, limit: int = 100) -> List[Item]:
       """Get items with pagination."""
       return item_repo.get_multi(skip=skip, limit=limit)
   ```

### Docstrings

1. **Docstring Style**:
   - Use Google-style docstrings
   - Include a brief description of the function
   - Document parameters, return values, and exceptions
   - Keep docstrings concise and focused

   ```python
   def create_user(user_create: UserCreate) -> User:
       """
       Create a new user.
       
       Args:
           user_create: User creation data
           
       Returns:
           Created user
           
       Raises:
           ValueError: If user with the same email already exists
       """
       # Implementation
   ```

2. **Module Docstrings**:
   - Include a docstring at the top of each module
   - Describe the purpose and contents of the module

   ```python
   """
   User repository module.
   
   This module provides data access for user-related operations.
   """
   ```

3. **Class Docstrings**:
   - Include a docstring for each class
   - Describe the purpose and behavior of the class

   ```python
   class UserRepository:
       """
       Repository for user-related data access.
       
       This class provides methods for creating, reading, updating,
       and deleting user records in the database.
       """
   ```

### Naming Conventions

1. **General Naming**:
   - Use descriptive names that convey the purpose
   - Avoid abbreviations unless they are widely understood
   - Be consistent with naming across the codebase

2. **Case Conventions**:
   - `snake_case` for variables, functions, methods, and modules
   - `PascalCase` for classes and type variables
   - `UPPER_CASE` for constants
   - `snake_case` for file names

   ```python
   # Variables and functions
   user_id = uuid.uuid4()
   def get_user_by_email(email: str) -> Optional[User]:
       pass
   
   # Classes
   class UserRepository:
       pass
   
   # Constants
   MAX_USERS = 100
   ```

3. **Naming Patterns**:
   - Prefix boolean variables and functions with `is_`, `has_`, `can_`, etc.
   - Use plural names for collections (lists, dictionaries, etc.)
   - Use singular names for individual items

   ```python
   # Boolean variables
   is_active = True
   has_permission = False
   
   # Collections
   users = [user1, user2, user3]
   
   # Individual items
   user = users[0]
   ```

### Code Structure

1. **Function Length**:
   - Keep functions short and focused on a single task
   - Aim for functions that are less than 20 lines
   - Extract complex logic into separate functions

2. **Line Length**:
   - Keep lines under 88 characters (Black default)
   - Use line breaks for long expressions
   - Use parentheses to group long expressions

   ```python
   # Good
   result = (
       very_long_function_name(
           long_argument1,
           long_argument2,
           long_argument3,
       )
   )
   
   # Avoid
   result = very_long_function_name(long_argument1, long_argument2, long_argument3)
   ```

3. **Whitespace**:
   - Use 4 spaces for indentation (no tabs)
   - Add a blank line between logical sections of code
   - Add a blank line between function and class definitions

### Error Handling

1. **Exception Types**:
   - Use specific exception types rather than generic ones
   - Create custom exceptions for domain-specific errors
   - Document exceptions in docstrings

   ```python
   class UserNotFoundError(Exception):
       """Raised when a user is not found."""
       pass
   
   def get_user_by_id(user_id: uuid.UUID) -> User:
       """
       Get user by ID.
       
       Args:
           user_id: User ID
           
       Returns:
           User
           
       Raises:
           UserNotFoundError: If user not found
       """
       user = user_repo.get_by_id(user_id)
       if not user:
           raise UserNotFoundError(f"User with ID {user_id} not found")
       return user
   ```

2. **Error Messages**:
   - Include relevant information in error messages
   - Make error messages actionable
   - Use consistent error message formats

   ```python
   # Good
   raise ValueError(f"User with email {email} already exists")
   
   # Avoid
   raise ValueError("User exists")
   ```

## Module-Specific Guidelines

### Domain Models

1. **Model Structure**:
   - Define base models with common properties
   - Extend base models for specific use cases
   - Use clear and consistent naming

   ```python
   class UserBase(SQLModel):
       """Base user model with common properties."""
       email: str = Field(unique=True, index=True, max_length=255)
       is_active: bool = True
   
   class UserCreate(UserBase):
       """Model for creating a user."""
       password: str = Field(min_length=8, max_length=40)
   
   class UserUpdate(UserBase):
       """Model for updating a user."""
       email: Optional[str] = Field(default=None, max_length=255)
       password: Optional[str] = Field(default=None, min_length=8, max_length=40)
   ```

2. **Field Validation**:
   - Add validation constraints to fields
   - Document validation constraints in docstrings
   - Use consistent validation patterns

   ```python
   class UserCreate(UserBase):
       """Model for creating a user."""
       password: str = Field(
           min_length=8,
           max_length=40,
           description="User password (8-40 characters)",
       )
   ```

### Repositories

1. **Repository Methods**:
   - Include standard CRUD methods (create, read, update, delete)
   - Add domain-specific query methods as needed
   - Use consistent naming and parameter patterns

   ```python
   class UserRepository:
       """Repository for user-related data access."""
       
       def get_by_id(self, user_id: uuid.UUID) -> Optional[User]:
           """Get user by ID."""
           return self.session.get(User, user_id)
       
       def get_by_email(self, email: str) -> Optional[User]:
           """Get user by email."""
           statement = select(User).where(User.email == email)
           return self.session.exec(statement).first()
   ```

2. **Error Handling**:
   - Raise specific exceptions for domain-specific errors
   - Document exceptions in docstrings
   - Handle database errors appropriately

   ```python
   def create(self, user: User) -> User:
       """
       Create new user.
       
       Args:
           user: User to create
           
       Returns:
           Created user
           
       Raises:
           ValueError: If user with the same email already exists
       """
       existing_user = self.get_by_email(user.email)
       if existing_user:
           raise ValueError(f"User with email {user.email} already exists")
       
       self.session.add(user)
       self.session.commit()
       self.session.refresh(user)
       return user
   ```

### Services

1. **Service Methods**:
   - Include business logic for domain operations
   - Coordinate repository calls and other services
   - Handle domain-specific validation and rules

   ```python
   class UserService:
       """Service for user-related operations."""
       
       def create_user(self, user_create: UserCreate) -> User:
           """
           Create a new user.
           
           Args:
               user_create: User creation data
               
           Returns:
               Created user
               
           Raises:
               ValueError: If user with the same email already exists
           """
           # Hash the password
           hashed_password = get_password_hash(user_create.password)
           
           # Create the user
           user = User(
               email=user_create.email,
               hashed_password=hashed_password,
               is_active=user_create.is_active,
           )
           
           # Save the user
           created_user = self.user_repo.create(user)
           
           # Publish event
           event = UserCreatedEvent(user_id=created_user.id, email=created_user.email)
           event.publish()
           
           return created_user
   ```

2. **Event Publishing**:
   - Publish domain events for significant state changes
   - Include relevant information in events
   - Document event publishing in docstrings

   ```python
   def update_user(self, user_id: uuid.UUID, user_update: UserUpdate) -> User:
       """
       Update user.
       
       Args:
           user_id: User ID
           user_update: User update data
           
       Returns:
           Updated user
           
       Raises:
           UserNotFoundError: If user not found
       """
       # Get the user
       user = self.user_repo.get_by_id(user_id)
       if not user:
           raise UserNotFoundError(f"User with ID {user_id} not found")
       
       # Update fields if provided
       update_data = user_update.model_dump(exclude_unset=True)
       for field, value in update_data.items():
           setattr(user, field, value)
       
       # Save the user
       updated_user = self.user_repo.update(user)
       
       # Publish event
       event = UserUpdatedEvent(user_id=updated_user.id)
       event.publish()
       
       return updated_user
   ```

### API Routes

1. **Route Structure**:
   - Group related routes in the same router
   - Use consistent URL patterns
   - Include appropriate HTTP methods and status codes

   ```python
   @router.get("/", response_model=UsersPublic)
   def read_users(
       session: SessionDep,
       current_user: CurrentUser,
       user_service: UserService = Depends(get_user_service),
       skip: int = 0,
       limit: int = 100,
   ) -> Any:
       """
       Retrieve users.
       
       Args:
           session: Database session
           current_user: Current user
           user_service: User service
           skip: Number of records to skip
           limit: Maximum number of records to return
           
       Returns:
           List of users
       """
       users = user_service.get_multi(skip=skip, limit=limit)
       count = user_service.count()
       return user_service.to_public_list(users, count)
   ```

2. **Dependency Injection**:
   - Use FastAPI's dependency injection system
   - Create helper functions for common dependencies
   - Document dependencies in docstrings

   ```python
   def get_user_service(session: SessionDep) -> UserService:
       """
       Get user service.
       
       Args:
           session: Database session
           
       Returns:
           User service
       """
       user_repo = UserRepository(session)
       return UserService(user_repo)
   ```

3. **Error Handling**:
   - Convert domain exceptions to HTTP exceptions
   - Include appropriate status codes and error messages
   - Document error responses in docstrings

   ```python
   @router.get("/{user_id}", response_model=UserPublic)
   def read_user(
       user_id: uuid.UUID,
       session: SessionDep,
       current_user: CurrentUser,
       user_service: UserService = Depends(get_user_service),
   ) -> Any:
       """
       Get user by ID.
       
       Args:
           user_id: User ID
           session: Database session
           current_user: Current user
           user_service: User service
           
       Returns:
           User
           
       Raises:
           HTTPException: If user not found
       """
       try:
           user = user_service.get_by_id(user_id)
           return user_service.to_public(user)
       except UserNotFoundError as e:
           raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
   ```

## Tools and Automation

1. **Code Formatting**:
   - Use [Black](https://black.readthedocs.io/) for code formatting
   - Use [isort](https://pycqa.github.io/isort/) for import sorting
   - Use [Ruff](https://github.com/charliermarsh/ruff) for linting

2. **Type Checking**:
   - Use [mypy](https://mypy.readthedocs.io/) for static type checking
   - Add type hints to all functions and methods
   - Fix type errors before committing code

3. **Pre-commit Hooks**:
   - Use [pre-commit](https://pre-commit.com/) to run checks before committing
   - Configure hooks for formatting, linting, and type checking
   - Fix issues before committing code

## Conclusion

Following these code style guidelines will help maintain a consistent, readable, and maintainable codebase. Remember that the goal is to write code that is easy to understand, modify, and extend, not just code that works.

================
File: backend/EVENT_SYSTEM.md
================
# Event System Documentation

This document provides detailed information about the event system used in the modular monolith architecture.

## Overview

The event system enables loose coupling between modules by allowing them to communicate through events rather than direct dependencies. This approach has several benefits:

- **Decoupling**: Modules don't need to know about each other's implementation details
- **Extensibility**: New functionality can be added by subscribing to existing events
- **Testability**: Event handlers can be tested in isolation
- **Maintainability**: Changes to one module don't require changes to other modules

## Core Components

### Event Base Class

All events inherit from the `EventBase` class defined in `app/core/events.py`:

```python
class EventBase(SQLModel):
    """Base class for all events."""
    
    event_type: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    def publish(self) -> None:
        """Publish the event."""
        from app.core.events import publish_event
        publish_event(self)
```

### Event Registry

The event system maintains a registry of event handlers in `app/core/events.py`:

```python
# Event handler registry
_event_handlers: Dict[str, List[Callable]] = {}
```

### Event Handler Decorator

Event handlers are registered using the `event_handler` decorator:

```python
def event_handler(event_type: str) -> Callable:
    """
    Decorator to register an event handler.
    
    Args:
        event_type: Type of event to handle
        
    Returns:
        Decorator function
    """
    def decorator(func: Callable) -> Callable:
        if event_type not in _event_handlers:
            _event_handlers[event_type] = []
        _event_handlers[event_type].append(func)
        logger.info(f"Registered handler {func.__name__} for event {event_type}")
        return func
    return decorator
```

### Event Publishing

Events are published using the `publish_event` function:

```python
def publish_event(event: EventBase) -> None:
    """
    Publish an event.
    
    Args:
        event: Event to publish
    """
    event_type = event.event_type
    logger.info(f"Publishing event {event_type}")
    
    if event_type in _event_handlers:
        for handler in _event_handlers[event_type]:
            try:
                handler(event)
            except Exception as e:
                logger.error(f"Error handling event {event_type} with handler {handler.__name__}: {e}")
                # Continue processing other handlers
    else:
        logger.info(f"No handlers registered for event {event_type}")
```

## Using the Event System

### Defining Events

To define a new event:

1. Create a new class that inherits from `EventBase`
2. Define the `event_type` attribute
3. Add any additional attributes needed for the event
4. Implement the `publish` method

Example:

```python
class UserCreatedEvent(EventBase):
    """Event published when a user is created."""
    event_type: str = "user.created"
    user_id: uuid.UUID
    email: str
    
    def publish(self) -> None:
        """Publish the event."""
        from app.core.events import publish_event
        publish_event(self)
```

### Publishing Events

To publish an event:

1. Create an instance of the event class
2. Call the `publish` method

Example:

```python
def create_user(self, user_create: UserCreate) -> User:
    # Create user logic...
    
    # Publish event
    event = UserCreatedEvent(user_id=user.id, email=user.email)
    event.publish()
    
    return user
```

### Subscribing to Events

To subscribe to an event:

1. Create a function that takes the event as a parameter
2. Decorate the function with `@event_handler("event.type")`
3. Import the handler in the module's `__init__.py` to register it

Example:

```python
@event_handler("user.created")
def handle_user_created(event: UserCreatedEvent) -> None:
    """Handle user created event."""
    logger.info(f"User created: {event.user_id}")
    # Handle the event...
```

## Event Naming Conventions

Events should be named using the format `{entity}.{action}`:

- `user.created`
- `user.updated`
- `user.deleted`
- `item.created`
- `item.updated`
- `item.deleted`
- `email.sent`
- `password.reset`

## Best Practices

### Event Design

- **Keep Events Simple**: Events should contain only the data needed by handlers
- **Include IDs**: Always include entity IDs to allow handlers to fetch more data if needed
- **Use Meaningful Names**: Event names should clearly indicate what happened
- **Version Events**: Consider adding version information for long-lived events

### Event Handlers

- **Keep Handlers Focused**: Each handler should do one thing
- **Handle Errors Gracefully**: Errors in one handler shouldn't affect others
- **Avoid Circular Events**: Be careful not to create circular event chains
- **Document Dependencies**: Clearly document which events a module depends on

### Testing

- **Test Event Publishing**: Verify that events are published when expected
- **Test Event Handlers**: Test handlers in isolation with mock events
- **Test End-to-End**: Test the full event flow in integration tests

## Real-World Examples

### User Registration Flow

1. User registers via API
2. User service creates the user
3. User service publishes `UserCreatedEvent`
4. Email service handles `UserCreatedEvent` and sends welcome email
5. Analytics service handles `UserCreatedEvent` and logs the registration

```python
# User service
def register_user(self, user_register: UserRegister) -> User:
    # Create user
    user = User(
        email=user_register.email,
        full_name=user_register.full_name,
        hashed_password=get_password_hash(user_register.password),
    )
    
    created_user = self.user_repo.create(user)
    
    # Publish event
    event = UserCreatedEvent(user_id=created_user.id, email=created_user.email)
    event.publish()
    
    return created_user

# Email service
@event_handler("user.created")
def send_welcome_email(event: UserCreatedEvent) -> None:
    """Send welcome email to new user."""
    # Get user from database
    user = user_repo.get_by_id(event.user_id)
    
    # Send email
    email_service.send_email(
        email_to=user.email,
        subject="Welcome to our service",
        template_type=EmailTemplateType.NEW_ACCOUNT,
        template_data={"user_name": user.full_name},
    )

# Analytics service
@event_handler("user.created")
def log_user_registration(event: UserCreatedEvent) -> None:
    """Log user registration for analytics."""
    analytics_service.log_event(
        event_type="user_registration",
        user_id=event.user_id,
        timestamp=datetime.utcnow(),
    )
```

### Item Creation Flow

1. User creates an item via API
2. Item service creates the item
3. Item service publishes `ItemCreatedEvent`
4. Notification service handles `ItemCreatedEvent` and notifies relevant users
5. Search service handles `ItemCreatedEvent` and indexes the item

```python
# Item service
def create_item(self, item_create: ItemCreate, owner_id: uuid.UUID) -> Item:
    # Create item
    item = Item(
        title=item_create.title,
        description=item_create.description,
        owner_id=owner_id,
    )
    
    created_item = self.item_repo.create(item)
    
    # Publish event
    event = ItemCreatedEvent(
        item_id=created_item.id,
        title=created_item.title,
        owner_id=created_item.owner_id,
    )
    event.publish()
    
    return created_item

# Notification service
@event_handler("item.created")
def notify_item_creation(event: ItemCreatedEvent) -> None:
    """Notify relevant users about new item."""
    # Get owner's followers
    followers = follower_repo.get_followers(event.owner_id)
    
    # Notify followers
    for follower in followers:
        notification_service.send_notification(
            user_id=follower.id,
            message=f"New item: {event.title}",
            link=f"/items/{event.item_id}",
        )

# Search service
@event_handler("item.created")
def index_item(event: ItemCreatedEvent) -> None:
    """Index item in search engine."""
    # Get item from database
    item = item_repo.get_by_id(event.item_id)
    
    # Index item
    search_service.index_item(
        id=str(item.id),
        title=item.title,
        description=item.description,
        owner_id=str(item.owner_id),
    )
```

## Debugging Events

To debug events, you can use the logger in `app/core/events.py`:

```python
# Add this to your local development settings
import logging
logging.getLogger("app.core.events").setLevel(logging.DEBUG)
```

This will log detailed information about event publishing and handling.

================
File: backend/EXTENDING_ARCHITECTURE.md
================
# Extending the Modular Monolith Architecture

This guide explains how to extend the modular monolith architecture by adding new modules or enhancing existing ones.

## Creating a New Module

### 1. Create the Module Structure

Create a new directory for your module under `app/modules/` with the following structure:

```
app/modules/{module_name}/
 __init__.py           # Module initialization
 api/                  # API layer
    __init__.py
    dependencies.py   # Module-specific dependencies
    routes.py         # API endpoints
 domain/               # Domain layer
    __init__.py
    events.py         # Domain events
    models.py         # Domain models
 repository/           # Data access layer
    __init__.py
    {module}_repo.py  # Repository implementation
 services/             # Business logic layer
     __init__.py
     {module}_service.py  # Service implementation
```

### 2. Implement the Module Components

#### Module Initialization

In `app/modules/{module_name}/__init__.py`:

```python
"""
{Module name} module initialization.

This module handles {module description}.
"""
from fastapi import FastAPI

from app.core.config import settings
from app.core.logging import get_logger

# Initialize logger
logger = get_logger("{module_name}")


def init_{module_name}_module(app: FastAPI) -> None:
    """
    Initialize {module name} module.

    This function registers all routes and initializes the module.

    Args:
        app: FastAPI application
    """
    # Import here to avoid circular imports
    from app.modules.{module_name}.api.routes import router as {module_name}_router

    # Include the router in the application
    app.include_router({module_name}_router, prefix=settings.API_V1_STR)

    logger.info("{Module name} module initialized")
```

#### Domain Models

In `app/modules/{module_name}/domain/models.py`:

```python
"""
{Module name} domain models.

This module contains domain models related to {module description}.
"""
import uuid
from typing import List, Optional

from sqlmodel import Field, SQLModel

from app.shared.models import BaseModel


# Define your models here
class {Entity}Base(SQLModel):
    """Base {entity} model with common properties."""
    name: str = Field(max_length=255)
    description: Optional[str] = Field(default=None, max_length=255)


class {Entity}Create({Entity}Base):
    """Model for creating a {entity}."""
    pass


class {Entity}Update({Entity}Base):
    """Model for updating a {entity}."""
    name: Optional[str] = Field(default=None, max_length=255)  # type: ignore
    description: Optional[str] = Field(default=None, max_length=255)


class {Entity}({Entity}Base, BaseModel, table=True):
    """Database model for a {entity}."""
    __tablename__ = "{entity_lowercase}"

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)


class {Entity}Public({Entity}Base):
    """Public {entity} model for API responses."""
    id: uuid.UUID


class {Entity}sPublic(SQLModel):
    """List of public {entity}s for API responses."""
    data: List[{Entity}Public]
    count: int
```

#### Repository

In `app/modules/{module_name}/repository/{module_name}_repo.py`:

```python
"""
{Module name} repository.

This module provides data access for {module description}.
"""
import uuid
from typing import List, Optional

from sqlmodel import Session, select

from app.modules.{module_name}.domain.models import {Entity}
from app.shared.exceptions import NotFoundException


class {Module}Repository:
    """Repository for {module description}."""

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: Database session
        """
        self.session = session

    def get_by_id(self, {entity}_id: uuid.UUID) -> {Entity}:
        """
        Get {entity} by ID.

        Args:
            {entity}_id: {Entity} ID

        Returns:
            {Entity}

        Raises:
            NotFoundException: If {entity} not found
        """
        {entity} = self.session.get({Entity}, {entity}_id)
        if not {entity}:
            raise NotFoundException(f"{Entity} with ID {{{entity}_id}} not found")
        return {entity}

    def get_multi(self, *, skip: int = 0, limit: int = 100) -> List[{Entity}]:
        """
        Get multiple {entity}s.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return

        Returns:
            List of {entity}s
        """
        statement = select({Entity}).offset(skip).limit(limit)
        return list(self.session.exec(statement))

    def count(self) -> int:
        """
        Count total {entity}s.

        Returns:
            Total count
        """
        statement = select([count()]).select_from({Entity})
        return self.session.exec(statement).one()

    def create(self, {entity}: {Entity}) -> {Entity}:
        """
        Create new {entity}.

        Args:
            {entity}: {Entity} to create

        Returns:
            Created {entity}
        """
        self.session.add({entity})
        self.session.commit()
        self.session.refresh({entity})
        return {entity}

    def update(self, {entity}: {Entity}) -> {Entity}:
        """
        Update {entity}.

        Args:
            {entity}: {Entity} to update

        Returns:
            Updated {entity}
        """
        self.session.add({entity})
        self.session.commit()
        self.session.refresh({entity})
        return {entity}

    def delete(self, {entity}_id: uuid.UUID) -> None:
        """
        Delete {entity}.

        Args:
            {entity}_id: {Entity} ID

        Raises:
            NotFoundException: If {entity} not found
        """
        {entity} = self.get_by_id({entity}_id)
        self.session.delete({entity})
        self.session.commit()
```

#### Service

In `app/modules/{module_name}/services/{module_name}_service.py`:

```python
"""
{Module name} service.

This module provides business logic for {module description}.
"""
import uuid
from typing import List, Optional

from app.core.logging import get_logger
from app.modules.{module_name}.domain.models import (
    {Entity},
    {Entity}Create,
    {Entity}Public,
    {Entity}sPublic,
    {Entity}Update,
)
from app.modules.{module_name}.repository.{module_name}_repo import {Module}Repository
from app.shared.exceptions import NotFoundException

# Initialize logger
logger = get_logger("{module_name}_service")


class {Module}Service:
    """Service for {module description}."""

    def __init__(self, {module_name}_repo: {Module}Repository):
        """
        Initialize service with repository.

        Args:
            {module_name}_repo: {Module} repository
        """
        self.{module_name}_repo = {module_name}_repo

    def get_by_id(self, {entity}_id: uuid.UUID) -> {Entity}:
        """
        Get {entity} by ID.

        Args:
            {entity}_id: {Entity} ID

        Returns:
            {Entity}

        Raises:
            NotFoundException: If {entity} not found
        """
        return self.{module_name}_repo.get_by_id({entity}_id)

    def get_multi(self, *, skip: int = 0, limit: int = 100) -> List[{Entity}]:
        """
        Get multiple {entity}s.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return

        Returns:
            List of {entity}s
        """
        return self.{module_name}_repo.get_multi(skip=skip, limit=limit)

    def create_{entity}(self, {entity}_create: {Entity}Create) -> {Entity}:
        """
        Create new {entity}.

        Args:
            {entity}_create: {Entity} creation data

        Returns:
            Created {entity}
        """
        # Create {entity}
        {entity} = {Entity}(
            name={entity}_create.name,
            description={entity}_create.description,
        )

        created_{entity} = self.{module_name}_repo.create({entity})
        logger.info(f"Created {entity} with ID {created_{entity}.id}")

        return created_{entity}

    def update_{entity}(
        self, {entity}_id: uuid.UUID, {entity}_update: {Entity}Update
    ) -> {Entity}:
        """
        Update {entity}.

        Args:
            {entity}_id: {Entity} ID
            {entity}_update: {Entity} update data

        Returns:
            Updated {entity}

        Raises:
            NotFoundException: If {entity} not found
        """
        {entity} = self.get_by_id({entity}_id)

        # Update fields if provided
        update_data = {entity}_update.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr({entity}, field, value)

        updated_{entity} = self.{module_name}_repo.update({entity})
        logger.info(f"Updated {entity} with ID {updated_{entity}.id}")

        return updated_{entity}

    def delete_{entity}(self, {entity}_id: uuid.UUID) -> None:
        """
        Delete {entity}.

        Args:
            {entity}_id: {Entity} ID

        Raises:
            NotFoundException: If {entity} not found
        """
        self.{module_name}_repo.delete({entity}_id)
        logger.info(f"Deleted {entity} with ID {{{entity}_id}}")

    # Public model conversions

    def to_public(self, {entity}: {Entity}) -> {Entity}Public:
        """
        Convert {entity} to public model.

        Args:
            {entity}: {Entity} to convert

        Returns:
            Public {entity}
        """
        return {Entity}Public.model_validate({entity})

    def to_public_list(self, {entity}s: List[{Entity}], count: int) -> {Entity}sPublic:
        """
        Convert list of {entity}s to public model.

        Args:
            {entity}s: {Entity}s to convert
            count: Total count

        Returns:
            Public {entity}s list
        """
        return {Entity}sPublic(
            data=[self.to_public({entity}) for {entity} in {entity}s],
            count=count,
        )
```

#### API Routes

In `app/modules/{module_name}/api/routes.py`:

```python
"""
{Module name} API routes.

This module provides API endpoints for {module description}.
"""
import uuid
from typing import Any

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import CurrentUser, SessionDep
from app.modules.{module_name}.domain.models import (
    {Entity}Create,
    {Entity}Public,
    {Entity}sPublic,
    {Entity}Update,
)
from app.modules.{module_name}.repository.{module_name}_repo import {Module}Repository
from app.modules.{module_name}.services.{module_name}_service import {Module}Service
from app.shared.exceptions import NotFoundException
from app.shared.models import Message

# Create router
router = APIRouter(prefix="/{module_name}", tags=["{module_name}"])


# Dependencies
def get_{module_name}_service(session: SessionDep) -> {Module}Service:
    """
    Get {module name} service.

    Args:
        session: Database session

    Returns:
        {Module} service
    """
    {module_name}_repo = {Module}Repository(session)
    return {Module}Service({module_name}_repo)


# Routes
@router.get("/", response_model={Entity}sPublic)
def read_{entity}s(
    session: SessionDep,
    current_user: CurrentUser,
    {module_name}_service: {Module}Service = Depends(get_{module_name}_service),
    skip: int = 0,
    limit: int = 100,
) -> Any:
    """
    Retrieve {entity}s.

    Args:
        session: Database session
        current_user: Current user
        {module_name}_service: {Module} service
        skip: Number of records to skip
        limit: Maximum number of records to return

    Returns:
        List of {entity}s
    """
    {entity}s = {module_name}_service.get_multi(skip=skip, limit=limit)
    count = len({entity}s)  # For simplicity, using length instead of count query
    return {module_name}_service.to_public_list({entity}s, count)


@router.post("/", response_model={Entity}Public, status_code=status.HTTP_201_CREATED)
def create_{entity}(
    *,
    session: SessionDep,
    current_user: CurrentUser,
    {entity}_in: {Entity}Create,
    {module_name}_service: {Module}Service = Depends(get_{module_name}_service),
) -> Any:
    """
    Create new {entity}.

    Args:
        session: Database session
        current_user: Current user
        {entity}_in: {Entity} creation data
        {module_name}_service: {Module} service

    Returns:
        Created {entity}
    """
    {entity} = {module_name}_service.create_{entity}({entity}_in)
    return {module_name}_service.to_public({entity})


@router.get("/{{{entity}_id}}", response_model={Entity}Public)
def read_{entity}(
    {entity}_id: uuid.UUID,
    session: SessionDep,
    current_user: CurrentUser,
    {module_name}_service: {Module}Service = Depends(get_{module_name}_service),
) -> Any:
    """
    Get {entity} by ID.

    Args:
        {entity}_id: {Entity} ID
        session: Database session
        current_user: Current user
        {module_name}_service: {Module} service

    Returns:
        {Entity}

    Raises:
        HTTPException: If {entity} not found
    """
    try:
        {entity} = {module_name}_service.get_by_id({entity}_id)
        return {module_name}_service.to_public({entity})
    except NotFoundException as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.put("/{{{entity}_id}}", response_model={Entity}Public)
def update_{entity}(
    *,
    {entity}_id: uuid.UUID,
    session: SessionDep,
    current_user: CurrentUser,
    {entity}_in: {Entity}Update,
    {module_name}_service: {Module}Service = Depends(get_{module_name}_service),
) -> Any:
    """
    Update {entity}.

    Args:
        {entity}_id: {Entity} ID
        session: Database session
        current_user: Current user
        {entity}_in: {Entity} update data
        {module_name}_service: {Module} service

    Returns:
        Updated {entity}

    Raises:
        HTTPException: If {entity} not found
    """
    try:
        {entity} = {module_name}_service.update_{entity}({entity}_id, {entity}_in)
        return {module_name}_service.to_public({entity})
    except NotFoundException as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.delete("/{{{entity}_id}}", response_model=Message)
def delete_{entity}(
    {entity}_id: uuid.UUID,
    session: SessionDep,
    current_user: CurrentUser,
    {module_name}_service: {Module}Service = Depends(get_{module_name}_service),
) -> Any:
    """
    Delete {entity}.

    Args:
        {entity}_id: {Entity} ID
        session: Database session
        current_user: Current user
        {module_name}_service: {Module} service

    Returns:
        Success message

    Raises:
        HTTPException: If {entity} not found
    """
    try:
        {module_name}_service.delete_{entity}({entity}_id)
        return Message(message=f"{Entity} deleted successfully")
    except NotFoundException as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
```

### 3. Register the Module

In `app/api/main.py`, import and initialize your module:

```python
from app.modules.{module_name} import init_{module_name}_module

def init_api_routes(app: FastAPI) -> None:
    # ... existing code ...

    # Initialize your module
    init_{module_name}_module(app)

    # ... existing code ...
```

### 4. Create Tests

Create tests for your module in the `tests/modules/{module_name}/` directory, following the same structure as the module.

## Enhancing Existing Modules

To add functionality to an existing module:

1. **Add Domain Models**: Add new models to the module's `domain/models.py` file.
2. **Add Repository Methods**: Add new methods to the module's repository.
3. **Add Service Methods**: Add new business logic to the module's service.
4. **Add API Endpoints**: Add new endpoints to the module's `api/routes.py` file.
5. **Add Tests**: Add tests for the new functionality.

## Adding Cross-Module Communication

To enable communication between modules:

1. **Define Events**: Create event classes in the source module's `domain/events.py` file.
2. **Publish Events**: Publish events from the source module's services.
3. **Subscribe to Events**: Create event handlers in the target module's services.
4. **Register Handlers**: Import the handlers in the target module's `__init__.py` file.

## Best Practices

1. **Maintain Module Boundaries**: Keep module code within its directory structure.
2. **Use Dependency Injection**: Inject dependencies rather than importing them directly.
3. **Follow Layered Architecture**: Respect the layered architecture within each module.
4. **Document Your Code**: Add docstrings to all classes and methods.
5. **Write Tests**: Create tests for all new functionality.
6. **Use Events for Cross-Module Communication**: Avoid direct imports between modules.

================
File: backend/pyproject.toml
================
[project]
name = "app"
version = "0.1.0"
description = ""
requires-python = ">=3.10,<4.0"
dependencies = [
    "fastapi[standard]<1.0.0,>=0.114.2",
    "python-multipart<1.0.0,>=0.0.7",
    "email-validator<3.0.0.0,>=2.1.0.post1",
    "passlib[bcrypt]<2.0.0,>=1.7.4",
    "tenacity<9.0.0,>=8.2.3",
    "pydantic>2.0",
    "emails<1.0,>=0.6",
    "jinja2<4.0.0,>=3.1.4",
    "alembic<2.0.0,>=1.12.1",
    "httpx<1.0.0,>=0.25.1",
    "psycopg[binary]<4.0.0,>=3.1.13",
    "sqlmodel<1.0.0,>=0.0.21",
    # Pin bcrypt until passlib supports the latest
    "bcrypt==4.0.1",
    "pydantic-settings<3.0.0,>=2.2.1",
    "sentry-sdk[fastapi]<2.0.0,>=1.40.6",
    "pyjwt<3.0.0,>=2.8.0",
]

[tool.uv]
dev-dependencies = [
    "pytest<8.0.0,>=7.4.3",
    "mypy<2.0.0,>=1.8.0",
    "ruff<1.0.0,>=0.2.2",
    "pre-commit<4.0.0,>=3.6.2",
    "types-passlib<2.0.0.0,>=1.7.7.20240106",
    "coverage<8.0.0,>=7.4.3",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.mypy]
strict = true
exclude = ["venv", ".venv", "alembic"]

[tool.ruff]
target-version = "py310"
exclude = ["alembic"]

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4",  # flake8-comprehensions
    "UP",  # pyupgrade
    "ARG001", # unused arguments in functions
]
ignore = [
    "E501",  # line too long, handled by black
    "B008",  # do not perform function calls in argument defaults
    "W191",  # indentation contains tabs
    "B904",  # Allow raising exceptions without from e, for HTTPException
]

[tool.ruff.lint.pyupgrade]
# Preserve types, even if a file imports `from __future__ import annotations`.
keep-runtime-typing = true

================
File: backend/pytest.ini
================
[pytest]
markers =
    anyio: mark a test as an anyio test

================
File: backend/README.md
================
# FastAPI Project - Backend

## Requirements

* [Docker](https://www.docker.com/).
* [uv](https://docs.astral.sh/uv/) for Python package and environment management.

## Docker Compose

Start the local development environment with Docker Compose following the guide in [../development.md](../development.md).

## General Workflow

By default, the dependencies are managed with [uv](https://docs.astral.sh/uv/), go there and install it.

From `./backend/` you can install all the dependencies with:

```console
$ uv sync
```

Then you can activate the virtual environment with:

```console
$ source .venv/bin/activate
```

Make sure your editor is using the correct Python virtual environment, with the interpreter at `backend/.venv/bin/python`.

## Modular Monolith Architecture

This project follows a modular monolith architecture, which organizes the codebase into domain-specific modules while maintaining the deployment simplicity of a monolith.

### Module Structure

Each module follows this structure:

```
app/modules/{module_name}/
 __init__.py           # Module initialization
 api/                  # API layer
    __init__.py
    dependencies.py   # Module-specific dependencies
    routes.py         # API endpoints
 domain/               # Domain layer
    __init__.py
    events.py         # Domain events
    models.py         # Domain models
 repository/           # Data access layer
    __init__.py
    {module}_repo.py  # Repository implementation
 services/             # Business logic layer
     __init__.py
     {module}_service.py  # Service implementation
```

### Available Modules

- **Auth**: Authentication and authorization
- **Users**: User management
- **Items**: Item management
- **Email**: Email sending and templates

### Working with Modules

To add functionality to an existing module, locate the appropriate layer (API, domain, repository, or service) and make your changes there.

To create a new module, follow the structure above and register it in `app/api/main.py`.

For more details, see the [Modular Monolith Implementation](./MODULAR_MONOLITH_IMPLEMENTATION.md) document.

### Adding New Features

When adding new features to the application:

- Add SQLModel models in the appropriate module's `domain/models.py` file
- Add API endpoints in the module's `api/routes.py` file
- Implement business logic in the module's `services/` directory
- Create repositories for data access in the module's `repository/` directory
- Define domain events in the module's `domain/events.py` file when needed

## VS Code

There are already configurations in place to run the backend through the VS Code debugger, so that you can use breakpoints, pause and explore variables, etc.

The setup is also already configured so you can run the tests through the VS Code Python tests tab.

## Docker Compose Override

During development, you can change Docker Compose settings that will only affect the local development environment in the file `docker-compose.override.yml`.

The changes to that file only affect the local development environment, not the production environment. So, you can add "temporary" changes that help the development workflow.

For example, the directory with the backend code is synchronized in the Docker container, copying the code you change live to the directory inside the container. That allows you to test your changes right away, without having to build the Docker image again. It should only be done during development, for production, you should build the Docker image with a recent version of the backend code. But during development, it allows you to iterate very fast.

There is also a command override that runs `fastapi run --reload` instead of the default `fastapi run`. It starts a single server process (instead of multiple, as would be for production) and reloads the process whenever the code changes. Have in mind that if you have a syntax error and save the Python file, it will break and exit, and the container will stop. After that, you can restart the container by fixing the error and running again:

```console
$ docker compose watch
```

There is also a commented out `command` override, you can uncomment it and comment the default one. It makes the backend container run a process that does "nothing", but keeps the container alive. That allows you to get inside your running container and execute commands inside, for example a Python interpreter to test installed dependencies, or start the development server that reloads when it detects changes.

To get inside the container with a `bash` session you can start the stack with:

```console
$ docker compose watch
```

and then in another terminal, `exec` inside the running container:

```console
$ docker compose exec backend bash
```

You should see an output like:

```console
root@7f2607af31c3:/app#
```

that means that you are in a `bash` session inside your container, as a `root` user, under the `/app` directory, this directory has another directory called "app" inside, that's where your code lives inside the container: `/app/app`.

There you can use the `fastapi run --reload` command to run the debug live reloading server.

```console
$ fastapi run --reload app/main.py
```

...it will look like:

```console
root@7f2607af31c3:/app# fastapi run --reload app/main.py
```

and then hit enter. That runs the live reloading server that auto reloads when it detects code changes.

Nevertheless, if it doesn't detect a change but a syntax error, it will just stop with an error. But as the container is still alive and you are in a Bash session, you can quickly restart it after fixing the error, running the same command ("up arrow" and "Enter").

...this previous detail is what makes it useful to have the container alive doing nothing and then, in a Bash session, make it run the live reload server.

## Backend tests

To test the backend run:

```console
$ bash ./scripts/test.sh
```

The tests run with Pytest, modify and add tests to `./backend/app/tests/`.

If you use GitHub Actions the tests will run automatically.

### Test running stack

If your stack is already up and you just want to run the tests, you can use:

```bash
docker compose exec backend bash scripts/tests-start.sh
```

That `/app/scripts/tests-start.sh` script just calls `pytest` after making sure that the rest of the stack is running. If you need to pass extra arguments to `pytest`, you can pass them to that command and they will be forwarded.

For example, to stop on first error:

```bash
docker compose exec backend bash scripts/tests-start.sh -x
```

### Test Coverage

When the tests are run, a file `htmlcov/index.html` is generated, you can open it in your browser to see the coverage of the tests.

## Migrations

As during local development your app directory is mounted as a volume inside the container, you can also run the migrations with `alembic` commands inside the container and the migration code will be in your app directory (instead of being only inside the container). So you can add it to your git repository.

Make sure you create a "revision" of your models and that you "upgrade" your database with that revision every time you change them. As this is what will update the tables in your database. Otherwise, your application will have errors.

* Start an interactive session in the backend container:

```console
$ docker compose exec backend bash
```

* Alembic is configured to import models from their respective modules in the modular architecture

* After changing a model (for example, adding a column), inside the container, create a revision, e.g.:

```console
$ alembic revision --autogenerate -m "Add column last_name to User model"
```

* For more details on working with Alembic in the modular architecture, see the [Modular Monolith Implementation](./MODULAR_MONOLITH_IMPLEMENTATION.md#alembic-migration-environment) document.

* Commit to the git repository the files generated in the alembic directory.

* After creating the revision, run the migration in the database (this is what will actually change the database):

```console
$ alembic upgrade head
```

If you don't want to use migrations at all, uncomment the lines in the file at `./backend/app/core/db.py` that end in:

```python
SQLModel.metadata.create_all(engine)
```

and comment the line in the file `scripts/prestart.sh` that contains:

```console
$ alembic upgrade head
```

If you don't want to start with the default models and want to remove them / modify them, from the beginning, without having any previous revision, you can remove the revision files (`.py` Python files) under `./backend/app/alembic/versions/`. And then create a first migration as described above.

## Event System

The project includes an event system for communication between modules. This allows for loose coupling while maintaining clear communication paths.

### Publishing Events

To publish an event from a module:

1. Define an event class in the module's `domain/events.py` file:

```python
from app.core.events import EventBase

class MyEvent(EventBase):
    event_type: str = "my.event"
    # Add event properties here

    def publish(self) -> None:
        from app.core.events import publish_event
        publish_event(self)
```

2. Publish the event from a service:

```python
event = MyEvent(property1="value1", property2="value2")
event.publish()
```

### Subscribing to Events

To subscribe to events:

1. Create an event handler in a module's services directory:

```python
from app.core.events import event_handler
from other_module.domain.events import OtherEvent

@event_handler("other.event")
def handle_other_event(event: OtherEvent) -> None:
    # Handle the event
    pass
```

2. Import the handler in the module's `__init__.py` to register it.

For more details, see the [Event System Documentation](./MODULAR_MONOLITH_IMPLEMENTATION.md#event-system-implementation).

## Email Templates

The email templates are in `./backend/app/email-templates/`. Here, there are two directories: `build` and `src`. The `src` directory contains the source files that are used to build the final email templates. The `build` directory contains the final email templates that are used by the application.

Before continuing, ensure you have the [MJML extension](https://marketplace.visualstudio.com/items?itemName=attilabuti.vscode-mjml) installed in your VS Code.

Once you have the MJML extension installed, you can create a new email template in the `src` directory. After creating the new email template and with the `.mjml` file open in your editor, open the command palette with `Ctrl+Shift+P` and search for `MJML: Export to HTML`. This will convert the `.mjml` file to a `.html` file and now you can save it in the build directory.

================
File: backend/TEST_PLAN.md
================
# Test Plan

This document outlines the test plan for the modular monolith architecture.

## Test Types

### 1. Unit Tests

Unit tests verify that individual components work as expected in isolation.

#### What to Test

- **Domain Models**: Validate model constraints and behaviors
- **Repositories**: Test data access methods
- **Services**: Test business logic
- **API Routes**: Test request handling and response formatting

#### Test Approach

- Use pytest for unit testing
- Mock dependencies to isolate the component being tested
- Focus on edge cases and error handling

### 2. Integration Tests

Integration tests verify that components work together correctly.

#### What to Test

- **Module Integration**: Test interactions between components within a module
- **Cross-Module Integration**: Test interactions between different modules
- **Database Integration**: Test database operations
- **Event System Integration**: Test event publishing and handling

#### Test Approach

- Use pytest for integration testing
- Use test database for database operations
- Test complete workflows across multiple components

### 3. API Tests

API tests verify that the API endpoints work as expected.

#### What to Test

- **API Endpoints**: Test all API endpoints
- **Authentication**: Test authentication and authorization
- **Error Handling**: Test error responses
- **Data Validation**: Test input validation

#### Test Approach

- Use TestClient from FastAPI for API testing
- Test different HTTP methods (GET, POST, PUT, DELETE)
- Test different response codes (200, 201, 400, 401, 403, 404, 500)
- Test with different input data (valid, invalid, edge cases)

### 4. Migration Tests

Migration tests verify that database migrations work correctly.

#### What to Test

- **Migration Generation**: Test that migrations can be generated
- **Migration Application**: Test that migrations can be applied
- **Migration Rollback**: Test that migrations can be rolled back

#### Test Approach

- Use Alembic for migration testing
- Test with a clean database
- Test with an existing database

## Test Coverage

The test suite should aim for high test coverage, focusing on critical components and business logic.

### Coverage Targets

- **Domain Models**: 100% coverage
- **Repositories**: 100% coverage
- **Services**: 90%+ coverage
- **API Routes**: 90%+ coverage
- **Overall**: 90%+ coverage

### Coverage Measurement

- Use pytest-cov to measure test coverage
- Generate coverage reports for each test run
- Review coverage reports to identify gaps

## Test Execution

### Local Testing

Run tests locally during development to catch issues early.

```bash
# Run all tests
bash ./scripts/test.sh

# Run specific tests
python -m pytest tests/modules/users/

# Run tests with coverage
python -m pytest --cov=app tests/
```

### CI/CD Testing

Run tests in the CI/CD pipeline to ensure code quality before deployment.

- Run tests on every pull request
- Run tests before every deployment
- Block deployments if tests fail

## Test Plan Execution

### Phase 1: Unit Tests

1. **Run Existing Unit Tests**:
   - Run all existing unit tests
   - Fix any failing tests
   - Document test coverage

2. **Add Missing Unit Tests**:
   - Identify components with low test coverage
   - Add unit tests for these components
   - Focus on critical business logic

### Phase 2: Integration Tests

1. **Run Existing Integration Tests**:
   - Run all existing integration tests
   - Fix any failing tests
   - Document test coverage

2. **Add Missing Integration Tests**:
   - Identify integration points with low test coverage
   - Add integration tests for these points
   - Focus on cross-module interactions

### Phase 3: API Tests

1. **Run Existing API Tests**:
   - Run all existing API tests
   - Fix any failing tests
   - Document test coverage

2. **Add Missing API Tests**:
   - Identify API endpoints with low test coverage
   - Add API tests for these endpoints
   - Focus on error handling and edge cases

### Phase 4: Migration Tests

1. **Test Migration Generation**:
   - Generate a test migration
   - Verify that the migration is correct
   - Fix any issues

2. **Test Migration Application**:
   - Apply the test migration to a clean database
   - Verify that the migration is applied correctly
   - Fix any issues

3. **Test Migration Rollback**:
   - Roll back the test migration
   - Verify that the rollback is successful
   - Fix any issues

### Phase 5: End-to-End Testing

1. **Test Complete Workflows**:
   - Identify key user workflows
   - Test these workflows end-to-end
   - Fix any issues

2. **Test Edge Cases**:
   - Identify edge cases and error scenarios
   - Test these scenarios
   - Fix any issues

## Test Scenarios

### User Module

1. **User Registration**:
   - Register a new user
   - Verify that the user is created in the database
   - Verify that a welcome email is sent

2. **User Authentication**:
   - Log in with valid credentials
   - Verify that a token is returned
   - Verify that the token can be used to access protected endpoints

3. **User Profile**:
   - Get user profile
   - Update user profile
   - Verify that the changes are saved

4. **Password Reset**:
   - Request password reset
   - Verify that a reset email is sent
   - Reset password
   - Verify that the new password works

### Item Module

1. **Item Creation**:
   - Create a new item
   - Verify that the item is created in the database
   - Verify that the item is associated with the correct user

2. **Item Retrieval**:
   - Get a list of items
   - Get a specific item
   - Verify that the correct data is returned

3. **Item Update**:
   - Update an item
   - Verify that the changes are saved
   - Verify that only the owner can update the item

4. **Item Deletion**:
   - Delete an item
   - Verify that the item is removed from the database
   - Verify that only the owner can delete the item

### Email Module

1. **Email Sending**:
   - Send a test email
   - Verify that the email is sent
   - Verify that the email content is correct

2. **Email Templates**:
   - Render email templates
   - Verify that the templates are rendered correctly
   - Verify that template variables are replaced

### Event System

1. **Event Publishing**:
   - Publish an event
   - Verify that the event is published
   - Verify that event handlers are called

2. **Event Handling**:
   - Handle an event
   - Verify that the event is handled correctly
   - Verify that error handling works

## Test Data

### Test Users

- **Admin User**: A user with superuser privileges
- **Regular User**: A user with standard privileges
- **Inactive User**: A user that is not active

### Test Items

- **Standard Item**: A regular item
- **Item with Long Description**: An item with a long description
- **Item with Special Characters**: An item with special characters in the title and description

## Test Environment

### Local Environment

- **Database**: PostgreSQL
- **Email**: SMTP server (or mock)
- **API**: FastAPI TestClient

### CI/CD Environment

- **Database**: PostgreSQL (in Docker)
- **Email**: Mock SMTP server
- **API**: FastAPI TestClient

## Test Reporting

### Test Results

- Generate test results for each test run
- Include pass/fail status for each test
- Include error messages for failing tests

### Coverage Reports

- Generate coverage reports for each test run
- Include coverage percentage for each module
- Include list of uncovered lines

## Conclusion

This test plan provides a comprehensive approach to testing the modular monolith architecture. By following this plan, we can ensure that the application works correctly and maintains high quality as it evolves.

================
File: development.md
================
# FastAPI Project - Development

## Docker Compose

* Start the local stack with Docker Compose:

```bash
docker compose watch
```

* Now you can open your browser and interact with these URLs:

Frontend, built with Docker, with routes handled based on the path: http://localhost:5173

Backend, JSON based web API based on OpenAPI: http://localhost:8000

Automatic interactive documentation with Swagger UI (from the OpenAPI backend): http://localhost:8000/docs

Adminer, database web administration: http://localhost:8080

Traefik UI, to see how the routes are being handled by the proxy: http://localhost:8090

**Note**: The first time you start your stack, it might take a minute for it to be ready. While the backend waits for the database to be ready and configures everything. You can check the logs to monitor it.

To check the logs, run (in another terminal):

```bash
docker compose logs
```

To check the logs of a specific service, add the name of the service, e.g.:

```bash
docker compose logs backend
```

## Local Development

The Docker Compose files are configured so that each of the services is available in a different port in `localhost`.

For the backend and frontend, they use the same port that would be used by their local development server, so, the backend is at `http://localhost:8000` and the frontend at `http://localhost:5173`.

This way, you could turn off a Docker Compose service and start its local development service, and everything would keep working, because it all uses the same ports.

For example, you can stop that `frontend` service in the Docker Compose, in another terminal, run:

```bash
docker compose stop frontend
```

And then start the local frontend development server:

```bash
cd frontend
npm run dev
```

Or you could stop the `backend` Docker Compose service:

```bash
docker compose stop backend
```

And then you can run the local development server for the backend:

```bash
cd backend
fastapi dev app/main.py
```

## Docker Compose in `localhost.tiangolo.com`

When you start the Docker Compose stack, it uses `localhost` by default, with different ports for each service (backend, frontend, adminer, etc).

When you deploy it to production (or staging), it will deploy each service in a different subdomain, like `api.example.com` for the backend and `dashboard.example.com` for the frontend.

In the guide about [deployment](deployment.md) you can read about Traefik, the configured proxy. That's the component in charge of transmitting traffic to each service based on the subdomain.

If you want to test that it's all working locally, you can edit the local `.env` file, and change:

```dotenv
DOMAIN=localhost.tiangolo.com
```

That will be used by the Docker Compose files to configure the base domain for the services.

Traefik will use this to transmit traffic at `api.localhost.tiangolo.com` to the backend, and traffic at `dashboard.localhost.tiangolo.com` to the frontend.

The domain `localhost.tiangolo.com` is a special domain that is configured (with all its subdomains) to point to `127.0.0.1`. This way you can use that for your local development.

After you update it, run again:

```bash
docker compose watch
```

When deploying, for example in production, the main Traefik is configured outside of the Docker Compose files. For local development, there's an included Traefik in `docker-compose.override.yml`, just to let you test that the domains work as expected, for example with `api.localhost.tiangolo.com` and `dashboard.localhost.tiangolo.com`.

## Docker Compose files and env vars

There is a main `docker-compose.yml` file with all the configurations that apply to the whole stack, it is used automatically by `docker compose`.

And there's also a `docker-compose.override.yml` with overrides for development, for example to mount the source code as a volume. It is used automatically by `docker compose` to apply overrides on top of `docker-compose.yml`.

These Docker Compose files use the `.env` file containing configurations to be injected as environment variables in the containers.

They also use some additional configurations taken from environment variables set in the scripts before calling the `docker compose` command.

After changing variables, make sure you restart the stack:

```bash
docker compose watch
```

## The .env file

The `.env` file is the one that contains all your configurations, generated keys and passwords, etc.

Depending on your workflow, you could want to exclude it from Git, for example if your project is public. In that case, you would have to make sure to set up a way for your CI tools to obtain it while building or deploying your project.

One way to do it could be to add each environment variable to your CI/CD system, and updating the `docker-compose.yml` file to read that specific env var instead of reading the `.env` file.

## Pre-commits and code linting

we are using a tool called [pre-commit](https://pre-commit.com/) for code linting and formatting.

When you install it, it runs right before making a commit in git. This way it ensures that the code is consistent and formatted even before it is committed.

You can find a file `.pre-commit-config.yaml` with configurations at the root of the project.

#### Install pre-commit to run automatically

`pre-commit` is already part of the dependencies of the project, but you could also install it globally if you prefer to, following [the official pre-commit docs](https://pre-commit.com/).

After having the `pre-commit` tool installed and available, you need to "install" it in the local repository, so that it runs automatically before each commit.

Using `uv`, you could do it with:

```bash
 uv run pre-commit install
pre-commit installed at .git/hooks/pre-commit
```

Now whenever you try to commit, e.g. with:

```bash
git commit
```

...pre-commit will run and check and format the code you are about to commit, and will ask you to add that code (stage it) with git again before committing.

Then you can `git add` the modified/fixed files again and now you can commit.

#### Running pre-commit hooks manually

you can also run `pre-commit` manually on all the files, you can do it using `uv` with:

```bash
 uv run pre-commit run --all-files
check for added large files..............................................Passed
check toml...............................................................Passed
check yaml...............................................................Passed
ruff.....................................................................Passed
ruff-format..............................................................Passed
eslint...................................................................Passed
prettier.................................................................Passed
```

## URLs

The production or staging URLs would use these same paths, but with your own domain.

### Development URLs

Development URLs, for local development.

Frontend: http://localhost:5173

Backend: http://localhost:8000

Automatic Interactive Docs (Swagger UI): http://localhost:8000/docs

Automatic Alternative Docs (ReDoc): http://localhost:8000/redoc

Adminer: http://localhost:8080

Traefik UI: http://localhost:8090

MailCatcher: http://localhost:1080

### Development URLs with `localhost.tiangolo.com` Configured

Development URLs, for local development.

Frontend: http://dashboard.localhost.tiangolo.com

Backend: http://api.localhost.tiangolo.com

Automatic Interactive Docs (Swagger UI): http://api.localhost.tiangolo.com/docs

Automatic Alternative Docs (ReDoc): http://api.localhost.tiangolo.com/redoc

Adminer: http://localhost.tiangolo.com:8080

Traefik UI: http://localhost.tiangolo.com:8090

MailCatcher: http://localhost.tiangolo.com:1080

================
File: docker-compose.override.yml
================
services:

  # Local services are available on their ports, but also available on:
  # http://api.localhost.tiangolo.com: backend
  # http://dashboard.localhost.tiangolo.com: frontend
  # etc. To enable it, update .env, set:
  # DOMAIN=localhost.tiangolo.com
  proxy:
    image: traefik:3.0
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - "80:80"
      - "8090:8080"
    # Duplicate the command from docker-compose.yml to add --api.insecure=true
    command:
      # Enable Docker in Traefik, so that it reads labels from Docker services
      - --providers.docker
      # Add a constraint to only use services with the label for this stack
      - --providers.docker.constraints=Label(`traefik.constraint-label`, `traefik-public`)
      # Do not expose all Docker services, only the ones explicitly exposed
      - --providers.docker.exposedbydefault=false
      # Create an entrypoint "http" listening on port 80
      - --entrypoints.http.address=:80
      # Create an entrypoint "https" listening on port 443
      - --entrypoints.https.address=:443
      # Enable the access log, with HTTP requests
      - --accesslog
      # Enable the Traefik log, for configurations and errors
      - --log
      # Enable debug logging for local development
      - --log.level=DEBUG
      # Enable the Dashboard and API
      - --api
      # Enable the Dashboard and API in insecure mode for local development
      - --api.insecure=true
    labels:
      # Enable Traefik for this service, to make it available in the public network
      - traefik.enable=true
      - traefik.constraint-label=traefik-public
      # Dummy https-redirect middleware that doesn't really redirect, only to
      # allow running it locally
      - traefik.http.middlewares.https-redirect.contenttype.autodetect=false
    networks:
      - traefik-public
      - default

  db:
    restart: "no"
    ports:
      - "5432:5432"

  adminer:
    restart: "no"
    ports:
      - "8080:8080"

  backend:
    restart: "no"
    ports:
      - "8000:8000"
    build:
      context: ./backend
    # command: sleep infinity  # Infinite loop to keep container alive doing nothing
    command:
      - fastapi
      - run
      - --reload
      - "app/main.py"
    depends_on:
      db:
        condition: service_healthy
        restart: true
      # Remove prestart dependency
    develop:
      watch:
        - path: ./backend
          action: sync
          target: /app
          ignore:
            - ./backend/.venv
            - .venv
        - path: ./backend/pyproject.toml
          action: rebuild
    # TODO: remove once coverage is done locally
    volumes:
      - ./backend/htmlcov:/app/htmlcov
    environment:
      SMTP_HOST: "mailcatcher"
      SMTP_PORT: "1025"
      SMTP_TLS: "false"
      EMAILS_FROM_EMAIL: "noreply@example.com"

  mailcatcher:
    image: schickling/mailcatcher
    ports:
      - "1080:1080"
      - "1025:1025"

  frontend:
    restart: "no"
    ports:
      - "5173:80"
    build:
      context: ./frontend
      args:
        - VITE_API_URL=http://localhost:8000
        - NODE_ENV=development

  playwright:
    build:
      context: ./frontend
      dockerfile: Dockerfile.playwright
      args:
        - VITE_API_URL=http://backend:8000
        - NODE_ENV=production
    ipc: host
    depends_on:
      - backend
      - mailcatcher
    env_file:
      - .env
    environment:
      - VITE_API_URL=http://backend:8000
      - MAILCATCHER_HOST=http://mailcatcher:1080
      # For the reports when run locally
      - PLAYWRIGHT_HTML_HOST=0.0.0.0
      - CI=${CI}
    volumes:
      - ./frontend/blob-report:/app/blob-report
      - ./frontend/test-results:/app/test-results
    ports:
      - 9323:9323

networks:
  traefik-public:
    # For local dev, don't expect an external Traefik network
    external: false

================
File: docker-compose.traefik.yml
================
services:
  traefik:
    image: traefik:3.0
    ports:
      # Listen on port 80, default for HTTP, necessary to redirect to HTTPS
      - 80:80
      # Listen on port 443, default for HTTPS
      - 443:443
    restart: always
    labels:
      # Enable Traefik for this service, to make it available in the public network
      - traefik.enable=true
      # Use the traefik-public network (declared below)
      - traefik.docker.network=traefik-public
      # Define the port inside of the Docker service to use
      - traefik.http.services.traefik-dashboard.loadbalancer.server.port=8080
      # Make Traefik use this domain (from an environment variable) in HTTP
      - traefik.http.routers.traefik-dashboard-http.entrypoints=http
      - traefik.http.routers.traefik-dashboard-http.rule=Host(`traefik.${DOMAIN?Variable not set}`)
      # traefik-https the actual router using HTTPS
      - traefik.http.routers.traefik-dashboard-https.entrypoints=https
      - traefik.http.routers.traefik-dashboard-https.rule=Host(`traefik.${DOMAIN?Variable not set}`)
      - traefik.http.routers.traefik-dashboard-https.tls=true
      # Use the "le" (Let's Encrypt) resolver created below
      - traefik.http.routers.traefik-dashboard-https.tls.certresolver=le
      # Use the special Traefik service api@internal with the web UI/Dashboard
      - traefik.http.routers.traefik-dashboard-https.service=api@internal
      # https-redirect middleware to redirect HTTP to HTTPS
      - traefik.http.middlewares.https-redirect.redirectscheme.scheme=https
      - traefik.http.middlewares.https-redirect.redirectscheme.permanent=true
      # traefik-http set up only to use the middleware to redirect to https
      - traefik.http.routers.traefik-dashboard-http.middlewares=https-redirect
      # admin-auth middleware with HTTP Basic auth
      # Using the environment variables USERNAME and HASHED_PASSWORD
      - traefik.http.middlewares.admin-auth.basicauth.users=${USERNAME?Variable not set}:${HASHED_PASSWORD?Variable not set}
      # Enable HTTP Basic auth, using the middleware created above
      - traefik.http.routers.traefik-dashboard-https.middlewares=admin-auth
    volumes:
      # Add Docker as a mounted volume, so that Traefik can read the labels of other services
      - /var/run/docker.sock:/var/run/docker.sock:ro
      # Mount the volume to store the certificates
      - traefik-public-certificates:/certificates
    command:
      # Enable Docker in Traefik, so that it reads labels from Docker services
      - --providers.docker
      # Do not expose all Docker services, only the ones explicitly exposed
      - --providers.docker.exposedbydefault=false
      # Create an entrypoint "http" listening on port 80
      - --entrypoints.http.address=:80
      # Create an entrypoint "https" listening on port 443
      - --entrypoints.https.address=:443
      # Create the certificate resolver "le" for Let's Encrypt, uses the environment variable EMAIL
      - --certificatesresolvers.le.acme.email=${EMAIL?Variable not set}
      # Store the Let's Encrypt certificates in the mounted volume
      - --certificatesresolvers.le.acme.storage=/certificates/acme.json
      # Use the TLS Challenge for Let's Encrypt
      - --certificatesresolvers.le.acme.tlschallenge=true
      # Enable the access log, with HTTP requests
      - --accesslog
      # Enable the Traefik log, for configurations and errors
      - --log
      # Enable the Dashboard and API
      - --api
    networks:
      # Use the public network created to be shared between Traefik and
      # any other service that needs to be publicly available with HTTPS
      - traefik-public

volumes:
  # Create a volume to store the certificates, even if the container is recreated
  traefik-public-certificates:

networks:
  # Use the previously created public network "traefik-public", shared with other
  # services that need to be publicly available via this Traefik
  traefik-public:
    external: true

================
File: backend/app/api/main.py
================
"""
API routes registration and initialization.

This module handles the registration of all API routes and module initialization.
"""
from fastapi import FastAPI, APIRouter

from app.core.config import settings
from app.core.logging import get_logger
from app.modules.auth import init_auth_module
from app.modules.email import init_email_module
from app.modules.items import init_items_module
from app.modules.users import init_users_module

# Initialize logger
logger = get_logger("api.main")

# Create the main API router
api_router = APIRouter()


def init_api_routes(app: FastAPI) -> None:
    """
    Initialize API routes.

    This function registers all module routers and initializes the modules.

    Args:
        app: FastAPI application
    """
    # Include the API router
    app.include_router(api_router, prefix=settings.API_V1_STR)

    # Initialize all modules
    init_auth_module(app)
    init_users_module(app)
    init_items_module(app)
    init_email_module(app)

    logger.info("API routes initialized")

================
File: backend/app/core/events.py
================
"""
Event system for inter-module communication.

This module provides a simple pub/sub system for communication between modules
without direct dependencies.
"""
import asyncio
import inspect
import logging
from typing import Any, Callable, Dict, List, Optional, Set, Type, get_type_hints

from fastapi import FastAPI
from pydantic import BaseModel

# Configure logger
logger = logging.getLogger(__name__)


class EventBase(BaseModel):
    """Base class for all events in the system."""
    event_type: str


# Dictionary mapping event types to sets of handlers
_event_handlers: Dict[str, Set[Callable]] = {}


def publish_event(event: EventBase) -> None:
    """
    Publish an event to all registered handlers.
    
    Args:
        event: Event to publish
    """
    event_type = event.event_type
    handlers = _event_handlers.get(event_type, set())
    
    if not handlers:
        logger.debug(f"No handlers registered for event type: {event_type}")
        return
    
    for handler in handlers:
        try:
            if asyncio.iscoroutinefunction(handler):
                # Create task for async handlers
                asyncio.create_task(handler(event))
            else:
                # Execute sync handlers directly
                handler(event)
        except Exception as e:
            logger.exception(f"Error in event handler for {event_type}: {e}")


def subscribe_to_event(event_type: str, handler: Callable) -> None:
    """
    Subscribe a handler to an event type.
    
    Args:
        event_type: Type of event to subscribe to
        handler: Function to handle the event
    """
    if event_type not in _event_handlers:
        _event_handlers[event_type] = set()
    
    _event_handlers[event_type].add(handler)
    logger.debug(f"Handler {handler.__name__} subscribed to event type: {event_type}")


def unsubscribe_from_event(event_type: str, handler: Callable) -> None:
    """
    Unsubscribe a handler from an event type.
    
    Args:
        event_type: Type of event to unsubscribe from
        handler: Function to unsubscribe
    """
    if event_type in _event_handlers:
        _event_handlers[event_type].discard(handler)
        logger.debug(f"Handler {handler.__name__} unsubscribed from event type: {event_type}")


# Decorators for easier event handling
def event_handler(event_type: str):
    """
    Decorator for event handler functions.
    
    Args:
        event_type: Type of event to handle
    """
    def decorator(func: Callable):
        subscribe_to_event(event_type, func)
        return func
    return decorator


def setup_event_handlers(app: FastAPI) -> None:
    """
    Set up event handlers for application startup and shutdown.
    
    Args:
        app: FastAPI application
    """
    @app.on_event("startup")
    async def startup_event_handlers():
        logger.info("Starting event system")

    @app.on_event("shutdown")
    async def shutdown_event_handlers():
        logger.info("Shutting down event system")
        global _event_handlers
        _event_handlers = {}

================
File: backend/app/core/logging.py
================
"""
Centralized logging configuration for the application.

This module provides a consistent logging setup across all modules.
"""
import logging
import sys
from typing import Any, Dict, Optional

from fastapi import FastAPI
from pydantic import BaseModel

from app.core.config import settings


class LogConfig(BaseModel):
    """Configuration for application logging."""
    
    LOGGER_NAME: str = "app"
    LOG_FORMAT: str = "%(levelprefix)s | %(asctime)s | %(module)s | %(message)s"
    LOG_LEVEL: str = "INFO"
    
    # Logging config
    version: int = 1
    disable_existing_loggers: bool = False
    formatters: Dict[str, Dict[str, str]] = {
        "default": {
            "()": "uvicorn.logging.DefaultFormatter",
            "fmt": LOG_FORMAT,
            "datefmt": "%Y-%m-%d %H:%M:%S",
        },
    }
    handlers: Dict[str, Dict[str, Any]] = {
        "default": {
            "formatter": "default",
            "class": "logging.StreamHandler",
            "stream": "ext://sys.stderr",
        },
    }
    loggers: Dict[str, Dict[str, Any]] = {
        LOGGER_NAME: {"handlers": ["default"], "level": LOG_LEVEL},
    }


def get_logger(name: str) -> logging.Logger:
    """
    Get a module-specific logger.
    
    Args:
        name: Module name for the logger
        
    Returns:
        Logger instance
    """
    logger_name = f"{LogConfig().LOGGER_NAME}.{name}"
    return logging.getLogger(logger_name)


def setup_logging(app: Optional[FastAPI] = None) -> None:
    """
    Configure logging for the application.
    
    Args:
        app: FastAPI application (optional)
    """
    # Set log level from settings
    log_config = LogConfig()
    log_config.LOG_LEVEL = settings.LOG_LEVEL
    
    # Configure logging
    import logging.config
    logging.config.dictConfig(log_config.dict())
    
    # Add startup and shutdown event handlers if app is provided
    if app:
        @app.on_event("startup")
        async def startup_logging_event():
            root_logger = logging.getLogger()
            root_logger.info(f"Application starting up in {settings.ENVIRONMENT} environment")
            
        @app.on_event("shutdown")
        async def shutdown_logging_event():
            root_logger = logging.getLogger()
            root_logger.info("Application shutting down")


def get_module_logger(module_name: str) -> logging.Logger:
    """
    Get a logger for a specific module.
    
    Args:
        module_name: Name of the module
        
    Returns:
        Module-specific logger
    """
    return get_logger(module_name)

================
File: backend/app/core/security.py
================
"""
Security utilities.

This module provides utilities for handling passwords, JWT tokens, and other
security-related functionality.
"""
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional

import jwt
from passlib.context import CryptContext

from app.core.config import settings
from app.core.logging import get_logger

# Configure logger
logger = get_logger("security")

# Password hash configuration
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# JWT configuration
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES


def create_access_token(
    subject: str | Any, 
    expires_delta: Optional[timedelta] = None,
    extra_claims: Optional[Dict[str, Any]] = None
) -> str:
    """
    Create a JWT access token.
    
    Args:
        subject: Subject of the token (usually user ID)
        expires_delta: Token expiration time (default from settings)
        extra_claims: Additional claims to include in the token
        
    Returns:
        Encoded JWT token string
    """
    if expires_delta is None:
        expires_delta = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        
    expire = datetime.now(timezone.utc) + expires_delta
    
    to_encode = {"exp": expire, "sub": str(subject)}
    
    # Add any extra claims
    if extra_claims:
        to_encode.update(extra_claims)
    
    try:
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    except Exception as e:
        logger.error(f"Error creating JWT token: {e}")
        raise


def decode_access_token(token: str) -> Dict[str, Any]:
    """
    Decode a JWT access token.
    
    Args:
        token: JWT token string
        
    Returns:
        Dictionary of decoded token claims
        
    Raises:
        jwt.PyJWTError: If token validation fails
    """
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.PyJWTError as e:
        logger.warning(f"JWT token validation failed: {e}")
        raise


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a password against a hash.
    
    Args:
        plain_password: Plain text password
        hashed_password: Hashed password
        
    Returns:
        True if password matches hash, False otherwise
    """
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """
    Hash a password.
    
    Args:
        password: Plain text password
        
    Returns:
        Hashed password
    """
    return pwd_context.hash(password)


def generate_password_reset_token(email: str) -> str:
    """
    Generate a password reset token.
    
    Args:
        email: User email address
        
    Returns:
        Encoded JWT token for password reset
    """
    expires = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)
    return create_access_token(
        subject=email, 
        expires_delta=expires,
        extra_claims={"purpose": "password_reset"}
    )


def verify_password_reset_token(token: str) -> Optional[str]:
    """
    Verify a password reset token.
    
    Args:
        token: Password reset token
        
    Returns:
        Email address if token is valid, None otherwise
    """
    try:
        decoded_token = decode_access_token(token)
        # Verify token purpose
        if decoded_token.get("purpose") != "password_reset":
            return None
        return decoded_token["sub"]
    except jwt.PyJWTError:
        return None

================
File: backend/app/modules/auth/repository/auth_repo.py
================
"""
Auth repository.

This module provides database access functions for authentication operations.
"""
from sqlmodel import Session, select

from app.core.db import BaseRepository
from app.modules.users.domain.models import User


class AuthRepository(BaseRepository):
    """
    Repository for authentication operations.

    This class provides database access functions for authentication operations.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: Database session
        """
        super().__init__(session)

    def get_user_by_email(self, email: str) -> User | None:
        """
        Get a user by email.

        Args:
            email: User email

        Returns:
            User if found, None otherwise
        """
        statement = select(User).where(User.email == email)
        return self.session.exec(statement).first()

    def verify_user_exists(self, user_id: str) -> bool:
        """
        Verify that a user exists by ID.

        Args:
            user_id: User ID

        Returns:
            True if user exists, False otherwise
        """
        statement = select(User).where(User.id == user_id)
        return self.session.exec(statement).first() is not None

    def update_user_password(self, user_id: str, hashed_password: str) -> bool:
        """
        Update a user's password.

        Args:
            user_id: User ID
            hashed_password: Hashed password

        Returns:
            True if update was successful, False otherwise
        """
        user = self.session.get(User, user_id)
        if not user:
            return False

        user.hashed_password = hashed_password
        self.session.add(user)
        self.session.commit()
        return True

================
File: backend/app/modules/auth/dependencies.py
================
"""
Auth module dependencies.

This module provides dependencies for the auth module.
"""
from fastapi import Depends
from sqlmodel import Session

from app.core.db import get_repository, get_session
from app.modules.auth.repository.auth_repo import AuthRepository
from app.modules.auth.services.auth_service import AuthService


def get_auth_repository(session: Session = Depends(get_session)) -> AuthRepository:
    """
    Get an auth repository instance.
    
    Args:
        session: Database session
        
    Returns:
        Auth repository instance
    """
    return AuthRepository(session)


def get_auth_service(
    auth_repo: AuthRepository = Depends(get_auth_repository),
) -> AuthService:
    """
    Get an auth service instance.
    
    Args:
        auth_repo: Auth repository
        
    Returns:
        Auth service instance
    """
    return AuthService(auth_repo)


# Alternative using the repository factory
get_auth_repo = get_repository(AuthRepository)

================
File: backend/app/modules/email/domain/models.py
================
"""
Email domain models.

This module contains domain models related to email operations.
"""
from enum import Enum
from typing import Dict, List, Optional

from pydantic import EmailStr
from sqlmodel import SQLModel


class EmailTemplateType(str, Enum):
    """Types of email templates."""
    
    NEW_ACCOUNT = "new_account"
    RESET_PASSWORD = "reset_password"
    TEST_EMAIL = "test_email"
    GENERIC = "generic"


class EmailContent(SQLModel):
    """Email content model."""
    
    subject: str
    html_content: str
    plain_text_content: Optional[str] = None


class EmailRequest(SQLModel):
    """Email request model."""
    
    email_to: List[EmailStr]
    subject: str
    html_content: str
    plain_text_content: Optional[str] = None
    cc: Optional[List[EmailStr]] = None
    bcc: Optional[List[EmailStr]] = None
    reply_to: Optional[EmailStr] = None
    attachments: Optional[List[str]] = None


class TemplateData(SQLModel):
    """Template data model for rendering email templates."""
    
    template_type: EmailTemplateType
    context: Dict[str, str]
    email_to: EmailStr
    subject_override: Optional[str] = None

================
File: backend/app/modules/email/services/email_service.py
================
"""
Email service.

This module provides business logic for email operations.
"""
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional

import emails  # type: ignore
from jinja2 import Template
from pydantic import EmailStr

from app.core.config import settings
from app.core.logging import get_logger
from app.modules.email.domain.models import (
    EmailContent,
    EmailRequest,
    EmailTemplateType,
    TemplateData,
)

# Configure logger
logger = get_logger("email_service")


class EmailService:
    """
    Service for email operations.
    
    This class provides business logic for email operations.
    """
    
    def __init__(self):
        """Initialize email service."""
        self.templates_dir = Path(__file__).parents[3] / "email-templates" / "build"
        self.enabled = settings.emails_enabled
        self.smtp_options = self._get_smtp_options()
        self.from_name = settings.EMAILS_FROM_NAME
        self.from_email = settings.EMAILS_FROM_EMAIL
        self.frontend_host = settings.FRONTEND_HOST
        self.project_name = settings.PROJECT_NAME
    
    def _get_smtp_options(self) -> Dict[str, Any]:
        """
        Get SMTP options from settings.
        
        Returns:
            Dictionary of SMTP options
        """
        smtp_options = {"host": settings.SMTP_HOST, "port": settings.SMTP_PORT}
        
        if settings.SMTP_TLS:
            smtp_options["tls"] = True
        elif settings.SMTP_SSL:
            smtp_options["ssl"] = True
            
        if settings.SMTP_USER:
            smtp_options["user"] = settings.SMTP_USER
            
        if settings.SMTP_PASSWORD:
            smtp_options["password"] = settings.SMTP_PASSWORD
            
        return smtp_options
    
    def _render_template(self, template_name: str, context: Dict[str, Any]) -> str:
        """
        Render an email template.
        
        Args:
            template_name: Template filename
            context: Template context variables
            
        Returns:
            Rendered HTML content
        """
        template_path = self.templates_dir / template_name
        
        if not template_path.exists():
            logger.error(f"Email template not found: {template_path}")
            raise ValueError(f"Email template not found: {template_name}")
        
        template_str = template_path.read_text()
        html_content = Template(template_str).render(context)
        
        return html_content
    
    def send_email(self, email_request: EmailRequest) -> bool:
        """
        Send an email.
        
        Args:
            email_request: Email request data
            
        Returns:
            True if email was sent successfully, False otherwise
        """
        if not self.enabled:
            logger.warning("Email sending is disabled. Check your configuration.")
            return False
        
        try:
            message = emails.Message(
                subject=email_request.subject,
                html=email_request.html_content,
                text=email_request.plain_text_content,
                mail_from=(self.from_name, self.from_email),
            )
            
            # Add CC and BCC if provided
            if email_request.cc:
                message.cc = email_request.cc
                
            if email_request.bcc:
                message.bcc = email_request.bcc
                
            # Add reply-to if provided
            if email_request.reply_to:
                message.set_header("Reply-To", email_request.reply_to)
            
            # Add attachments if provided
            if email_request.attachments:
                for attachment_path in email_request.attachments:
                    message.attach(filename=attachment_path)
            
            # Send to each recipient
            for recipient in email_request.email_to:
                response = message.send(to=recipient, smtp=self.smtp_options)
                logger.info(f"Send email result to {recipient}: {response}")
                
                if not response.success:
                    logger.error(f"Failed to send email to {recipient}: {response.error}")
                    return False
            
            return True
        except Exception as e:
            logger.exception(f"Error sending email: {e}")
            return False
    
    def send_template_email(self, template_data: TemplateData) -> bool:
        """
        Send an email using a template.
        
        Args:
            template_data: Template data
            
        Returns:
            True if email was sent successfully, False otherwise
        """
        template_content = self.get_template_content(template_data)
        
        email_request = EmailRequest(
            email_to=[template_data.email_to],
            subject=template_data.subject_override or template_content.subject,
            html_content=template_content.html_content,
            plain_text_content=template_content.plain_text_content,
        )
        
        return self.send_email(email_request)
    
    def get_template_content(self, template_data: TemplateData) -> EmailContent:
        """
        Get email content from a template.
        
        Args:
            template_data: Template data
            
        Returns:
            Email content
        """
        # Default context with project name
        context = {
            "project_name": self.project_name,
            "frontend_host": self.frontend_host,
            **template_data.context,
        }
        
        # Add email to context if not already present
        if "email" not in context:
            context["email"] = template_data.email_to
        
        template_filename = f"{template_data.template_type}.html"
        html_content = self._render_template(template_filename, context)
        
        # Generate subject based on template type
        subject = self._get_subject_for_template(
            template_data.template_type, context
        )
        
        return EmailContent(
            subject=subject,
            html_content=html_content,
        )
    
    def _get_subject_for_template(
        self, template_type: EmailTemplateType, context: Dict[str, Any]
    ) -> str:
        """
        Get subject for a template type.
        
        Args:
            template_type: Template type
            context: Template context
            
        Returns:
            Email subject
        """
        if template_type == EmailTemplateType.NEW_ACCOUNT:
            username = context.get("username", "")
            return f"{self.project_name} - New account for user {username}"
        
        elif template_type == EmailTemplateType.RESET_PASSWORD:
            username = context.get("username", "")
            return f"{self.project_name} - Password recovery for user {username}"
        
        elif template_type == EmailTemplateType.TEST_EMAIL:
            return f"{self.project_name} - Test email"
        
        else:  # Generic or custom
            return context.get("subject", f"{self.project_name} - Notification")
    
    # Specific email sending methods
    
    def send_test_email(self, email_to: EmailStr) -> bool:
        """
        Send a test email.
        
        Args:
            email_to: Recipient email address
            
        Returns:
            True if email was sent successfully, False otherwise
        """
        template_data = TemplateData(
            template_type=EmailTemplateType.TEST_EMAIL,
            context={"email": email_to},
            email_to=email_to,
        )
        
        return self.send_template_email(template_data)
    
    def send_new_account_email(
        self, email_to: EmailStr, username: str, password: str
    ) -> bool:
        """
        Send a new account email.
        
        Args:
            email_to: Recipient email address
            username: Username
            password: Password
            
        Returns:
            True if email was sent successfully, False otherwise
        """
        template_data = TemplateData(
            template_type=EmailTemplateType.NEW_ACCOUNT,
            context={
                "username": username,
                "password": password,
                "link": self.frontend_host,
            },
            email_to=email_to,
        )
        
        return self.send_template_email(template_data)
    
    def send_password_reset_email(
        self, email_to: EmailStr, username: str, token: str
    ) -> bool:
        """
        Send a password reset email.
        
        Args:
            email_to: Recipient email address
            username: Username
            token: Password reset token
            
        Returns:
            True if email was sent successfully, False otherwise
        """
        link = f"{self.frontend_host}/reset-password?token={token}"
        
        template_data = TemplateData(
            template_type=EmailTemplateType.RESET_PASSWORD,
            context={
                "username": username,
                "valid_hours": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,
                "link": link,
            },
            email_to=email_to,
        )
        
        return self.send_template_email(template_data)

================
File: backend/app/modules/email/__init__.py
================
"""
Email module initialization.

This module handles email operations.
"""
from fastapi import APIRouter, FastAPI

from app.core.config import settings
from app.core.logging import get_logger
from app.modules.email.api.routes import router as email_router

# Import event handlers to register them
from app.modules.email.services import email_event_handlers

# Configure logger
logger = get_logger("email_module")


def get_email_router() -> APIRouter:
    """
    Get the email module's router.

    Returns:
        APIRouter for email module
    """
    return email_router


def init_email_module(app: FastAPI) -> None:
    """
    Initialize the email module.

    This function sets up routes and event handlers for the email module.

    Args:
        app: FastAPI application
    """
    # Include the email router in the application
    app.include_router(email_router, prefix=settings.API_V1_STR)

    # Set up any event handlers or startup tasks for the email module
    @app.on_event("startup")
    async def init_email():
        """Initialize email module on application startup."""
        # Log email service status
        if settings.emails_enabled:
            logger.info("Email module initialized with SMTP connection")
            logger.info(f"SMTP Host: {settings.SMTP_HOST}:{settings.SMTP_PORT}")
            logger.info(f"From: {settings.EMAILS_FROM_NAME} <{settings.EMAILS_FROM_EMAIL}>")
        else:
            logger.warning("Email module initialized but sending is disabled")
            logger.warning("To enable, configure SMTP settings in environment variables")

        # Log event handlers registration
        logger.info("Email event handlers registered for: user.created")

================
File: backend/app/modules/email/dependencies.py
================
"""
Email module dependencies.

This module provides dependencies for the email module.
"""
from fastapi import Depends

from app.modules.email.services.email_service import EmailService


def get_email_service() -> EmailService:
    """
    Get an email service instance.
    
    Returns:
        Email service instance
    """
    return EmailService()

================
File: backend/app/modules/items/dependencies.py
================
"""
Item module dependencies.

This module provides dependencies for the item module.
"""
from fastapi import Depends
from sqlmodel import Session

from app.core.db import get_repository, get_session
from app.modules.items.repository.item_repo import ItemRepository
from app.modules.items.services.item_service import ItemService


def get_item_repository(session: Session = Depends(get_session)) -> ItemRepository:
    """
    Get an item repository instance.
    
    Args:
        session: Database session
        
    Returns:
        Item repository instance
    """
    return ItemRepository(session)


def get_item_service(
    item_repo: ItemRepository = Depends(get_item_repository),
) -> ItemService:
    """
    Get an item service instance.
    
    Args:
        item_repo: Item repository
        
    Returns:
        Item service instance
    """
    return ItemService(item_repo)


# Alternative using the repository factory
get_item_repo = get_repository(ItemRepository)

================
File: backend/app/shared/exceptions.py
================
"""
Shared exceptions for the application.

This module contains custom exceptions used across multiple modules.
"""
from typing import Any, Dict, Optional


class AppException(Exception):
    """Base exception for application-specific errors."""
    
    def __init__(
        self, 
        message: str = "An unexpected error occurred", 
        status_code: int = 500,
        data: Optional[Dict[str, Any]] = None
    ):
        self.message = message
        self.status_code = status_code
        self.data = data or {}
        super().__init__(self.message)


class NotFoundException(AppException):
    """Exception raised when a resource is not found."""
    
    def __init__(
        self, 
        message: str = "Resource not found",
        data: Optional[Dict[str, Any]] = None
    ):
        super().__init__(message=message, status_code=404, data=data)


class ValidationException(AppException):
    """Exception raised when validation fails."""
    
    def __init__(
        self, 
        message: str = "Validation error",
        data: Optional[Dict[str, Any]] = None
    ):
        super().__init__(message=message, status_code=422, data=data)


class AuthenticationException(AppException):
    """Exception raised when authentication fails."""
    
    def __init__(
        self, 
        message: str = "Authentication failed",
        data: Optional[Dict[str, Any]] = None
    ):
        super().__init__(message=message, status_code=401, data=data)


class PermissionException(AppException):
    """Exception raised when permission is denied."""
    
    def __init__(
        self, 
        message: str = "Permission denied",
        data: Optional[Dict[str, Any]] = None
    ):
        super().__init__(message=message, status_code=403, data=data)

================
File: backend/app/shared/utils.py
================
"""
Shared utility functions for the application.

This module contains utility functions used across multiple modules.
"""
import re
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, TypeVar, Union

from fastapi import HTTPException, status
from pydantic import UUID4
from sqlmodel import Session, select

from app.shared.exceptions import NotFoundException

T = TypeVar("T")


def create_response_model(items: List[T], count: int) -> Dict[str, Any]:
    """
    Create a standard response model for collections with pagination info.
    
    Args:
        items: List of items to include in response
        count: Total number of items available
        
    Returns:
        Dict with data and count keys
    """
    return {
        "data": items,
        "count": count
    }


def get_utc_now() -> datetime:
    """Get the current UTC datetime."""
    return datetime.now(timezone.utc)


def uuid_to_str(uuid_obj: Union[uuid.UUID, str, None]) -> Optional[str]:
    """
    Convert a UUID object to a string.
    
    Args:
        uuid_obj: UUID object or string
        
    Returns:
        String representation of UUID or None if input is None
    """
    if uuid_obj is None:
        return None
    
    if isinstance(uuid_obj, uuid.UUID):
        return str(uuid_obj)
    
    return uuid_obj


def validate_uuid(value: str) -> bool:
    """
    Validate that a string is a valid UUID.
    
    Args:
        value: String to validate
        
    Returns:
        True if value is a valid UUID, False otherwise
    """
    try:
        uuid.UUID(str(value))
        return True
    except (ValueError, AttributeError, TypeError):
        return False


def get_or_404(session: Session, model: Any, id: Union[UUID4, str]) -> Any:
    """
    Get a database object by ID or raise a 404 exception.
    
    Args:
        session: Database session
        model: SQLModel class
        id: ID of the object to retrieve
        
    Returns:
        Database object
        
    Raises:
        NotFoundException: If object does not exist
    """
    obj = session.get(model, id)
    if not obj:
        raise NotFoundException(f"{model.__name__} with id {id} not found")
    return obj


def is_valid_email(email: str) -> bool:
    """
    Validate email format using a simple regex.
    
    Args:
        email: Email address to validate
        
    Returns:
        True if email format is valid, False otherwise
    """
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

================
File: backend/app/tests/api/blackbox/__init__.py
================
"""
Blackbox tests for API endpoints.

These tests verify the external behavior of the API without knowledge
of internal implementation, ensuring the behavior is maintained during
the modular monolith refactoring.
"""

================
File: backend/app/tests/api/blackbox/.env
================
# Test-specific environment variables
PROJECT_NAME="Test FastAPI"
POSTGRES_SERVER="localhost"
POSTGRES_USER="postgres"
POSTGRES_PASSWORD="postgres"
POSTGRES_DB="app_test"
FIRST_SUPERUSER="admin@example.com"
FIRST_SUPERUSER_PASSWORD="adminpassword"
SECRET_KEY="testingsecretkey"

================
File: backend/app/tests/api/blackbox/client_utils.py
================
"""
Utilities for blackbox testing using httpx against a running server.

This module provides helper functions and classes to interact with a running API server
without any knowledge of its implementation details. It exclusively uses HTTP requests
against the API's public endpoints.
"""
import json
import os
import time
import uuid
from typing import Dict, Optional, Any, Tuple, List, Union

import httpx

# Default server details - can be overridden with environment variables
DEFAULT_BASE_URL = "http://localhost:8000"
DEFAULT_TIMEOUT = 30.0  # seconds

# Get server details from environment or use defaults
BASE_URL = os.environ.get("TEST_SERVER_URL", DEFAULT_BASE_URL)
TIMEOUT = float(os.environ.get("TEST_REQUEST_TIMEOUT", DEFAULT_TIMEOUT))

class BlackboxClient:
    """
    Client for blackbox testing of the API.
    
    This client uses httpx to make HTTP requests to a running API server,
    handling authentication tokens and providing helper methods for common operations.
    """
    
    def __init__(
        self, 
        base_url: str = BASE_URL, 
        timeout: float = TIMEOUT,
    ):
        """
        Initialize the blackbox test client.
        
        Args:
            base_url: Base URL of the API server
            timeout: Request timeout in seconds
        """
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.token: Optional[str] = None
        self.client = httpx.Client(timeout=timeout)
        
    def __enter__(self):
        """Context manager entry."""
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit with client cleanup."""
        self.client.close()

    def url(self, path: str) -> str:
        """Build a full URL from a path."""
        # Ensure path starts with a slash
        if not path.startswith('/'):
            path = f'/{path}'
        return f"{self.base_url}{path}"
        
    def headers(self, additional_headers: Optional[Dict[str, str]] = None) -> Dict[str, str]:
        """
        Build request headers, including auth token if available.
        
        Args:
            additional_headers: Additional headers to include
            
        Returns:
            Dictionary of headers
        """
        result = {"Content-Type": "application/json"}
        
        if self.token:
            result["Authorization"] = f"Bearer {self.token}"
            
        if additional_headers:
            result.update(additional_headers)
            
        return result
    
    # HTTP Methods
    
    def get(self, path: str, params: Optional[Dict[str, Any]] = None, 
            headers: Optional[Dict[str, str]] = None) -> httpx.Response:
        """
        Make a GET request to the API.
        
        Args:
            path: API endpoint path
            params: URL parameters
            headers: Additional headers
            
        Returns:
            Response from the API
        """
        url = self.url(path)
        all_headers = self.headers(headers)
        return self.client.get(url, params=params, headers=all_headers)
    
    def post(self, path: str, json_data: Optional[Dict[str, Any]] = None,
             data: Optional[Dict[str, Any]] = None, 
             headers: Optional[Dict[str, str]] = None) -> httpx.Response:
        """
        Make a POST request to the API.
        
        Args:
            path: API endpoint path
            json_data: JSON data to send
            data: Form data to send
            headers: Additional headers
            
        Returns:
            Response from the API
        """
        url = self.url(path)
        all_headers = self.headers(headers)
        
        # Handle form data vs JSON data
        if data:
            # For form data, remove the Content-Type: application/json header
            if "Content-Type" in all_headers:
                all_headers.pop("Content-Type")
            return self.client.post(url, data=data, headers=all_headers)
        
        return self.client.post(url, json=json_data, headers=all_headers)
    
    def put(self, path: str, json_data: Dict[str, Any], 
            headers: Optional[Dict[str, str]] = None) -> httpx.Response:
        """
        Make a PUT request to the API.
        
        Args:
            path: API endpoint path
            json_data: JSON data to send
            headers: Additional headers
            
        Returns:
            Response from the API
        """
        url = self.url(path)
        all_headers = self.headers(headers)
        return self.client.put(url, json=json_data, headers=all_headers)
    
    def patch(self, path: str, json_data: Dict[str, Any],
              headers: Optional[Dict[str, str]] = None) -> httpx.Response:
        """
        Make a PATCH request to the API.
        
        Args:
            path: API endpoint path
            json_data: JSON data to send
            headers: Additional headers
            
        Returns:
            Response from the API
        """
        url = self.url(path)
        all_headers = self.headers(headers)
        return self.client.patch(url, json=json_data, headers=all_headers)
    
    def delete(self, path: str, headers: Optional[Dict[str, str]] = None) -> httpx.Response:
        """
        Make a DELETE request to the API.
        
        Args:
            path: API endpoint path
            headers: Additional headers
            
        Returns:
            Response from the API
        """
        url = self.url(path)
        all_headers = self.headers(headers)
        return self.client.delete(url, headers=all_headers)
    
    # Authentication helpers
    
    def sign_up(self, email: Optional[str] = None, password: str = "testpassword123",
                full_name: str = "Test User") -> Tuple[httpx.Response, Dict[str, str]]:
        """
        Sign up a new user.
        
        Args:
            email: User email (random if not provided)
            password: User password
            full_name: User full name
            
        Returns:
            Tuple of (response, credentials)
        """
        if not email:
            email = f"test-{uuid.uuid4()}@example.com"
            
        user_data = {
            "email": email,
            "password": password,
            "full_name": full_name
        }
        
        response = self.post("/api/v1/users/signup", json_data=user_data)
        return response, user_data
    
    def login(self, email: str, password: str) -> httpx.Response:
        """
        Log in a user and store the token.
        
        Args:
            email: User email
            password: User password
            
        Returns:
            Login response
        """
        login_data = {
            "username": email,
            "password": password
        }
        
        response = self.post("/api/v1/login/access-token", data=login_data)
        
        if response.status_code == 200:
            token_data = response.json()
            self.token = token_data.get("access_token")
            
        return response
    
    def create_and_login_user(
        self, 
        email: Optional[str] = None, 
        password: str = "testpassword123", 
        full_name: str = "Test User"
    ) -> Dict[str, Any]:
        """
        Create a new user and log in.
        
        Args:
            email: User email (random if not provided)
            password: User password
            full_name: User full name
            
        Returns:
            Dict containing user data and credentials
        """
        signup_response, credentials = self.sign_up(
            email=email, 
            password=password, 
            full_name=full_name
        )
        
        if signup_response.status_code != 200:
            raise ValueError(f"Failed to sign up user: {signup_response.text}")
        
        login_response = self.login(credentials["email"], credentials["password"])
        
        if login_response.status_code != 200:
            raise ValueError(f"Failed to log in user: {login_response.text}")
            
        return {
            "signup_response": signup_response.json(),
            "credentials": credentials,
            "login_response": login_response.json(),
            "token": self.token
        }
    
    # Item management helpers
    
    def create_item(self, title: str, description: Optional[str] = None) -> httpx.Response:
        """
        Create a new item.
        
        Args:
            title: Item title
            description: Item description
            
        Returns:
            Response from the API
        """
        item_data = {
            "title": title
        }
        if description:
            item_data["description"] = description
            
        return self.post("/api/v1/items/", json_data=item_data)
    
    def wait_for_server(self, max_retries: int = 30, delay: float = 1.0) -> bool:
        """
        Wait for the server to be ready by polling the docs endpoint.
        
        Args:
            max_retries: Maximum number of retries
            delay: Delay between retries in seconds
            
        Returns:
            True if server is ready, False otherwise
        """
        docs_url = self.url("/docs")
        
        for attempt in range(max_retries):
            try:
                response = httpx.get(docs_url, timeout=self.timeout)
                if response.status_code == 200:
                    print(f" Server ready at {self.base_url}")
                    return True
                
                print(f"Attempt {attempt + 1}/{max_retries}: Server returned {response.status_code}")
            except httpx.RequestError as e:
                print(f"Attempt {attempt + 1}/{max_retries}: {e}")
                
            time.sleep(delay)
            
        print(f" Server not ready after {max_retries} attempts")
        return False


def random_email() -> str:
    """Generate a random email address for testing."""
    return f"test-{uuid.uuid4()}@example.com"


def random_string(length: int = 10) -> str:
    """Generate a random string for testing."""
    return str(uuid.uuid4())[:length]


def assert_uuid_format(value: str) -> bool:
    """Check if a string is a valid UUID format."""
    try:
        uuid.UUID(value)
        return True
    except (ValueError, AttributeError):
        return False

================
File: backend/app/tests/api/blackbox/conftest.py
================
"""
Configuration and fixtures for blackbox tests.

These tests are designed to test the API as a black box, without any knowledge
of its implementation details. They interact with a running server via HTTP
and do not directly manipulate the database.
"""
import os
import uuid
import time
import pytest
import httpx
from typing import Dict, Any, Generator, Optional

from .client_utils import BlackboxClient

# Set default timeout for test cases
DEFAULT_TIMEOUT = 30.0  # seconds

# Get server URL from environment or use default
DEFAULT_TEST_SERVER_URL = "http://localhost:8000"
TEST_SERVER_URL = os.environ.get("TEST_SERVER_URL", DEFAULT_TEST_SERVER_URL)

# Superuser credentials for admin tests
DEFAULT_ADMIN_EMAIL = "admin@example.com"
DEFAULT_ADMIN_PASSWORD = "admin" 
ADMIN_EMAIL = os.environ.get("FIRST_SUPERUSER", DEFAULT_ADMIN_EMAIL)
ADMIN_PASSWORD = os.environ.get("FIRST_SUPERUSER_PASSWORD", DEFAULT_ADMIN_PASSWORD)

@pytest.fixture(scope="session")
def server_url() -> str:
    """Get the URL of the test server."""
    return TEST_SERVER_URL

@pytest.fixture(scope="session")
def verify_server(server_url: str) -> bool:
    """Verify that the server is running and accessible."""
    # Use the Swagger docs endpoint to check if server is running
    docs_url = f"{server_url}/docs"
    max_retries = 30
    delay = 1.0
    
    print(f"\nChecking if API server is running at {server_url}...")
    
    for attempt in range(max_retries):
        try:
            response = httpx.get(docs_url, timeout=DEFAULT_TIMEOUT)
            if response.status_code == 200:
                print(f" Server is running at {server_url}")
                return True
            
            print(f"Attempt {attempt + 1}/{max_retries}: Server returned {response.status_code}")
        except httpx.RequestError as e:
            print(f"Attempt {attempt + 1}/{max_retries}: {e}")
            
        time.sleep(delay)
        
    # If we reach here, the server is not available
    pytest.fail(f"ERROR: Server not running at {server_url}. "
                f"Run 'docker compose up -d' or 'fastapi dev app/main.py' to start the server.")
    return False  # This line won't be reached due to pytest.fail, but keeps type checking happy

@pytest.fixture(scope="function")
def client(verify_server) -> Generator[BlackboxClient, None, None]:
    """
    Get a BlackboxClient instance connected to the test server.
    
    This fixture verifies that the server is running before creating the client.
    """
    with BlackboxClient(base_url=TEST_SERVER_URL) as test_client:
        yield test_client

@pytest.fixture(scope="function")
def user_client(client) -> Dict[str, Any]:
    """
    Get a client instance authenticated as a regular user.
    
    Returns a dictionary with:
    - client: Authenticated BlackboxClient instance
    - user_data: Dictionary with user information from signup
    - credentials: Dictionary with user credentials
    """
    # Create a random user
    unique_email = f"test-{uuid.uuid4()}@example.com"
    user_password = "testpassword123"
    
    # Sign up and login
    signup_response = client.sign_up(
        email=unique_email,
        password=user_password,
        full_name="Test User"
    )
    
    # Create a new client instance to avoid token sharing
    user_client = BlackboxClient(base_url=TEST_SERVER_URL)
    login_response = user_client.login(unique_email, user_password)
    
    return {
        "client": user_client,
        "user_data": signup_response[0].json(),
        "credentials": signup_response[1]
    }

@pytest.fixture(scope="function")
def admin_client() -> Generator[BlackboxClient, None, None]:
    """
    Get a client instance authenticated as a superuser/admin.
    
    This fixture attempts to log in with the superuser credentials
    from environment variables or defaults.
    """
    with BlackboxClient(base_url=TEST_SERVER_URL) as admin_client:
        login_response = admin_client.login(ADMIN_EMAIL, ADMIN_PASSWORD)
        
        if login_response.status_code != 200:
            pytest.skip("Admin authentication failed. Ensure the superuser exists.")
            
        yield admin_client

@pytest.fixture(scope="function")
def user_and_items(client) -> Dict[str, Any]:
    """
    Create a user with test items and return client and item data.
    
    Returns a dictionary with:
    - client: Authenticated BlackboxClient instance
    - user_data: User information
    - credentials: User credentials
    - items: List of items created for the user
    """
    # Create user
    user_data = client.create_and_login_user()
    
    # Create test items
    items = []
    for i in range(3):
        response = client.create_item(
            title=f"Test Item {i}",
            description=f"Test Description {i}"
        )
        if response.status_code == 200:
            items.append(response.json())
            
    return {
        "client": client,
        "user_data": user_data["signup_response"],
        "credentials": user_data["credentials"],
        "items": items
    }

================
File: backend/app/tests/api/blackbox/dependencies.py
================
"""
Custom dependencies for blackbox tests.

These dependencies override the regular application dependencies
to work with the test database and simplified models.
"""
from typing import Annotated, Generator

import jwt
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from sqlmodel import Session, select

from app.core import security
from app.core.config import settings

from .test_models import User

# Use the same OAuth2 password bearer as the main app
reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)


# We'll override this in tests via dependency injection
def get_test_db() -> Generator[Session, None, None]:
    """
    Placeholder function that will be overridden in tests.
    """
    raise NotImplementedError("This function should be overridden in tests")


TestSessionDep = Annotated[Session, Depends(get_test_db)]
TestTokenDep = Annotated[str, Depends(reusable_oauth2)]


def get_current_test_user(session: TestSessionDep, token: TestTokenDep) -> User:
    """
    Get the current user from the provided token.
    This is similar to the regular get_current_user but works with our test models.
    """
    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[security.ALGORITHM]
        )
        sub = payload.get("sub")
        if sub is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    # Use string ID for test User model
    user = session.exec(select(User).where(User.id == sub)).first()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    if not user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    
    return user


TestCurrentUser = Annotated[User, Depends(get_current_test_user)]


def get_current_active_test_superuser(current_user: TestCurrentUser) -> User:
    """Verify the user is a superuser."""
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=403, detail="The user doesn't have enough privileges"
        )
    return current_user

================
File: backend/app/tests/api/blackbox/pytest.ini
================
[pytest]
# Skip application-level conftest
norecursedirs = ../../conftest.py ../../../conftest.py
# Only use our blackbox-specific fixtures
pythonpath = .

================
File: backend/app/tests/api/blackbox/README.md
================
# Blackbox Tests

This directory contains blackbox tests for the API. These tests interact with a running API server via HTTP requests, without any knowledge of the internal implementation.

## Test Approach

- Tests use httpx to make real HTTP requests to a running server
- No direct database manipulation - all data is created/read/updated/deleted via the API
- Tests have no knowledge of internal implementation details
- Tests can be run against any server (local, Docker, remote)

## Running the Tests

Tests can be run using the included script:

```bash
cd backend
bash scripts/run_blackbox_tests.sh
```

The script will:
1. Check if a server is already running, or start one if needed
2. Run the basic infrastructure tests first
3. If they pass, run the full test suite
4. Generate test reports
5. Stop the server if it was started by the script

## Test Categories

- **Basic Tests**: Verify server is running and basic API functionality works
- **API Contract Tests**: Verify API endpoints adhere to their contracts
- **User Lifecycle Tests**: Verify complete user flows from creation to deletion
- **Authorization Tests**: Verify permission rules are enforced correctly

## Client Utilities

The `client_utils.py` module provides a `BlackboxClient` class that wraps httpx with API-specific helpers. This simplifies test writing and maintenance.

Example usage:

```python
# Create a client
client = BlackboxClient()

# Create a user
signup_response, credentials = client.sign_up(
    email="test@example.com",
    password="testpassword123",
    full_name="Test User"
)

# Login to get a token
client.login(credentials["email"], credentials["password"])

# The token is automatically stored and used in subsequent requests
user_profile = client.get("/api/v1/users/me")

# Create an item
item = client.create_item("Test Item", "Description").json()
```

## Test Utilities

The `test_utils.py` module provides helper functions for common test operations and assertions:

- `create_random_user`: Create a user with random data
- `create_test_item`: Create a test item for a user
- `assert_validation_error`: Verify a 422 validation error response
- `assert_not_found_error`: Verify a 404 not found error response
- `assert_unauthorized_error`: Verify a 401/403 unauthorized error response
- `verify_user_object`: Verify a user object has the expected structure
- `verify_item_object`: Verify an item object has the expected structure

## Environment Variables

The tests use the following environment variables:

- `TEST_SERVER_URL`: URL of the API server (default: http://localhost:8000)
- `TEST_REQUEST_TIMEOUT`: Request timeout in seconds (default: 30.0)
- `FIRST_SUPERUSER`: Email of the superuser account for admin tests
- `FIRST_SUPERUSER_PASSWORD`: Password of the superuser account

## Admin Tests

Some tests require a superuser account to run. These tests will be skipped if:

1. No superuser credentials are provided in environment variables
2. The superuser login fails

If you want to run admin tests, ensure the superuser exists in the database and provide valid credentials in the environment variables.

================
File: backend/app/tests/api/blackbox/test_api_contract.py
================
"""
Blackbox test for API contracts.

This test verifies that API endpoints adhere to their expected contracts:
- Response schemas conform to specifications
- Status codes are correct for different scenarios
- Validation rules are properly enforced
"""
import uuid
from typing import Dict, Any

import pytest
import httpx

from .client_utils import BlackboxClient
from .test_utils import (
    assert_validation_error,
    assert_not_found_error,
    assert_unauthorized_error,
    assert_uuid_format,
    verify_user_object,
    verify_item_object
)

def test_user_signup_contract(client):
    """Test that user signup endpoint adheres to contract."""
    user_data = {
        "email": f"signup-{uuid.uuid4()}@example.com",
        "password": "testpassword123",
        "full_name": "Signup Test User"
    }
    
    # Test the signup endpoint
    response, _ = client.sign_up(
        email=user_data["email"],
        password=user_data["password"],
        full_name=user_data["full_name"]
    )
    
    assert response.status_code == 200, f"Signup failed: {response.text}"
    
    result = response.json()
    # Verify response schema by checking all required fields
    verify_user_object(result)
    
    # Verify field values
    assert result["email"] == user_data["email"]
    assert result["full_name"] == user_data["full_name"]
    assert result["is_active"] is True
    assert result["is_superuser"] is False
    
    # Verify UUID format
    assert assert_uuid_format(result["id"]), "User ID is not a valid UUID"
    
    # Test validation errors
    # 1. Test invalid email format
    invalid_email_response, _ = client.sign_up(
        email="not-an-email",
        password="testpassword123",
        full_name="Validation Test"
    )
    assert_validation_error(invalid_email_response)
    
    # 2. Test short password
    short_pw_response, _ = client.sign_up(
        email="test@example.com",
        password="short",
        full_name="Validation Test"
    )
    assert_validation_error(short_pw_response)

def test_login_contract(client):
    """Test that login endpoint adheres to contract."""
    # Create a user first
    unique_email = f"login-{uuid.uuid4()}@example.com"
    password = "testpassword123"
    
    signup_response, _ = client.sign_up(
        email=unique_email,
        password=password,
        full_name="Login Test User"
    )
    assert signup_response.status_code == 200
    
    # Test login with the credentials
    login_response = client.login(unique_email, password)
    assert login_response.status_code == 200, f"Login failed: {login_response.text}"
    
    result = login_response.json()
    # Verify response schema
    assert "access_token" in result
    assert "token_type" in result
    
    # Verify token type
    assert result["token_type"].lower() == "bearer"
    
    # Verify token format (non-empty string)
    assert isinstance(result["access_token"], str)
    assert len(result["access_token"]) > 0
    
    # Test login with wrong credentials
    wrong_login_response = client.post("/api/v1/login/access-token", data={
        "username": unique_email,
        "password": "wrongpassword"
    })
    assert wrong_login_response.status_code in (400, 401), \
        f"Expected 400/401 for wrong password, got: {wrong_login_response.status_code}"
        
    # Test login with non-existent user
    nonexistent_login_response = client.post("/api/v1/login/access-token", data={
        "username": f"nonexistent-{uuid.uuid4()}@example.com",
        "password": "testpassword123"
    })
    assert nonexistent_login_response.status_code in (400, 401), \
        f"Expected 400/401 for nonexistent user, got: {nonexistent_login_response.status_code}"

def test_me_endpoint_contract(client):
    """Test that /users/me endpoint adheres to contract."""
    # Create a user and log in
    user_data = client.create_and_login_user()
    
    # Test /users/me endpoint
    response = client.get("/api/v1/users/me")
    assert response.status_code == 200, f"Get user profile failed: {response.text}"
    
    result = response.json()
    # Verify response schema
    verify_user_object(result)
    
    # Verify field values
    assert result["email"] == user_data["credentials"]["email"]
    assert result["full_name"] == user_data["credentials"]["full_name"]
    
    # Test unauthorized access
    # Create a new client without authentication
    unauthenticated_client = BlackboxClient(base_url=client.base_url)
    unauthenticated_response = unauthenticated_client.get("/api/v1/users/me")
    assert_unauthorized_error(unauthenticated_response)

def test_create_item_contract(client):
    """Test that item creation endpoint adheres to contract."""
    # Create a user and log in
    client.create_and_login_user()
    
    # Create an item
    item_data = {
        "title": "Test Item",
        "description": "Test Description"
    }
    
    response = client.create_item(
        title=item_data["title"],
        description=item_data["description"]
    )
    
    assert response.status_code == 200, f"Create item failed: {response.text}"
    
    result = response.json()
    # Verify response schema
    assert "id" in result
    assert "title" in result
    assert "description" in result
    assert "owner_id" in result
    
    # Verify field values
    assert result["title"] == item_data["title"]
    assert result["description"] == item_data["description"]
    
    # Verify UUID format
    assert assert_uuid_format(result["id"])
    assert assert_uuid_format(result["owner_id"])
    
    # Test validation errors
    # Missing required field (title)
    invalid_response = client.post("/api/v1/items/", json_data={
        "description": "Missing Title"
    })
    assert_validation_error(invalid_response)

def test_get_items_contract(client):
    """Test that items list endpoint adheres to contract."""
    # Create a user and log in
    client.create_and_login_user()
    
    # Create a few items
    created_items = []
    for i in range(3):
        item_response = client.create_item(
            title=f"Item {i}",
            description=f"Description {i}"
        )
        if item_response.status_code == 200:
            created_items.append(item_response.json())
    
    # Get items list
    response = client.get("/api/v1/items/")
    assert response.status_code == 200, f"Get items failed: {response.text}"
    
    result = response.json()
    # Verify response schema
    assert "data" in result
    assert "count" in result
    assert isinstance(result["data"], list)
    assert isinstance(result["count"], int)
    
    # Verify items schema
    if len(result["data"]) > 0:
        for item in result["data"]:
            verify_item_object(item)
    
    # Verify count matches actual items returned
    assert result["count"] == len(result["data"])
    
    # Verify pagination
    if len(result["data"]) > 1:
        # Test with limit parameter
        limit = 1
        limit_response = client.get(f"/api/v1/items/?limit={limit}")
        assert limit_response.status_code == 200
        limit_result = limit_response.json()
        assert len(limit_result["data"]) <= limit
        
        # Test with skip parameter
        skip = 1
        skip_response = client.get(f"/api/v1/items/?skip={skip}")
        assert skip_response.status_code == 200

def test_not_found_contract(client):
    """Test that not found errors follow the expected format."""
    # Create a user and log in
    client.create_and_login_user()
    
    # Test with non-existent item
    non_existent_id = str(uuid.uuid4())
    response = client.get(f"/api/v1/items/{non_existent_id}")
    assert_not_found_error(response)
    
    # Test with non-existent user (admin endpoint)
    non_existent_id = str(uuid.uuid4())
    response = client.get(f"/api/v1/users/{non_existent_id}")
    assert response.status_code in (403, 404), \
        f"Expected 403/404 for non-admin or non-existent, got: {response.status_code}"

def test_validation_error_contract(client):
    """Test that validation errors follow the expected format."""
    # Create invalid user data
    invalid_data = {
        "email": "not-an-email",
        "password": "testpassword123",
        "full_name": "Validation Test"
    }
    response = client.post("/api/v1/users/signup", json_data=invalid_data)
    assert_validation_error(response)
    
    # Test with short password
    short_pw_data = {
        "email": "test@example.com",
        "password": "short",
        "full_name": "Validation Test"
    }
    response = client.post("/api/v1/users/signup", json_data=short_pw_data)
    assert_validation_error(response)
    
    # Test with missing required field
    missing_data = {"email": "test@example.com"}
    response = client.post("/api/v1/users/signup", json_data=missing_data)
    assert_validation_error(response)

def test_update_item_contract(client):
    """Test that item update endpoint adheres to contract."""
    # Create a user and log in
    client.create_and_login_user()
    
    # Create an item first
    item_data = {
        "title": "Original Item",
        "description": "Original Description"
    }
    create_response = client.create_item(
        title=item_data["title"],
        description=item_data["description"]
    )
    assert create_response.status_code == 200
    item_id = create_response.json()["id"]
    
    # Update the item
    update_data = {
        "title": "Updated Item",
        "description": "Updated Description"
    }
    update_response = client.put(f"/api/v1/items/{item_id}", json_data=update_data)
    assert update_response.status_code == 200, f"Update item failed: {update_response.text}"
    
    result = update_response.json()
    # Verify response schema
    assert "id" in result
    assert "title" in result
    assert "description" in result
    assert "owner_id" in result
    
    # Verify field values are updated
    assert result["title"] == update_data["title"]
    assert result["description"] == update_data["description"]
    
    # ID and owner should remain the same
    assert result["id"] == item_id
    
    # Test validation errors on update
    invalid_update_data = {"title": ""}  # Empty title should be invalid
    invalid_response = client.put(f"/api/v1/items/{item_id}", json_data=invalid_update_data)
    assert_validation_error(invalid_response)

def test_unauthorized_contract(client):
    """Test that unauthorized errors follow the expected format."""
    # Create a regular client without authentication
    unauthenticated_client = BlackboxClient(base_url=client.base_url)
    
    # Test protected endpoint with invalid token
    headers = {"Authorization": "Bearer invalid-token"}
    response = unauthenticated_client.get("/api/v1/users/me", headers=headers)
    assert_unauthorized_error(response)
    
    # Test protected endpoint with no token
    response = unauthenticated_client.get("/api/v1/users/me")
    assert_unauthorized_error(response)
    
    # Test protected endpoint with expired token
    # This is hard to test in a blackbox manner without manipulating tokens
    # For now, we'll just assert that the server handles auth errors consistently
    
    # Create a user and authenticate
    client.create_and_login_user()
    
    # Try to access resources that require different permissions
    # Regular user attempt to access admin endpoints
    users_response = client.get("/api/v1/users/")
    assert users_response.status_code in (401, 403, 404), \
        f"Expected permission error, got: {users_response.status_code}"

================
File: backend/app/tests/api/blackbox/test_basic.py
================
"""
Basic tests to verify the API server is running and responding to requests.

These tests simply check that the server is properly set up and responding
to basic requests as expected, without any complex authentication or business logic.
"""
import uuid
import pytest

from .client_utils import BlackboxClient

def test_server_is_running(client):
    """Test that the server is running and accessible."""
    # Use the docs endpoint to verify server is up
    response = client.get("/docs")
    assert response.status_code == 200
    
    # Should return HTML for the Swagger UI
    assert "text/html" in response.headers.get("content-type", "")

def test_public_endpoints(client):
    """Test that public endpoints are accessible without authentication."""
    # Test signup endpoint availability (without actually creating a user)
    # Just check that it returns the correct error for invalid data
    # rather than an authorization error
    response = client.post("/api/v1/users/signup", json_data={})
    
    # Should return validation error (422), not auth error (401/403)
    assert response.status_code == 422, \
        f"Expected validation error, got {response.status_code}: {response.text}"
        
    # Test login endpoint availability
    response = client.post("/api/v1/login/access-token", data={
        "username": "nonexistent@example.com",
        "password": "wrongpassword"
    })
    
    # Should return error (400 or 401), not "not found" or other error
    # Different FastAPI implementations may return 400 or 401 for invalid credentials
    assert response.status_code in (400, 401), \
        f"Expected authentication error, got {response.status_code}: {response.text}"

def test_auth_token_flow(client):
    """Test that the authentication flow works correctly using tokens."""
    # Create a random user
    unique_email = f"test-{uuid.uuid4()}@example.com"
    password = "testpassword123"
    
    # Sign up
    signup_response, user_credentials = client.sign_up(
        email=unique_email, 
        password=password,
        full_name="Test User"
    )
    
    assert signup_response.status_code == 200, \
        f"Signup failed: {signup_response.text}"
    
    # Login to get token
    login_response = client.login(unique_email, password)
    
    assert login_response.status_code == 200, \
        f"Login failed: {login_response.text}"
    
    token_data = login_response.json()
    assert "access_token" in token_data, \
        f"Login response missing access token: {token_data}"
    assert "token_type" in token_data, \
        f"Login response missing token type: {token_data}"
    assert token_data["token_type"].lower() == "bearer", \
        f"Expected bearer token, got: {token_data['token_type']}"
    
    # Test token by accessing a protected endpoint
    me_response = client.get("/api/v1/users/me")
    
    assert me_response.status_code == 200, \
        f"Access with token failed: {me_response.text}"
        
    me_data = me_response.json()
    assert me_data["email"] == unique_email, \
        f"User 'me' data has wrong email. Expected {unique_email}, got {me_data['email']}"

def test_item_creation(client):
    """Test that item creation and retrieval works correctly."""
    # Create a random user
    unique_email = f"test-{uuid.uuid4()}@example.com"
    password = "testpassword123"
    client.sign_up(email=unique_email, password=password)
    client.login(unique_email, password)
    
    # Create an item
    item_title = f"Test Item {uuid.uuid4().hex[:8]}"
    item_description = "This is a test item description"
    
    create_response = client.create_item(
        title=item_title, 
        description=item_description
    )
    
    assert create_response.status_code == 200, \
        f"Item creation failed: {create_response.text}"
    
    item_data = create_response.json()
    assert "id" in item_data, \
        f"Item creation response missing ID: {item_data}"
    assert item_data["title"] == item_title, \
        f"Item title mismatch. Expected {item_title}, got {item_data['title']}"
    assert item_data["description"] == item_description, \
        f"Item description mismatch. Expected {item_description}, got {item_data['description']}"
    
    # Get the item to verify
    item_id = item_data["id"]
    get_response = client.get(f"/api/v1/items/{item_id}")
    
    assert get_response.status_code == 200, \
        f"Item retrieval failed: {get_response.text}"
        
    get_item = get_response.json()
    assert get_item["id"] == item_id, \
        f"Item ID mismatch. Expected {item_id}, got {get_item['id']}"
    assert get_item["title"] == item_title, \
        f"Item title mismatch. Expected {item_title}, got {get_item['title']}"

================
File: backend/app/tests/api/blackbox/test_user_lifecycle.py
================
"""
Blackbox test for complete user lifecycle.

This test verifies that the entire user flow works correctly,
from registration to deletion, including creating, updating and
deleting items, all via HTTP requests to a running server.
"""
import uuid
import pytest
from typing import Dict, Any

from .client_utils import BlackboxClient
from .test_utils import create_random_user, assert_uuid_format

def test_complete_user_lifecycle(client):
    """Test the complete lifecycle of a user including authentication and item management."""
    # 1. Create a user (signup)
    signup_data = {
        "email": f"lifecycle-{uuid.uuid4()}@example.com", 
        "password": "testpassword123", 
        "full_name": "Lifecycle Test"
    }
    signup_response, credentials = client.sign_up(
        email=signup_data["email"],
        password=signup_data["password"],
        full_name=signup_data["full_name"]
    )
    
    assert signup_response.status_code == 200, f"Signup failed: {signup_response.text}"
    user_data = signup_response.json()
    assert_uuid_format(user_data["id"])
    
    # 2. Login with the new user
    login_response = client.login(
        email=signup_data["email"],
        password=signup_data["password"]
    )
    
    assert login_response.status_code == 200, f"Login failed: {login_response.text}"
    tokens = login_response.json()
    assert "access_token" in tokens
    
    # 3. Get user profile with token
    profile_response = client.get("/api/v1/users/me")
    assert profile_response.status_code == 200, f"Get profile failed: {profile_response.text}"
    user_profile = profile_response.json()
    assert user_profile["email"] == signup_data["email"]
    
    # 4. Update user details
    update_data = {"full_name": "Updated Name"}
    update_response = client.patch("/api/v1/users/me", json_data=update_data)
    assert update_response.status_code == 200, f"Update user failed: {update_response.text}"
    updated_data = update_response.json()
    assert updated_data["full_name"] == update_data["full_name"]
    
    # 5. Create an item
    item_data = {"title": "Test Item", "description": "Test Description"}
    item_response = client.create_item(
        title=item_data["title"], 
        description=item_data["description"]
    )
    
    assert item_response.status_code == 200, f"Create item failed: {item_response.text}"
    item = item_response.json()
    item_id = item["id"]
    assert_uuid_format(item_id)
    
    # 6. Get the item
    get_item_response = client.get(f"/api/v1/items/{item_id}")
    assert get_item_response.status_code == 200, f"Get item failed: {get_item_response.text}"
    assert get_item_response.json()["title"] == item_data["title"]
    
    # 7. Update the item
    item_update = {"title": "Updated Item"}
    update_item_response = client.put(f"/api/v1/items/{item_id}", json_data=item_update)
    assert update_item_response.status_code == 200, f"Update item failed: {update_item_response.text}"
    assert update_item_response.json()["title"] == item_update["title"]
    
    # 8. Delete the item
    delete_item_response = client.delete(f"/api/v1/items/{item_id}")
    assert delete_item_response.status_code == 200, f"Delete item failed: {delete_item_response.text}"
    
    # 9. Change user password
    password_data = {
        "current_password": signup_data["password"],
        "new_password": "newpassword123"
    }
    password_response = client.patch("/api/v1/users/me/password", json_data=password_data)
    assert password_response.status_code == 200, f"Password change failed: {password_response.text}"
    
    # 10. Verify login with new password works
    # Create a new client to avoid using the existing token
    new_client = BlackboxClient(base_url=client.base_url)
    new_login_response = new_client.login(
        email=signup_data["email"],
        password="newpassword123"
    )
    assert new_login_response.status_code == 200, f"Login with new password failed: {new_login_response.text}"
    
    # 11. Delete user account
    # Use the original client which has the token
    delete_response = client.delete("/api/v1/users/me")
    assert delete_response.status_code == 200, f"Delete user failed: {delete_response.text}"
    
    # 12. Verify user account is deleted (attempt login)
    failed_login_client = BlackboxClient(base_url=client.base_url)
    failed_login_response = failed_login_client.login(
        email=signup_data["email"],
        password="newpassword123"
    )
    assert failed_login_response.status_code != 200, "Login should fail for deleted user"


def test_admin_user_management(admin_client, client):
    """Test the admin capabilities for user management."""
    # Skip if admin client wasn't created successfully
    if not admin_client.token:
        pytest.skip("Admin client not available (login failed)")
        
    # 1. Admin creates a new user
    new_user_data = {
        "email": f"admintest-{uuid.uuid4()}@example.com",
        "password": "testpassword123",
        "full_name": "Admin Created User",
        "is_superuser": False
    }
    create_response = admin_client.post("/api/v1/users/", json_data=new_user_data)
    assert create_response.status_code == 200, f"Admin create user failed: {create_response.text}"
    new_user = create_response.json()
    user_id = new_user["id"]
    assert_uuid_format(user_id)
    
    # 2. Admin gets user by ID
    get_response = admin_client.get(f"/api/v1/users/{user_id}")
    assert get_response.status_code == 200, f"Admin get user failed: {get_response.text}"
    assert get_response.json()["email"] == new_user_data["email"]
    
    # 3. Admin updates user
    update_data = {"full_name": "Updated By Admin", "is_superuser": True}
    update_response = admin_client.patch(f"/api/v1/users/{user_id}", json_data=update_data)
    assert update_response.status_code == 200, f"Admin update user failed: {update_response.text}"
    updated_user = update_response.json()
    assert updated_user["full_name"] == update_data["full_name"]
    assert updated_user["is_superuser"] == update_data["is_superuser"]
    
    # 4. Admin lists all users
    list_response = admin_client.get("/api/v1/users/")
    assert list_response.status_code == 200, f"Admin list users failed: {list_response.text}"
    users = list_response.json()
    assert "data" in users
    assert "count" in users
    assert isinstance(users["data"], list)
    assert len(users["data"]) >= 1
    
    # 5. Admin deletes user
    delete_response = admin_client.delete(f"/api/v1/users/{user_id}")
    assert delete_response.status_code == 200, f"Admin delete user failed: {delete_response.text}"
    
    # 6. Verify user is deleted
    get_deleted_response = admin_client.get(f"/api/v1/users/{user_id}")
    assert get_deleted_response.status_code == 404, "Deleted user should not be accessible"
    
    # 7. Verify regular user can't access admin endpoints
    # Create a regular user
    regular_client = BlackboxClient(base_url=client.base_url)
    user_data = regular_client.create_and_login_user()
    
    # Try to list all users (admin-only endpoint)
    regular_list_response = regular_client.get("/api/v1/users/")
    assert regular_list_response.status_code in (401, 403, 404), \
        "Regular user should not access admin endpoints"

================
File: backend/app/tests/api/blackbox/test_utils.py
================
"""
Utilities for blackbox testing to simplify common operations.

This module provides functions for testing common API operations and verification
without any knowledge of the database or implementation details.
"""
import json
import uuid
import random
import string
from typing import Dict, Any, List, Tuple, Optional, Union

from .client_utils import BlackboxClient

def create_random_user(client: BlackboxClient) -> Dict[str, Any]:
    """
    Create a random user and return user data with credentials.
    
    Args:
        client: API client instance
        
    Returns:
        Dictionary with user information and credentials
    """
    # Generate random credentials
    email = f"test-{uuid.uuid4()}@example.com"
    password = "".join(random.choices(string.ascii_letters + string.digits, k=12))
    full_name = f"Test User {uuid.uuid4().hex[:8]}"
    
    # Create user and login
    user_data = client.create_and_login_user(email, password, full_name)
    return user_data

def create_test_item(client: BlackboxClient, title: Optional[str] = None, description: Optional[str] = None) -> Dict[str, Any]:
    """
    Create a test item and return the item data.
    
    Args:
        client: API client instance
        title: Item title (random if not provided)
        description: Item description (random if not provided)
        
    Returns:
        Item data from API response
    """
    if not title:
        title = f"Test Item {uuid.uuid4().hex[:8]}"
        
    if not description:
        description = f"Test description {uuid.uuid4().hex[:16]}"
    
    response = client.create_item(title=title, description=description)
    
    if response.status_code != 200:
        raise ValueError(f"Failed to create item: {response.text}")
        
    return response.json()

def assert_error_response(response, expected_status_code: int) -> None:
    """
    Assert that a response is an error with expected status code.
    
    Args:
        response: HTTP response
        expected_status_code: Expected HTTP status code
    """
    assert response.status_code == expected_status_code, \
        f"Expected status code {expected_status_code}, got {response.status_code}: {response.text}"
        
    error_data = response.json()
    assert "detail" in error_data, \
        f"Error response missing 'detail' field: {error_data}"

def assert_validation_error(response) -> None:
    """
    Assert that a response is a validation error (422).
    
    Args:
        response: HTTP response
    """
    assert_error_response(response, 422)
    error_data = response.json()
    
    assert isinstance(error_data["detail"], list), \
        f"Validation error should have list of details: {error_data}"
        
    for detail in error_data["detail"]:
        assert "loc" in detail, f"Validation error detail missing 'loc': {detail}"
        assert "msg" in detail, f"Validation error detail missing 'msg': {detail}"
        assert "type" in detail, f"Validation error detail missing 'type': {detail}"

def assert_not_found_error(response) -> None:
    """
    Assert that a response is a not found error (404).
    
    Args:
        response: HTTP response
    """
    assert_error_response(response, 404)

def assert_unauthorized_error(response) -> None:
    """
    Assert that a response is an unauthorized error (401 or 403).
    
    Args:
        response: HTTP response
    """
    assert response.status_code in (401, 403), \
        f"Expected status code 401 or 403, got {response.status_code}: {response.text}"
        
    error_data = response.json()
    assert "detail" in error_data, \
        f"Error response missing 'detail' field: {error_data}"

def create_superuser_client() -> BlackboxClient:
    """
    Create a client authenticated as superuser.
    
    This requires that the server has a superuser account available with
    known credentials from the environment.
    
    Returns:
        Authenticated client instance
    """
    # The superuser credentials should be available in the environment
    # Typically, the first superuser from FIRST_SUPERUSER/FIRST_SUPERUSER_PASSWORD
    import os
    
    superuser_email = os.environ.get("FIRST_SUPERUSER", "admin@example.com")
    superuser_password = os.environ.get("FIRST_SUPERUSER_PASSWORD", "admin")
    
    client = BlackboxClient()
    login_response = client.login(superuser_email, superuser_password)
    
    if login_response.status_code != 200:
        raise ValueError(f"Failed to log in as superuser: {login_response.text}")
        
    return client

def verify_user_object(user_data: Dict[str, Any]) -> None:
    """
    Verify that a user object has the expected structure.
    
    Args:
        user_data: User data from API response
    """
    assert "id" in user_data, "User object missing 'id'"
    assert "email" in user_data, "User object missing 'email'"
    assert "is_active" in user_data, "User object missing 'is_active'"
    assert "is_superuser" in user_data, "User object missing 'is_superuser'"
    assert "full_name" in user_data, "User object missing 'full_name'"
    
    # Password should NEVER be included in user objects
    assert "password" not in user_data, "User object should not include 'password'"
    assert "hashed_password" not in user_data, "User object should not include 'hashed_password'"

def verify_item_object(item_data: Dict[str, Any]) -> None:
    """
    Verify that an item object has the expected structure.
    
    Args:
        item_data: Item data from API response
    """
    assert "id" in item_data, "Item object missing 'id'"
    assert "title" in item_data, "Item object missing 'title'"
    assert "owner_id" in item_data, "Item object missing 'owner_id'"
    # Note: description is optional in the schema

def assert_uuid_format(value: str) -> bool:
    """Check if a string is a valid UUID format."""
    try:
        uuid.UUID(value)
        return True
    except (ValueError, AttributeError):
        return False

================
File: backend/app/tests/services/test_user_service.py
================
"""
Tests for user service.

This module tests the user service functionality.
"""
import uuid
from fastapi.encoders import jsonable_encoder
from sqlmodel import Session

from app.core.security import verify_password
from app.modules.users.domain.models import User
from app.modules.users.domain.models import UserCreate, UserUpdate
from app.modules.users.services.user_service import UserService
from app.shared.exceptions import NotFoundException, ValidationException
from app.tests.utils.utils import random_email, random_lower_string

import pytest


def test_create_user(user_service: UserService) -> None:
    """Test creating a user."""
    email = random_email()
    password = random_lower_string()
    user_in = UserCreate(email=email, password=password)
    user = user_service.create_user(user_in)
    assert user.email == email
    assert hasattr(user, "hashed_password")


def test_create_user_duplicate_email(user_service: UserService) -> None:
    """Test creating a user with duplicate email fails."""
    email = random_email()
    password = random_lower_string()
    user_in = UserCreate(email=email, password=password)
    user_service.create_user(user_in)

    # Try to create another user with the same email
    with pytest.raises(ValidationException):
        user_service.create_user(user_in)


def test_authenticate_user(user_service: UserService) -> None:
    """Test authenticating a user."""
    email = random_email()
    password = random_lower_string()
    user_in = UserCreate(email=email, password=password)
    user = user_service.create_user(user_in)

    # Use the auth service for authentication
    authenticated_user = user_service.get_user_by_email(email)
    assert authenticated_user is not None
    assert verify_password(password, authenticated_user.hashed_password)
    assert user.email == authenticated_user.email


def test_get_non_existent_user(user_service: UserService) -> None:
    """Test getting a non-existent user raises exception."""
    non_existent_id = uuid.uuid4()

    with pytest.raises(NotFoundException):
        user_service.get_user(non_existent_id)


def test_check_if_user_is_active(user_service: UserService) -> None:
    """Test checking if user is active."""
    email = random_email()
    password = random_lower_string()
    user_in = UserCreate(email=email, password=password)
    user = user_service.create_user(user_in)
    assert user.is_active is True


def test_check_if_user_is_superuser(user_service: UserService) -> None:
    """Test checking if user is superuser."""
    email = random_email()
    password = random_lower_string()
    user_in = UserCreate(email=email, password=password, is_superuser=True)
    user = user_service.create_user(user_in)
    assert user.is_superuser is True


def test_check_if_user_is_superuser_normal_user(user_service: UserService) -> None:
    """Test checking if normal user is not superuser."""
    email = random_email()
    password = random_lower_string()
    user_in = UserCreate(email=email, password=password)
    user = user_service.create_user(user_in)
    assert user.is_superuser is False


def test_get_user(db: Session, user_service: UserService) -> None:
    """Test getting a user by ID."""
    password = random_lower_string()
    email = random_email()
    user_in = UserCreate(email=email, password=password, is_superuser=True)
    user = user_service.create_user(user_in)
    user_2 = user_service.get_user(user.id)
    assert user_2
    assert user.email == user_2.email
    assert jsonable_encoder(user) == jsonable_encoder(user_2)


def test_update_user(db: Session, user_service: UserService) -> None:
    """Test updating a user."""
    password = random_lower_string()
    email = random_email()
    user_in = UserCreate(email=email, password=password, is_superuser=True)
    user = user_service.create_user(user_in)
    new_password = random_lower_string()
    user_in_update = UserUpdate(password=new_password, is_superuser=True)
    updated_user = user_service.update_user(user.id, user_in_update)
    assert updated_user
    assert user.email == updated_user.email
    assert verify_password(new_password, updated_user.hashed_password)


def test_update_user_me(db: Session, user_service: UserService) -> None:
    """Test user updating their own profile."""
    password = random_lower_string()
    email = random_email()
    user_in = UserCreate(email=email, password=password)
    user = user_service.create_user(user_in)

    # Update full name
    new_name = "New Name"
    from app.modules.users.domain.models import UserUpdateMe
    update_data = UserUpdateMe(full_name=new_name)
    updated_user = user_service.update_user_me(user, update_data)

    assert updated_user.full_name == new_name
    assert updated_user.email == email

================
File: backend/app/tests/conftest.py
================
"""
Testing configuration.

This module provides fixtures for testing.
"""
from collections.abc import Generator
from contextlib import contextmanager
from typing import Dict

import pytest
from fastapi.testclient import TestClient
from sqlmodel import Session, delete

from app.core.config import settings
from app.core.db import engine
from app.main import app
from app.modules.items.domain.models import Item
from app.modules.users.domain.models import User
from app.modules.users.services.user_service import UserService
from app.modules.users.repository.user_repo import UserRepository
from app.tests.utils.user import authentication_token_from_email
from app.tests.utils.utils import get_superuser_token_headers


@contextmanager
def get_test_db() -> Generator[Session, None, None]:
    """
    Get a database session for testing.

    Yields:
        Database session
    """
    with Session(engine) as session:
        try:
            yield session
        finally:
            session.close()


@pytest.fixture(scope="session", autouse=True)
def db() -> Generator[Session, None, None]:
    """
    Database fixture for testing.

    This fixture sets up the database for testing and cleans up after tests.

    Yields:
        Database session
    """
    with Session(engine) as session:
        # Create initial data for testing
        _create_initial_test_data(session)

        yield session

        # Clean up test data
        statement = delete(Item)
        session.execute(statement)
        statement = delete(User)
        session.execute(statement)
        session.commit()


def _create_initial_test_data(session: Session) -> None:
    """
    Create initial data for testing.

    Args:
        session: Database session
    """
    # Create initial superuser if not exists
    user_repo = UserRepository(session)
    user_service = UserService(user_repo)
    user_service.create_initial_superuser()


@pytest.fixture(scope="module")
def client() -> Generator[TestClient, None, None]:
    """
    Test client fixture.

    Yields:
        Test client
    """
    with TestClient(app) as c:
        yield c


@pytest.fixture(scope="module")
def superuser_token_headers(client: TestClient) -> Dict[str, str]:
    """
    Superuser token headers fixture.

    Args:
        client: Test client

    Returns:
        Headers with superuser token
    """
    return get_superuser_token_headers(client)


@pytest.fixture(scope="module")
def normal_user_token_headers(client: TestClient, db: Session) -> Dict[str, str]:
    """
    Normal user token headers fixture.

    Args:
        client: Test client
        db: Database session

    Returns:
        Headers with normal user token
    """
    return authentication_token_from_email(
        client=client, email=settings.EMAIL_TEST_USER, db=db
    )


@pytest.fixture(scope="function")
def user_service(db: Session) -> UserService:
    """
    User service fixture.

    Args:
        db: Database session

    Returns:
        User service instance
    """
    user_repo = UserRepository(db)
    return UserService(user_repo)

================
File: backend/app/main.py
================
"""
Application entry point.

This module creates and configures the FastAPI application.
"""
import sentry_sdk
from fastapi import FastAPI
from fastapi.routing import APIRoute
from starlette.middleware.cors import CORSMiddleware

from app.api.main import init_api_routes
from app.core.config import settings
from app.core.logging import setup_logging


def custom_generate_unique_id(route: APIRoute) -> str:
    """
    Generate a unique ID for API routes.
    
    Args:
        route: API route
        
    Returns:
        Unique ID for the route
    """
    if route.tags:
        return f"{route.tags[0]}-{route.name}"
    return route.name


def create_application() -> FastAPI:
    """
    Create and configure the FastAPI application.
    
    Returns:
        Configured FastAPI application
    """
    # Initialize Sentry if configured and not in local environment
    if settings.SENTRY_DSN and settings.ENVIRONMENT != "local":
        sentry_sdk.init(dsn=str(settings.SENTRY_DSN), enable_tracing=True)
    
    # Create application
    application = FastAPI(
        title=settings.PROJECT_NAME,
        openapi_url=f"{settings.API_V1_STR}/openapi.json",
        generate_unique_id_function=custom_generate_unique_id,
    )
    
    # Set up logging
    setup_logging(application)
    
    # Set all CORS enabled origins
    if settings.all_cors_origins:
        application.add_middleware(
            CORSMiddleware,
            allow_origins=settings.all_cors_origins,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    # Initialize API routes
    init_api_routes(application)
    
    return application


# Create the application instance
app = create_application()

================
File: backend/scripts/run_blackbox_tests.sh
================
#!/bin/bash
# Script to run blackbox tests with a real server and generate a report

set -e  # Exit on error

# Check if we are in the backend directory
if [[ ! -d ./app ]]; then
    echo "Error: This script must be run from the backend directory."
    exit 1
fi

# Create test reports directory if it doesn't exist
mkdir -p test-reports

# Function to check if the server is already running
check_server() {
    curl -s http://localhost:8000/docs > /dev/null
    return $?
}

# Variables for server management
SERVER_HOST="localhost"
SERVER_PORT="8000"
SERVER_PID=""
SERVER_LOG="test-reports/server.log"
STARTED_SERVER=false

# Function to start the server if it's not already running
start_server() {
    if check_server; then
        echo " Server already running at http://${SERVER_HOST}:${SERVER_PORT}"
        return 0
    fi

    echo "Starting FastAPI server for tests..."
    python -m uvicorn app.main:app --host ${SERVER_HOST} --port ${SERVER_PORT} > $SERVER_LOG 2>&1 &
    SERVER_PID=$!
    STARTED_SERVER=true
    
    # Wait for the server to be ready
    MAX_RETRIES=30
    RETRY=0
    while [ $RETRY -lt $MAX_RETRIES ]; do
        if curl -s http://${SERVER_HOST}:${SERVER_PORT}/docs > /dev/null; then
            echo " Server started successfully at http://${SERVER_HOST}:${SERVER_PORT}"
            # Give the server a bit more time to fully initialize
            sleep 1
            return 0
        fi
        
        echo "Waiting for server to start... ($RETRY/$MAX_RETRIES)"
        sleep 1
        RETRY=$((RETRY+1))
    done
    
    echo " Failed to start server after $MAX_RETRIES attempts."
    if [ -n "$SERVER_PID" ]; then
        kill $SERVER_PID 2>/dev/null || true
    fi
    exit 1
}

# Function to stop the server if we started it
stop_server() {
    if [ "$STARTED_SERVER" = true ] && [ -n "$SERVER_PID" ]; then
        echo "Stopping FastAPI server (PID: $SERVER_PID)..."
        kill $SERVER_PID 2>/dev/null || true
        wait $SERVER_PID 2>/dev/null || true
        echo " Server stopped"
    else
        echo " Leaving external server running"
    fi
}

# Set up a trap to stop the server when the script exits
trap stop_server EXIT

# Start the server
start_server

# Export server URL for tests
export TEST_SERVER_URL="http://${SERVER_HOST}:${SERVER_PORT}"
export TEST_REQUEST_TIMEOUT=5.0  # Shorter timeout for tests

# Run the blackbox tests with the specified server
echo "Running blackbox tests against server at ${TEST_SERVER_URL}..."

# Basic tests first to verify infrastructure
echo "Running basic infrastructure tests..."
cd app/tests/api/blackbox
PYTHONPATH=../../../.. python -m pytest test_basic.py -v --no-header --junitxml=../../../../test-reports/blackbox-basic-results.xml

# If basic tests pass, run the complete test suite
if [ $? -eq 0 ]; then
    echo "Running all blackbox tests..."
    PYTHONPATH=../../../.. python -m pytest -v --no-header --junitxml=../../../../test-reports/blackbox-results.xml
fi

cd ../../../../

# Check the exit code
TEST_EXIT_CODE=$?
if [ $TEST_EXIT_CODE -eq 0 ]; then
    echo " All blackbox tests passed!"
else
    echo " Some blackbox tests failed."
fi

# Generate HTML report if pytest-html is installed
if python -c "import pytest_html" &> /dev/null; then
    echo "Generating HTML report..."
    cd app/tests/api/blackbox
    PYTHONPATH=../../../.. TEST_SERVER_URL=${TEST_SERVER_URL} python -m pytest --no-header -v --html=../../../../test-reports/blackbox-report.html
    cd ../../../../
else
    echo "pytest-html not found. Install with 'uv add pytest-html' to generate HTML reports."
fi

echo "Blackbox tests completed. Results available in test-reports directory."
exit $TEST_EXIT_CODE

================
File: backend/.gitignore
================
__pycache__
app.egg-info
*.pyc
.mypy_cache
.coverage
htmlcov
.cache
.venv
test-reports/

================
File: backend/BLACKBOX_TESTS.md
================
# Blackbox Testing Strategy for Modular Monolith Refactoring

This document outlines a comprehensive blackbox testing approach to ensure that the behavior of the FastAPI backend remains consistent before and after the modular monolith refactoring.

## Current Implementation Status

** New implementation complete!** We have now set up the following:

- A fully external HTTP-based testing approach using httpx
- Tests run against a real running server without TestClient
- No direct database manipulation in tests
- Helper utilities for interacting with the API
- Proper server lifecycle management during tests
- Clean separation of API testing from implementation details

This is a significant improvement over the previous implementation, which used:
- TestClient (FastAPI's built-in testing client)
- Direct access to the database
- Knowledge of internal implementation details

## Test Principles

1. **True Blackbox Testing**: Tests interact with the API solely through HTTP requests, just like any external client would
2. **No Implementation Knowledge**: Tests have no knowledge of internal implementation details
3. **Stateless Tests**: Tests do not rely on database state between tests
4. **Independent Execution**: Tests can run against any server instance (local, Docker, remote)
5. **Before/After Validation**: Tests can be run before and after each refactoring phase

## Test Implementation

### Test Infrastructure

The blackbox tests use the following components:

1. **httpx**: A modern HTTP client for Python
2. **pytest**: The testing framework for organizing and running tests
3. **BlackboxClient**: A custom client that wraps httpx with API-specific helpers
4. **Test utilities**: Helper functions for common operations and assertions

### Running Tests

Tests can be run using the included run_blackbox_tests.sh script:

```bash
cd backend
bash scripts/run_blackbox_tests.sh
```

The script:
1. Starts a FastAPI server if one is not already running
2. Runs the tests against the running server
3. Generates test reports
4. Stops the server if it was started by the script

### Client Utilities

The BlackboxClient provides an interface for interacting with the API:

```python
# Create a client
client = BlackboxClient()

# Create a user
signup_response, user_data = client.sign_up(
    email="test@example.com",
    password="testpassword123",
    full_name="Test User"
)

# Login to get a token
login_response = client.login("test@example.com", "testpassword123")

# The token is automatically stored and used in subsequent requests
user_profile = client.get("/api/v1/users/me")

# Create an item
item_response = client.create_item("Test Item", "Test Description")
item_id = item_response.json()["id"]

# Update an item
update_response = client.put(f"/api/v1/items/{item_id}", json_data={
    "title": "Updated Item"
})

# Delete an item
client.delete(f"/api/v1/items/{item_id}")
```

## Test Categories

### API Contract Tests

Verify that API endpoints adhere to their expected contracts:
- Response schemas
- Status codes
- Validation rules

```python
def test_user_signup_contract(client):
    # Test user signup returns the expected response structure
    response, _ = client.sign_up(
        email=f"test-{uuid.uuid4()}@example.com",
        password="testpassword123",
        full_name="Test User"
    )
    
    result = response.json()
    verify_user_object(result)  # Check schema fields exist
    
    # Verify validation errors
    invalid_response, _ = client.sign_up(email="not-an-email", password="testpassword123")
    assert_validation_error(invalid_response)
```

### User Lifecycle Tests

Verify complete end-to-end user flows:

```python
def test_complete_user_lifecycle(client):
    # Create a user
    signup_response, credentials = client.sign_up()
    
    # Login
    client.login(credentials["email"], credentials["password"])
    
    # Create an item
    item_response = client.create_item("Test Item")
    item_id = item_response.json()["id"]
    
    # Update the item
    client.put(f"/api/v1/items/{item_id}", json_data={"title": "Updated Item"})
    
    # Delete the item
    client.delete(f"/api/v1/items/{item_id}")
    
    # Delete the user
    client.delete("/api/v1/users/me")
    
    # Verify user is deleted by trying to login again
    new_client = BlackboxClient()
    login_response = new_client.login(credentials["email"], credentials["password"])
    assert login_response.status_code != 200
```

### Authorization Tests

Verify that authorization rules are enforced:

```python
def test_resource_ownership_protection(client):
    # Create two users
    user1_client = BlackboxClient()
    user1_client.create_and_login_user()
    
    user2_client = BlackboxClient()
    user2_client.create_and_login_user()
    
    # User1 creates an item
    item_response = user1_client.create_item("User1 Item")
    item_id = item_response.json()["id"]
    
    # User2 attempts to access User1's item
    user2_get_response = user2_client.get(f"/api/v1/items/{item_id}")
    assert user2_get_response.status_code == 404, "User2 should not see User1's item"
```

## Test Execution Plan

### Pre-Refactoring Phase

1. Run the complete test suite against the current architecture
2. Establish a baseline of expected responses and behaviors
3. Create a test report documenting the current behavior

### During Refactoring Phase

1. After each module refactoring, run the relevant subset of tests
2. Verify that the refactored module maintains the same external behavior
3. Document any differences or issues encountered

### Post-Refactoring Phase

1. Run the complete test suite against the fully refactored architecture
2. Compare results with the pre-refactoring baseline
3. Verify all tests pass with the same results as before refactoring
4. Create a final test report documenting the comparison

## Dependencies and Setup

The tests require the following:

1. httpx: `pip install httpx`
2. pytest: `pip install pytest`
3. A running FastAPI server (started automatically by the test script if not running)
4. The superuser credentials in environment variables (for admin tests)

## Continuous Integration Integration

Add the blackbox tests to the CI/CD pipeline to ensure they run on every pull request:

```yaml
# .github/workflows/backend-tests.yml (example)
name: Backend Tests

jobs:
  blackbox-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: app_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        cd backend
        pip install -e .
        pip install pytest pytest-html httpx
        
    - name: Run blackbox tests
      run: |
        cd backend
        bash scripts/run_blackbox_tests.sh
        
    - name: Upload test results
      uses: actions/upload-artifact@v3
      with:
        name: test-reports
        path: backend/test-reports/
```

## Conclusion

This blackbox testing strategy ensures that the external behavior of the API remains consistent throughout the refactoring process. By focusing exclusively on HTTP interactions without any knowledge of implementation details, these tests provide the most reliable validation that the refactoring does not introduce changes in behavior from an external client's perspective.

================
File: backend/Dockerfile
================
FROM python:3.10

ENV PYTHONUNBUFFERED=1

WORKDIR /app/

# Install uv
# Ref: https://docs.astral.sh/uv/guides/integration/docker/#installing-uv
COPY --from=ghcr.io/astral-sh/uv:0.5.11 /uv /uvx /bin/

# Place executables in the environment at the front of the path
# Ref: https://docs.astral.sh/uv/guides/integration/docker/#using-the-environment
ENV PATH="/app/.venv/bin:$PATH"

# Compile bytecode
# Ref: https://docs.astral.sh/uv/guides/integration/docker/#compiling-bytecode
ENV UV_COMPILE_BYTECODE=1

# uv Cache
# Ref: https://docs.astral.sh/uv/guides/integration/docker/#caching
ENV UV_LINK_MODE=copy

# Install dependencies
# Ref: https://docs.astral.sh/uv/guides/integration/docker/#intermediate-layers
RUN --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    uv sync --frozen --no-install-project

ENV PYTHONPATH=/app

COPY ./scripts /app/scripts

COPY ./pyproject.toml ./uv.lock ./alembic.ini /app/

COPY ./app /app/app

# Sync the project
# Ref: https://docs.astral.sh/uv/guides/integration/docker/#intermediate-layers
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync

CMD ["fastapi", "run", "--workers", "4", "app/main.py"]

================
File: docker-compose.yml
================
services:

  db:
    image: postgres:17
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 10s
    volumes:
      - app-db-data:/var/lib/postgresql/data/pgdata
    env_file:
      - .env
    environment:
      - PGDATA=/var/lib/postgresql/data/pgdata
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD?Variable not set}
      - POSTGRES_USER=${POSTGRES_USER?Variable not set}
      - POSTGRES_DB=${POSTGRES_DB?Variable not set}

  adminer:
    image: adminer
    restart: always
    networks:
      - traefik-public
      - default
    depends_on:
      - db
    environment:
      - ADMINER_DESIGN=pepa-linha-dark
    labels:
      - traefik.enable=true
      - traefik.docker.network=traefik-public
      - traefik.constraint-label=traefik-public
      - traefik.http.routers.${STACK_NAME?Variable not set}-adminer-http.rule=Host(`adminer.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-adminer-http.entrypoints=http
      - traefik.http.routers.${STACK_NAME?Variable not set}-adminer-http.middlewares=https-redirect
      - traefik.http.routers.${STACK_NAME?Variable not set}-adminer-https.rule=Host(`adminer.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-adminer-https.entrypoints=https
      - traefik.http.routers.${STACK_NAME?Variable not set}-adminer-https.tls=true
      - traefik.http.routers.${STACK_NAME?Variable not set}-adminer-https.tls.certresolver=le
      - traefik.http.services.${STACK_NAME?Variable not set}-adminer.loadbalancer.server.port=8080

  prestart:
    image: '${DOCKER_IMAGE_BACKEND?Variable not set}:${TAG-latest}'
    build:
      context: ./backend
    networks:
      - traefik-public
      - default
    depends_on:
      db:
        condition: service_healthy
        restart: true
    command: bash scripts/prestart.sh
    env_file:
      - .env
    environment:
      - DOMAIN=${DOMAIN}
      - FRONTEND_HOST=${FRONTEND_HOST?Variable not set}
      - ENVIRONMENT=${ENVIRONMENT}
      - BACKEND_CORS_ORIGINS=${BACKEND_CORS_ORIGINS}
      - SECRET_KEY=${SECRET_KEY?Variable not set}
      - FIRST_SUPERUSER=${FIRST_SUPERUSER?Variable not set}
      - FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD?Variable not set}
      - SMTP_HOST=${SMTP_HOST}
      - SMTP_USER=${SMTP_USER}
      - SMTP_PASSWORD=${SMTP_PASSWORD}
      - EMAILS_FROM_EMAIL=${EMAILS_FROM_EMAIL}
      - POSTGRES_SERVER=db
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER?Variable not set}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD?Variable not set}
      - SENTRY_DSN=${SENTRY_DSN}

  backend:
    image: '${DOCKER_IMAGE_BACKEND?Variable not set}:${TAG-latest}'
    restart: always
    networks:
      - traefik-public
      - default
    depends_on:
      db:
        condition: service_healthy
        restart: true
      prestart:
        condition: service_completed_successfully
    env_file:
      - .env
    environment:
      - DOMAIN=${DOMAIN}
      - FRONTEND_HOST=${FRONTEND_HOST?Variable not set}
      - ENVIRONMENT=${ENVIRONMENT}
      - BACKEND_CORS_ORIGINS=${BACKEND_CORS_ORIGINS}
      - SECRET_KEY=${SECRET_KEY?Variable not set}
      - FIRST_SUPERUSER=${FIRST_SUPERUSER?Variable not set}
      - FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD?Variable not set}
      - SMTP_HOST=${SMTP_HOST}
      - SMTP_USER=${SMTP_USER}
      - SMTP_PASSWORD=${SMTP_PASSWORD}
      - EMAILS_FROM_EMAIL=${EMAILS_FROM_EMAIL}
      - POSTGRES_SERVER=db
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER?Variable not set}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD?Variable not set}
      - SENTRY_DSN=${SENTRY_DSN}

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/v1/utils/health-check/"]
      interval: 10s
      timeout: 5s
      retries: 5

    build:
      context: ./backend
    labels:
      - traefik.enable=true
      - traefik.docker.network=traefik-public
      - traefik.constraint-label=traefik-public

      - traefik.http.services.${STACK_NAME?Variable not set}-backend.loadbalancer.server.port=8000

      - traefik.http.routers.${STACK_NAME?Variable not set}-backend-http.rule=Host(`api.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-backend-http.entrypoints=http

      - traefik.http.routers.${STACK_NAME?Variable not set}-backend-https.rule=Host(`api.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-backend-https.entrypoints=https
      - traefik.http.routers.${STACK_NAME?Variable not set}-backend-https.tls=true
      - traefik.http.routers.${STACK_NAME?Variable not set}-backend-https.tls.certresolver=le

      # Enable redirection for HTTP and HTTPS
      - traefik.http.routers.${STACK_NAME?Variable not set}-backend-http.middlewares=https-redirect

  frontend:
    image: '${DOCKER_IMAGE_FRONTEND?Variable not set}:${TAG-latest}'
    restart: always
    networks:
      - traefik-public
      - default
    build:
      context: ./frontend
      args:
        - VITE_API_URL=https://api.${DOMAIN?Variable not set}
        - NODE_ENV=production
    labels:
      - traefik.enable=true
      - traefik.docker.network=traefik-public
      - traefik.constraint-label=traefik-public

      - traefik.http.services.${STACK_NAME?Variable not set}-frontend.loadbalancer.server.port=80

      - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-http.rule=Host(`dashboard.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-http.entrypoints=http

      - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.rule=Host(`dashboard.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.entrypoints=https
      - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.tls=true
      - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-https.tls.certresolver=le

      # Enable redirection for HTTP and HTTPS
      - traefik.http.routers.${STACK_NAME?Variable not set}-frontend-http.middlewares=https-redirect
volumes:
  app-db-data:

networks:
  traefik-public:
    # Allow setting it to false for testing
    external: true

================
File: README.md
================
# Full Stack FastAPI Template

<a href="https://github.com/fastapi/full-stack-fastapi-template/actions?query=workflow%3ATest" target="_blank"><img src="https://github.com/fastapi/full-stack-fastapi-template/workflows/Test/badge.svg" alt="Test"></a>
<a href="https://coverage-badge.samuelcolvin.workers.dev/redirect/fastapi/full-stack-fastapi-template" target="_blank"><img src="https://coverage-badge.samuelcolvin.workers.dev/fastapi/full-stack-fastapi-template.svg" alt="Coverage"></a>

## Technology Stack and Features

-  [**FastAPI**](https://fastapi.tiangolo.com) for the Python backend API.
    -  [SQLModel](https://sqlmodel.tiangolo.com) for the Python SQL database interactions (ORM).
    -  [Pydantic](https://docs.pydantic.dev), used by FastAPI, for the data validation and settings management.
    -  [PostgreSQL](https://www.postgresql.org) as the SQL database.
-  [React](https://react.dev) for the frontend.
    -  Using TypeScript, hooks, Vite, and other parts of a modern frontend stack.
    -  [Chakra UI](https://chakra-ui.com) for the frontend components.
    -  An automatically generated frontend client.
    -  [Playwright](https://playwright.dev) for End-to-End testing.
    -  Dark mode support.
-  [Docker Compose](https://www.docker.com) for development and production.
-  Secure password hashing by default.
-  JWT (JSON Web Token) authentication.
-  Email based password recovery.
-  Tests with [Pytest](https://pytest.org).
-  [Traefik](https://traefik.io) as a reverse proxy / load balancer.
-  Deployment instructions using Docker Compose, including how to set up a frontend Traefik proxy to handle automatic HTTPS certificates.
-  CI (continuous integration) and CD (continuous deployment) based on GitHub Actions.

### Dashboard Login

[![API docs](img/login.png)](https://github.com/fastapi/full-stack-fastapi-template)

### Dashboard - Admin

[![API docs](img/dashboard.png)](https://github.com/fastapi/full-stack-fastapi-template)

### Dashboard - Create User

[![API docs](img/dashboard-create.png)](https://github.com/fastapi/full-stack-fastapi-template)

### Dashboard - Items

[![API docs](img/dashboard-items.png)](https://github.com/fastapi/full-stack-fastapi-template)

### Dashboard - User Settings

[![API docs](img/dashboard-user-settings.png)](https://github.com/fastapi/full-stack-fastapi-template)

### Dashboard - Dark Mode

[![API docs](img/dashboard-dark.png)](https://github.com/fastapi/full-stack-fastapi-template)

### Interactive API Documentation

[![API docs](img/docs.png)](https://github.com/fastapi/full-stack-fastapi-template)

## How To Use It

You can **just fork or clone** this repository and use it as is.

 It just works. 

### How to Use a Private Repository

If you want to have a private repository, GitHub won't allow you to simply fork it as it doesn't allow changing the visibility of forks.

But you can do the following:

- Create a new GitHub repo, for example `my-full-stack`.
- Clone this repository manually, set the name with the name of the project you want to use, for example `my-full-stack`:

```bash
git clone git@github.com:fastapi/full-stack-fastapi-template.git my-full-stack
```

- Enter into the new directory:

```bash
cd my-full-stack
```

- Set the new origin to your new repository, copy it from the GitHub interface, for example:

```bash
git remote set-url origin git@github.com:octocat/my-full-stack.git
```

- Add this repo as another "remote" to allow you to get updates later:

```bash
git remote add upstream git@github.com:fastapi/full-stack-fastapi-template.git
```

- Push the code to your new repository:

```bash
git push -u origin master
```

### Update From the Original Template

After cloning the repository, and after doing changes, you might want to get the latest changes from this original template.

- Make sure you added the original repository as a remote, you can check it with:

```bash
git remote -v

origin    git@github.com:octocat/my-full-stack.git (fetch)
origin    git@github.com:octocat/my-full-stack.git (push)
upstream    git@github.com:fastapi/full-stack-fastapi-template.git (fetch)
upstream    git@github.com:fastapi/full-stack-fastapi-template.git (push)
```

- Pull the latest changes without merging:

```bash
git pull --no-commit upstream master
```

This will download the latest changes from this template without committing them, that way you can check everything is right before committing.

- If there are conflicts, solve them in your editor.

- Once you are done, commit the changes:

```bash
git merge --continue
```

### Configure

You can then update configs in the `.env` files to customize your configurations.

Before deploying it, make sure you change at least the values for:

- `SECRET_KEY`
- `FIRST_SUPERUSER_PASSWORD`
- `POSTGRES_PASSWORD`

You can (and should) pass these as environment variables from secrets.

Read the [deployment.md](./deployment.md) docs for more details.

### Generate Secret Keys

Some environment variables in the `.env` file have a default value of `changethis`.

You have to change them with a secret key, to generate secret keys you can run the following command:

```bash
python -c "import secrets; print(secrets.token_urlsafe(32))"
```

Copy the content and use that as password / secret key. And run that again to generate another secure key.


## Backend Development

Backend docs: [backend/README.md](./backend/README.md).

## Frontend Development

Frontend docs: [frontend/README.md](./frontend/README.md).

## Deployment

Deployment docs: [deployment.md](./deployment.md).

## Development

General development docs: [development.md](./development.md).

This includes using Docker Compose, custom local domains, `.env` configurations, etc.

## Release Notes

Check the file [release-notes.md](./release-notes.md).

## License

The Full Stack FastAPI Template is licensed under the terms of the MIT license.

================
File: backend/app/alembic/env.py
================
"""
Alembic environment configuration.

This module configures the Alembic environment for database migrations.
"""
import os
from logging.config import fileConfig

from alembic import context
from sqlalchemy import engine_from_config, pool
from sqlmodel import SQLModel

# Alembic Config object
config = context.config

# Interpret the config file for Python logging
fileConfig(config.config_file_name)

# Import models from all modules for Alembic to detect schema changes
from app.core.config import settings  # noqa: E402
from app.core.logging import get_logger  # noqa: E402

# Import all models
# Import table models from their respective modules
from app.modules.items.domain.models import Item  # noqa: F401
from app.modules.users.domain.models import User  # noqa: F401

# Import models from modules
# These imports are for non-table models that have been migrated to modules
# They don't create duplicate table definitions since they don't use table=True

# Auth module models (non-table models only)
from app.modules.auth.domain.models import (  # noqa: F401
    LoginRequest,
    NewPassword,
    PasswordReset,
    RefreshToken,
    Token,
    TokenPayload,
)

# Users module models (non-table models only, not the User table model)
from app.modules.users.domain.models import (  # noqa: F401
    UpdatePassword,
    UserCreate,
    UserPublic,
    UserRegister,
    UserUpdate,
    UserUpdateMe,
    UsersPublic,
)

# Items module models (non-table models only, not the Item table model)
from app.modules.items.domain.models import (  # noqa: F401
    ItemCreate,
    ItemPublic,
    ItemsPublic,
    ItemUpdate,
)

# Email module models
from app.modules.email.domain.models import *  # noqa: F403, F401

# Shared models
from app.shared.models import Message  # noqa: F401

# Set up target metadata
target_metadata = SQLModel.metadata

# Initialize logger
logger = get_logger("alembic")


def get_url() -> str:
    """
    Get database URL from settings.

    Returns:
        Database URL string
    """
    return str(settings.SQLALCHEMY_DATABASE_URI)


def run_migrations_offline() -> None:
    """
    Run migrations in 'offline' mode.

    This configures the context with just a URL and not an Engine,
    though an Engine is acceptable here as well. By skipping the Engine
    creation we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = get_url()
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        compare_type=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """
    Run migrations in 'online' mode.

    In this scenario we need to create an Engine and associate
    a connection with the context.
    """
    configuration = config.get_section(config.config_ini_section)
    configuration["sqlalchemy.url"] = get_url()
    connectable = engine_from_config(
        configuration,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True
        )

        with context.begin_transaction():
            context.run_migrations()


# Run migrations based on mode
if context.is_offline_mode():
    logger.info("Running migrations in offline mode")
    run_migrations_offline()
else:
    logger.info("Running migrations in online mode")
    run_migrations_online()

================
File: backend/app/core/config.py
================
"""
Application configuration.

This module provides a centralized configuration system for the application,
organized by feature modules.
"""
import logging
import secrets
import warnings
from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import (
    AnyUrl,
    BeforeValidator,
    EmailStr,
    HttpUrl,
    PostgresDsn,
    computed_field,
    model_validator,
)
from pydantic_core import MultiHostUrl
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing_extensions import Self


def parse_cors(v: Any) -> List[str] | str:
    """Parse CORS settings from string to list."""
    if isinstance(v, str) and not v.startswith("["):
        return [i.strip() for i in v.split(",")]
    elif isinstance(v, list | str):
        return v
    raise ValueError(v)


class DatabaseSettings(BaseSettings):
    """Database-specific settings."""
    
    POSTGRES_SERVER: str
    POSTGRES_PORT: int = 5432
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str = ""
    POSTGRES_DB: str = ""

    @computed_field
    @property
    def SQLALCHEMY_DATABASE_URI(self) -> PostgresDsn:
        """Build the database URI."""
        return MultiHostUrl.build(
            scheme="postgresql+psycopg",
            username=self.POSTGRES_USER,
            password=self.POSTGRES_PASSWORD,
            host=self.POSTGRES_SERVER,
            port=self.POSTGRES_PORT,
            path=self.POSTGRES_DB,
        )


class SecuritySettings(BaseSettings):
    """Security-specific settings."""
    
    SECRET_KEY: str = secrets.token_urlsafe(32)
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8  # 8 days
    
    # Superuser account for initialization
    FIRST_SUPERUSER: EmailStr
    FIRST_SUPERUSER_PASSWORD: str


class EmailSettings(BaseSettings):
    """Email-specific settings."""
    
    SMTP_TLS: bool = True
    SMTP_SSL: bool = False
    SMTP_PORT: int = 587
    SMTP_HOST: Optional[str] = None
    SMTP_USER: Optional[str] = None
    SMTP_PASSWORD: Optional[str] = None
    EMAILS_FROM_EMAIL: Optional[EmailStr] = None
    EMAILS_FROM_NAME: Optional[str] = None
    EMAIL_RESET_TOKEN_EXPIRE_HOURS: int = 48
    EMAIL_TEST_USER: EmailStr = "test@example.com"

    @computed_field
    @property
    def emails_enabled(self) -> bool:
        """Check if email functionality is enabled."""
        return bool(self.SMTP_HOST and self.EMAILS_FROM_EMAIL)


class ApplicationSettings(BaseSettings):
    """Application-wide settings."""
    
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str
    ENVIRONMENT: Literal["local", "staging", "production"] = "local"
    LOG_LEVEL: str = "INFO"
    FRONTEND_HOST: str = "http://localhost:5173"
    SENTRY_DSN: Optional[HttpUrl] = None
    
    BACKEND_CORS_ORIGINS: Annotated[
        List[AnyUrl] | str, BeforeValidator(parse_cors)
    ] = []

    @computed_field
    @property
    def all_cors_origins(self) -> List[str]:
        """Get all allowed CORS origins including frontend host."""
        origins = [str(origin).rstrip("/") for origin in self.BACKEND_CORS_ORIGINS]
        if self.FRONTEND_HOST not in origins:
            origins.append(self.FRONTEND_HOST)
        return origins


class Settings(ApplicationSettings, SecuritySettings, DatabaseSettings, EmailSettings):
    """
    Combined settings from all modules.
    
    This class combines settings from all feature modules and provides
    validation methods.
    """
    
    model_config = SettingsConfigDict(
        # Use top level .env file (one level above ./backend/)
        env_file="../.env",
        env_ignore_empty=True,
        extra="ignore",
    )

    @model_validator(mode="after")
    def _set_default_emails_from(self) -> Self:
        """Set default email sender name if not provided."""
        if not self.EMAILS_FROM_NAME:
            self.EMAILS_FROM_NAME = self.PROJECT_NAME
        return self

    def _check_default_secret(self, var_name: str, value: str | None) -> None:
        """Check if a secret value is still set to default."""
        if value == "changethis":
            message = (
                f'The value of {var_name} is "changethis", '
                "for security, please change it, at least for deployments."
            )
            if self.ENVIRONMENT == "local":
                warnings.warn(message, stacklevel=1)
            else:
                raise ValueError(message)

    @model_validator(mode="after")
    def _enforce_non_default_secrets(self) -> Self:
        """Enforce that secrets are not left at default values."""
        self._check_default_secret("SECRET_KEY", self.SECRET_KEY)
        self._check_default_secret("POSTGRES_PASSWORD", self.POSTGRES_PASSWORD)
        self._check_default_secret(
            "FIRST_SUPERUSER_PASSWORD", self.FIRST_SUPERUSER_PASSWORD
        )
        return self
    
    def get_module_settings(self, module_name: str) -> Dict[str, Any]:
        """
        Get settings for a specific module.
        
        This method allows modules to access only the settings relevant to them.
        
        Args:
            module_name: Name of the module
            
        Returns:
            Dictionary of module-specific settings
        """
        if module_name == "auth":
            # Auth module settings
            return {
                "secret_key": self.SECRET_KEY,
                "access_token_expire_minutes": self.ACCESS_TOKEN_EXPIRE_MINUTES,
            }
        elif module_name == "email":
            # Email module settings
            return {
                "smtp_tls": self.SMTP_TLS,
                "smtp_ssl": self.SMTP_SSL,
                "smtp_port": self.SMTP_PORT,
                "smtp_host": self.SMTP_HOST,
                "smtp_user": self.SMTP_USER,
                "smtp_password": self.SMTP_PASSWORD,
                "emails_from_email": self.EMAILS_FROM_EMAIL,
                "emails_from_name": self.EMAILS_FROM_NAME,
                "email_reset_token_expire_hours": self.EMAIL_RESET_TOKEN_EXPIRE_HOURS,
                "emails_enabled": self.emails_enabled,
            }
        elif module_name == "users":
            # Users module settings
            return {
                "first_superuser": self.FIRST_SUPERUSER,
                "first_superuser_password": self.FIRST_SUPERUSER_PASSWORD,
            }
        
        # Default to returning empty dict for unknown modules
        return {}


# Initialize settings
settings = Settings()

================
File: backend/app/core/db.py
================
"""
Database setup and utilities.

This module provides database setup, connection management, and helper utilities
for interacting with the database.
"""
from contextlib import contextmanager
from typing import Any, Callable, Dict, Generator, Type, TypeVar

from fastapi import Depends
from sqlmodel import Session, SQLModel, create_engine, select
from sqlmodel.sql.expression import SelectOfScalar

# Set up SQLModel for better query performance
# This prevents SQLModel from overriding SQLAlchemy's select() with a version
# that doesn't use caching. See: https://github.com/tiangolo/sqlmodel/issues/189
SelectOfScalar.inherit_cache = True

from app.core.config import settings
from app.core.logging import get_logger

# Configure logger
logger = get_logger("db")

# Database engine
engine = create_engine(
    str(settings.SQLALCHEMY_DATABASE_URI),
    pool_pre_ping=True,
    echo=settings.ENVIRONMENT == "local",
)

# Type variables for repository pattern
T = TypeVar('T')
ModelType = TypeVar('ModelType', bound=SQLModel)
CreateSchemaType = TypeVar('CreateSchemaType', bound=SQLModel)
UpdateSchemaType = TypeVar('UpdateSchemaType', bound=SQLModel)


def get_session() -> Generator[Session, None, None]:
    """
    Get a database session.
    
    This function yields a database session that is automatically closed
    when the caller is done with it.
    
    Yields:
        SQLModel Session object
    """
    with Session(engine) as session:
        try:
            yield session
        except Exception as e:
            logger.exception(f"Database session error: {e}")
            session.rollback()
            raise
        finally:
            session.close()


@contextmanager
def session_manager() -> Generator[Session, None, None]:
    """
    Context manager for database sessions.
    
    This context manager provides a database session that is automatically
    committed or rolled back based on whether an exception is raised.
    
    Yields:
        SQLModel Session object
    """
    with Session(engine) as session:
        try:
            yield session
            session.commit()
        except Exception as e:
            logger.exception(f"Database error: {e}")
            session.rollback()
            raise
        finally:
            session.close()


class BaseRepository:
    """
    Base repository for database operations.
    
    This class provides a base implementation of common database operations
    that can be inherited by module-specific repositories.
    """
    
    def __init__(self, session: Session):
        """
        Initialize the repository with a database session.
        
        Args:
            session: SQLModel Session object
        """
        self.session = session
    
    def get(self, model: Type[ModelType], id: Any) -> ModelType | None:
        """
        Get a model instance by ID.
        
        Args:
            model: SQLModel model class
            id: Primary key value
            
        Returns:
            Model instance if found, None otherwise
        """
        return self.session.get(model, id)
    
    def get_multi(
        self, 
        model: Type[ModelType], 
        *, 
        skip: int = 0, 
        limit: int = 100
    ) -> list[ModelType]:
        """
        Get multiple model instances with pagination.
        
        Args:
            model: SQLModel model class
            skip: Number of records to skip
            limit: Maximum number of records to return
            
        Returns:
            List of model instances
        """
        statement = select(model).offset(skip).limit(limit)
        return list(self.session.exec(statement))
    
    def create(self, model_instance: ModelType) -> ModelType:
        """
        Create a new record in the database.
        
        Args:
            model_instance: Instance of a SQLModel model
            
        Returns:
            Created model instance with ID populated
        """
        self.session.add(model_instance)
        self.session.commit()
        self.session.refresh(model_instance)
        return model_instance
    
    def update(self, model_instance: ModelType) -> ModelType:
        """
        Update an existing record in the database.
        
        Args:
            model_instance: Instance of a SQLModel model
            
        Returns:
            Updated model instance
        """
        self.session.add(model_instance)
        self.session.commit()
        self.session.refresh(model_instance)
        return model_instance
    
    def delete(self, model_instance: ModelType) -> None:
        """
        Delete a record from the database.
        
        Args:
            model_instance: Instance of a SQLModel model
        """
        self.session.delete(model_instance)
        self.session.commit()


# Dependency to inject a repository into a route
def get_repository(repo_class: Type[T]) -> Callable[[Session], T]:
    """
    Factory function for repository injection.
    
    This function creates a dependency that injects a repository instance
    into a route function.
    
    Args:
        repo_class: Repository class to instantiate
        
    Returns:
        Dependency function
    """
    def _get_repo(session: Session = Depends(get_session)) -> T:
        return repo_class(session)
    return _get_repo


# Reusable dependency for a database session
SessionDep = Depends(get_session)


def init_db(session: Session) -> None:
    """
    Initialize database with required data.
    
    During the modular transition, we're delegating this to the users module
    to create the initial superuser. In the future, this will be a coordinated
    initialization process for all modules.
    
    Args:
        session: Database session
    """
    # Import here to avoid circular imports
    from app.modules.users.repository.user_repo import UserRepository
    from app.modules.users.services.user_service import UserService
    
    # Initialize user data (create superuser)
    user_repo = UserRepository(session)
    user_service = UserService(user_repo)
    user_service.create_initial_superuser()
    
    logger.info("Database initialized with initial data")

================
File: backend/app/modules/auth/api/routes.py
================
"""
Auth routes.

This module provides API routes for authentication operations.
"""
from typing import Any

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import HTMLResponse
from fastapi.security import OAuth2PasswordRequestForm

from app.api.deps import CurrentSuperuser, CurrentUser
from app.core.config import settings
from app.core.logging import get_logger
from app.modules.users.domain.models import UserPublic
from app.shared.models import Message  # Using shared Message model
from app.modules.auth.dependencies import get_auth_service
from app.modules.auth.domain.models import NewPassword, PasswordReset, Token
from app.modules.auth.services.auth_service import AuthService
from app.shared.exceptions import AuthenticationException, NotFoundException

# Initialize logger
logger = get_logger("auth_routes")

# Create router
router = APIRouter(tags=["login"])


@router.post("/login/access-token")
def login_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    auth_service: AuthService = Depends(get_auth_service),
) -> Token:
    """
    OAuth2 compatible token login, get an access token for future requests.

    Args:
        form_data: OAuth2 form data
        auth_service: Auth service

    Returns:
        Token object
    """
    try:
        return auth_service.login(
            email=form_data.username, password=form_data.password
        )
    except AuthenticationException as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )


@router.post("/login/test-token", response_model=UserPublic)
def test_token(current_user: CurrentUser) -> Any:
    """
    Test access token endpoint.

    Args:
        current_user: Current authenticated user

    Returns:
        User object
    """
    return current_user


@router.post("/password-recovery")
def recover_password(
    body: PasswordReset,
    auth_service: AuthService = Depends(get_auth_service),
) -> Message:
    """
    Password recovery endpoint.

    Args:
        body: Password reset request
        auth_service: Auth service

    Returns:
        Message object
    """
    auth_service.request_password_reset(email=body.email)

    # Always return success to prevent email enumeration
    return Message(message="Password recovery email sent")


@router.post("/reset-password")
def reset_password(
    body: NewPassword,
    auth_service: AuthService = Depends(get_auth_service),
) -> Message:
    """
    Reset password endpoint.

    Args:
        body: New password data
        auth_service: Auth service

    Returns:
        Message object
    """
    try:
        auth_service.reset_password(token=body.token, new_password=body.new_password)
        return Message(message="Password updated successfully")
    except (AuthenticationException, NotFoundException) as e:
        raise HTTPException(
            status_code=e.status_code,
            detail=str(e),
        )


@router.post(
    "/password-recovery-html-content/{email}",
    dependencies=[Depends(CurrentSuperuser)],
    response_class=HTMLResponse,
)
def recover_password_html_content(
    email: str,
) -> Any:
    """
    HTML content for password recovery (for testing/debugging).

    This endpoint is only available to superusers and is intended for
    testing and debugging the password recovery email template.

    Args:
        email: User email
        auth_service: Auth service

    Returns:
        HTML content of password recovery email
    """
    from app.modules.email.dependencies import get_email_service
    from app.modules.email.domain.models import TemplateData, EmailTemplateType
    from app.core.security import generate_password_reset_token

    # Generate a dummy token for template preview
    token = generate_password_reset_token(email)

    # Get email service
    email_service = get_email_service()

    # Create template data
    template_data = TemplateData(
        template_type=EmailTemplateType.RESET_PASSWORD,
        context={
            "username": email,
            "valid_hours": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,
            "link": f"{settings.FRONTEND_HOST}/reset-password?token={token}",
        },
        email_to=email,
    )

    # Get template content
    template_content = email_service.get_template_content(template_data)

    return HTMLResponse(
        content=template_content.html_content,
        headers={"subject": template_content.subject},
    )

================
File: backend/app/modules/auth/services/auth_service.py
================
"""
Auth service.

This module provides business logic for authentication operations.
"""
from datetime import timedelta
from typing import Optional, Tuple

from fastapi import HTTPException, status
from pydantic import EmailStr

from app.core.config import settings
from app.core.logging import get_logger
from app.core.security import (
    create_access_token,
    get_password_hash,
    generate_password_reset_token,
    verify_password,
    verify_password_reset_token,
)
from app.modules.users.domain.models import User
from app.modules.auth.domain.models import Token
from app.modules.auth.repository.auth_repo import AuthRepository
from app.shared.exceptions import AuthenticationException, NotFoundException

# Configure logger
logger = get_logger("auth_service")


class AuthService:
    """
    Service for authentication operations.

    This class provides business logic for authentication operations.
    """

    def __init__(self, auth_repo: AuthRepository):
        """
        Initialize service with auth repository.

        Args:
            auth_repo: Auth repository
        """
        self.auth_repo = auth_repo

    def authenticate_user(self, email: str, password: str) -> Optional[User]:
        """
        Authenticate a user with email and password.

        Args:
            email: User email
            password: User password

        Returns:
            User if authentication is successful, None otherwise
        """
        user = self.auth_repo.get_user_by_email(email)

        if not user:
            return None

        if not verify_password(password, user.hashed_password):
            return None

        return user

    def create_access_token_for_user(
        self, user: User, expires_delta: Optional[timedelta] = None
    ) -> Token:
        """
        Create an access token for a user.

        Args:
            user: User to create token for
            expires_delta: Token expiration time

        Returns:
            Token object
        """
        if expires_delta is None:
            expires_delta = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

        access_token = create_access_token(
            subject=user.id, expires_delta=expires_delta
        )

        return Token(access_token=access_token, token_type="bearer")

    def login(self, email: str, password: str) -> Token:
        """
        Login a user and return an access token.

        Args:
            email: User email
            password: User password

        Returns:
            Token object

        Raises:
            AuthenticationException: If login fails
        """
        user = self.authenticate_user(email, password)

        if not user:
            logger.warning(f"Failed login attempt for email: {email}")
            raise AuthenticationException(message="Incorrect email or password")

        return self.create_access_token_for_user(user)

    def request_password_reset(self, email: EmailStr) -> bool:
        """
        Request a password reset.

        Args:
            email: User email

        Returns:
            True if request was successful, False if user not found
        """
        user = self.auth_repo.get_user_by_email(email)

        if not user:
            # Don't reveal that the user doesn't exist for security
            return False

        # Generate password reset token
        password_reset_token = generate_password_reset_token(email=email)

        # Event should be published here to notify email service to send password reset email
        # self.event_publisher.publish_event(
        #     PasswordResetRequested(
        #         email=email,
        #         token=password_reset_token
        #     )
        # )

        return True

    def reset_password(self, token: str, new_password: str) -> bool:
        """
        Reset a user's password using a reset token.

        Args:
            token: Password reset token
            new_password: New password

        Returns:
            True if reset was successful

        Raises:
            AuthenticationException: If token is invalid
            NotFoundException: If user not found
        """
        email = verify_password_reset_token(token)

        if not email:
            raise AuthenticationException(message="Invalid or expired token")

        user = self.auth_repo.get_user_by_email(email)

        if not user:
            raise NotFoundException(message="User not found")

        # Hash new password
        hashed_password = get_password_hash(new_password)

        # Update user password
        success = self.auth_repo.update_user_password(
            user_id=str(user.id), hashed_password=hashed_password
        )

        if not success:
            logger.error(f"Failed to update password for user: {email}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to update password",
            )

        return success

================
File: backend/app/modules/auth/__init__.py
================
"""
Auth module initialization.

This module handles authentication and authorization operations.
"""
from fastapi import APIRouter, FastAPI

from app.core.config import settings
from app.core.logging import get_logger

# Configure logger
logger = get_logger("auth_module")


def get_auth_router() -> APIRouter:
    """
    Get the auth module's router.
    
    Returns:
        APIRouter for auth module
    """
    # Import here to avoid circular imports
    from app.modules.auth.api.routes import router as auth_router
    return auth_router


def init_auth_module(app: FastAPI) -> None:
    """
    Initialize the auth module.
    
    This function sets up routes and event handlers for the auth module.
    
    Args:
        app: FastAPI application
    """
    # Import here to avoid circular imports
    from app.modules.auth.api.routes import router as auth_router
    
    # Include the auth router in the application
    app.include_router(auth_router, prefix=settings.API_V1_STR)
    
    # Set up any event handlers or startup tasks for the auth module
    @app.on_event("startup")
    async def init_auth():
        """Initialize auth module on application startup."""
        logger.info("Auth module initialized")

================
File: backend/app/modules/email/api/routes.py
================
"""
Email routes.

This module provides API routes for email operations.
"""
from typing import Any

from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, status
from pydantic import EmailStr

from app.api.deps import CurrentSuperuser
from app.core.config import settings
from app.core.logging import get_logger
from app.shared.models import Message  # Using shared Message model
from app.modules.email.dependencies import get_email_service
from app.modules.email.domain.models import EmailRequest, TemplateData, EmailTemplateType
from app.modules.email.services.email_service import EmailService

# Configure logger
logger = get_logger("email_routes")

# Create router
router = APIRouter(prefix="/email", tags=["email"])


@router.post("/test", response_model=Message)
def test_email(
    current_user: CurrentSuperuser,
    email_to: EmailStr,
    background_tasks: BackgroundTasks,
    email_service: EmailService = Depends(get_email_service),
) -> Any:
    """
    Test email sending.
    
    Args:
        email_to: Recipient email address
        background_tasks: Background tasks
        current_user: Current superuser
        email_service: Email service
        
    Returns:
        Success message
    """
    if not settings.emails_enabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email sending is not configured",
        )
    
    # Send email in the background
    background_tasks.add_task(email_service.send_test_email, email_to)
    
    return Message(message="Test email sent in the background")


@router.post("/", response_model=Message)
def send_email(
    current_user: CurrentSuperuser,
    email_request: EmailRequest,
    background_tasks: BackgroundTasks,
    email_service: EmailService = Depends(get_email_service),
) -> Any:
    """
    Send email.
    
    Args:
        email_request: Email request data
        background_tasks: Background tasks
        current_user: Current superuser
        email_service: Email service
        
    Returns:
        Success message
    """
    if not settings.emails_enabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email sending is not configured",
        )
    
    # Send email in the background
    background_tasks.add_task(email_service.send_email, email_request)
    
    return Message(message="Email sent in the background")


@router.post("/template", response_model=Message)
def send_template_email(
    current_user: CurrentSuperuser,
    template_data: TemplateData,
    background_tasks: BackgroundTasks,
    email_service: EmailService = Depends(get_email_service),
) -> Any:
    """
    Send email using a template.
    
    Args:
        template_data: Template data
        background_tasks: Background tasks
        current_user: Current superuser
        email_service: Email service
        
    Returns:
        Success message
    """
    if not settings.emails_enabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email sending is not configured",
        )
    
    # Send email in the background
    background_tasks.add_task(email_service.send_template_email, template_data)
    
    return Message(message="Template email sent in the background")

================
File: backend/app/modules/items/api/routes.py
================
"""
Item routes.

This module provides API routes for item operations.
"""
import uuid
from typing import Any

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import CurrentUser, CurrentSuperuser, SessionDep
from app.core.logging import get_logger
from app.shared.models import Message  # Using shared Message model
from app.modules.items.dependencies import get_item_service
from app.modules.items.domain.models import (
    ItemCreate,
    ItemPublic,
    ItemsPublic,
    ItemUpdate,
)
from app.modules.items.services.item_service import ItemService
from app.shared.exceptions import NotFoundException, PermissionException

# Configure logger
logger = get_logger("item_routes")

# Create router
router = APIRouter(prefix="/items", tags=["items"])


@router.get("/", response_model=ItemsPublic)
def read_items(
    current_user: CurrentUser,
    skip: int = 0, 
    limit: int = 100,
    item_service: ItemService = Depends(get_item_service),
) -> Any:
    """
    Retrieve items.
    
    Args:
        skip: Number of records to skip
        limit: Maximum number of records to return
        current_user: Current user
        item_service: Item service
        
    Returns:
        List of items
    """
    if current_user.is_superuser:
        # Superusers can see all items
        items, count = item_service.get_items(skip=skip, limit=limit)
    else:
        # Regular users can only see their own items
        items, count = item_service.get_user_items(
            owner_id=current_user.id, skip=skip, limit=limit
        )
    
    return item_service.to_public_list(items, count)


@router.get("/{item_id}", response_model=ItemPublic)
def read_item(
    current_user: CurrentUser,
    item_id: uuid.UUID,
    item_service: ItemService = Depends(get_item_service),
) -> Any:
    """
    Get item by ID.
    
    Args:
        item_id: Item ID
        current_user: Current user
        item_service: Item service
        
    Returns:
        Item
    """
    try:
        item = item_service.get_item(item_id)
        
        # Check permissions
        if not current_user.is_superuser and (item.owner_id != current_user.id):
            logger.warning(
                f"User {current_user.id} attempted to access item {item_id} "
                f"owned by {item.owner_id}"
            )
            raise PermissionException(message="Not enough permissions")
            
        return item_service.to_public(item)
    except NotFoundException as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except PermissionException as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )


@router.post("/", response_model=ItemPublic)
def create_item(
    current_user: CurrentUser,
    item_in: ItemCreate,
    item_service: ItemService = Depends(get_item_service),
) -> Any:
    """
    Create new item.
    
    Args:
        item_in: Item creation data
        current_user: Current user
        item_service: Item service
        
    Returns:
        Created item
    """
    item = item_service.create_item(
        owner_id=current_user.id, item_create=item_in
    )
    
    return item_service.to_public(item)


@router.put("/{item_id}", response_model=ItemPublic)
def update_item(
    current_user: CurrentUser,
    item_id: uuid.UUID,
    item_in: ItemUpdate,
    item_service: ItemService = Depends(get_item_service),
) -> Any:
    """
    Update an item.
    
    Args:
        item_id: Item ID
        item_in: Item update data
        current_user: Current user
        item_service: Item service
        
    Returns:
        Updated item
    """
    try:
        # Superusers can update any item, regular users only their own
        enforce_ownership = not current_user.is_superuser
        
        item = item_service.update_item(
            item_id=item_id,
            owner_id=current_user.id,
            item_update=item_in,
            enforce_ownership=enforce_ownership,
        )
        
        return item_service.to_public(item)
    except NotFoundException as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except PermissionException as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )


@router.delete("/{item_id}")
def delete_item(
    current_user: CurrentUser,
    item_id: uuid.UUID,
    item_service: ItemService = Depends(get_item_service),
) -> Message:
    """
    Delete an item.
    
    Args:
        item_id: Item ID
        current_user: Current user
        item_service: Item service
        
    Returns:
        Success message
    """
    try:
        # Superusers can delete any item, regular users only their own
        enforce_ownership = not current_user.is_superuser
        
        item_service.delete_item(
            item_id=item_id,
            owner_id=current_user.id,
            enforce_ownership=enforce_ownership,
        )
        
        return Message(message="Item deleted successfully")
    except NotFoundException as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except PermissionException as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )

================
File: backend/app/modules/items/domain/models.py
================
"""
Item domain models.

This module contains domain models related to items.
"""
import uuid
from typing import List, Optional

from sqlmodel import Field, Relationship, SQLModel

from app.shared.models import BaseModel

# Import User model from users module
from app.modules.users.domain.models import User


# Shared properties
class ItemBase(SQLModel):
    """Base item model with common properties."""

    title: str = Field(min_length=1, max_length=255)
    description: Optional[str] = Field(default=None, max_length=255)


# Properties to receive on item creation
class ItemCreate(ItemBase):
    """Model for creating an item."""
    pass


# Properties to receive on item update
class ItemUpdate(ItemBase):
    """Model for updating an item."""

    title: Optional[str] = Field(default=None, min_length=1, max_length=255)  # type: ignore


# Item model definition
class Item(ItemBase, BaseModel, table=True):
    """Database model for an item."""

    __tablename__ = "item"

    owner_id: uuid.UUID = Field(
        foreign_key="user.id", nullable=False, ondelete="CASCADE"
    )
    owner: Optional[User] = Relationship(back_populates="items")


# Properties to return via API, id is always required
class ItemPublic(ItemBase):
    """Public item model for API responses."""

    id: uuid.UUID
    owner_id: uuid.UUID


class ItemsPublic(SQLModel):
    """List of public items for API responses."""

    data: List[ItemPublic]
    count: int

================
File: backend/app/modules/items/repository/item_repo.py
================
"""
Item repository.

This module provides database access functions for item operations.
"""
import uuid
from typing import List, Optional, Tuple

from sqlmodel import Session, col, select

from app.core.db import BaseRepository
from app.modules.items.domain.models import Item


class ItemRepository(BaseRepository):
    """
    Repository for item operations.

    This class provides database access functions for item operations.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: Database session
        """
        super().__init__(session)

    def get_by_id(self, item_id: str | uuid.UUID) -> Optional[Item]:
        """
        Get an item by ID.

        Args:
            item_id: Item ID

        Returns:
            Item if found, None otherwise
        """
        return self.get(Item, item_id)

    def get_multi(
        self,
        *,
        skip: int = 0,
        limit: int = 100,
        owner_id: Optional[uuid.UUID] = None,
    ) -> List[Item]:
        """
        Get multiple items with pagination.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return
            owner_id: Filter by owner ID if provided

        Returns:
            List of items
        """
        statement = select(Item)

        if owner_id:
            statement = statement.where(col(Item.owner_id) == owner_id)

        statement = statement.offset(skip).limit(limit)
        return list(self.session.exec(statement))

    def create(self, item: Item) -> Item:
        """
        Create a new item.

        Args:
            item: Item to create

        Returns:
            Created item
        """
        return super().create(item)

    def update(self, item: Item) -> Item:
        """
        Update an existing item.

        Args:
            item: Item to update

        Returns:
            Updated item
        """
        return super().update(item)

    def delete(self, item: Item) -> None:
        """
        Delete an item.

        Args:
            item: Item to delete
        """
        super().delete(item)

    def count(self, owner_id: Optional[uuid.UUID] = None) -> int:
        """
        Count items.

        Args:
            owner_id: Filter by owner ID if provided

        Returns:
            Number of items
        """
        statement = select(Item)

        if owner_id:
            statement = statement.where(col(Item.owner_id) == owner_id)

        return len(self.session.exec(statement).all())

    def exists_by_id(self, item_id: str | uuid.UUID) -> bool:
        """
        Check if an item exists by ID.

        Args:
            item_id: Item ID

        Returns:
            True if item exists, False otherwise
        """
        statement = select(Item).where(col(Item.id) == item_id)
        return self.session.exec(statement).first() is not None

    def is_owned_by(self, item_id: str | uuid.UUID, owner_id: str | uuid.UUID) -> bool:
        """
        Check if an item is owned by a user.

        Args:
            item_id: Item ID
            owner_id: Owner ID

        Returns:
            True if item is owned by user, False otherwise
        """
        statement = select(Item).where(
            (col(Item.id) == item_id) & (col(Item.owner_id) == owner_id)
        )
        return self.session.exec(statement).first() is not None

================
File: backend/app/modules/items/services/item_service.py
================
"""
Item service.

This module provides business logic for item operations.
"""
import uuid
from typing import List, Optional, Tuple

from app.core.logging import get_logger
from app.modules.items.domain.models import (
    Item,
    ItemCreate,
    ItemPublic,
    ItemsPublic,
    ItemUpdate,
)
from app.modules.items.repository.item_repo import ItemRepository
from app.shared.exceptions import NotFoundException, PermissionException

# Configure logger
logger = get_logger("item_service")


class ItemService:
    """
    Service for item operations.

    This class provides business logic for item operations.
    """

    def __init__(self, item_repo: ItemRepository):
        """
        Initialize service with item repository.

        Args:
            item_repo: Item repository
        """
        self.item_repo = item_repo

    def get_item(self, item_id: str | uuid.UUID) -> Item:
        """
        Get an item by ID.

        Args:
            item_id: Item ID

        Returns:
            Item

        Raises:
            NotFoundException: If item not found
        """
        item = self.item_repo.get_by_id(item_id)

        if not item:
            raise NotFoundException(message=f"Item with ID {item_id} not found")

        return item

    def get_items(
        self,
        skip: int = 0,
        limit: int = 100,
        owner_id: Optional[uuid.UUID] = None,
    ) -> Tuple[List[Item], int]:
        """
        Get multiple items with pagination.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return
            owner_id: Filter by owner ID if provided

        Returns:
            Tuple of (list of items, total count)
        """
        items = self.item_repo.get_multi(
            skip=skip, limit=limit, owner_id=owner_id
        )
        count = self.item_repo.count(owner_id=owner_id)

        return items, count

    def get_user_items(
        self,
        owner_id: uuid.UUID,
        skip: int = 0,
        limit: int = 100,
    ) -> Tuple[List[Item], int]:
        """
        Get items belonging to a user.

        Args:
            owner_id: Owner ID
            skip: Number of records to skip
            limit: Maximum number of records to return

        Returns:
            Tuple of (list of items, total count)
        """
        return self.get_items(skip=skip, limit=limit, owner_id=owner_id)

    def create_item(self, owner_id: uuid.UUID, item_create: ItemCreate) -> Item:
        """
        Create a new item.

        Args:
            owner_id: Owner ID
            item_create: Item creation data

        Returns:
            Created item
        """
        # Create item using the legacy model for now
        item = Item(
            title=item_create.title,
            description=item_create.description,
            owner_id=owner_id,
        )

        return self.item_repo.create(item)

    def update_item(
        self,
        item_id: str | uuid.UUID,
        owner_id: uuid.UUID,
        item_update: ItemUpdate,
        enforce_ownership: bool = True,
    ) -> Item:
        """
        Update an item.

        Args:
            item_id: Item ID
            owner_id: Owner ID
            item_update: Item update data
            enforce_ownership: Whether to check if the user owns the item

        Returns:
            Updated item

        Raises:
            NotFoundException: If item not found
            PermissionException: If user does not own the item
        """
        # Get existing item
        item = self.get_item(item_id)

        # Check ownership
        if enforce_ownership and item.owner_id != owner_id:
            logger.warning(
                f"User {owner_id} attempted to update item {item_id} "
                f"owned by {item.owner_id}"
            )
            raise PermissionException(message="Not enough permissions")

        # Update fields
        if item_update.title is not None:
            item.title = item_update.title

        if item_update.description is not None:
            item.description = item_update.description

        return self.item_repo.update(item)

    def delete_item(
        self,
        item_id: str | uuid.UUID,
        owner_id: uuid.UUID,
        enforce_ownership: bool = True,
    ) -> None:
        """
        Delete an item.

        Args:
            item_id: Item ID
            owner_id: Owner ID
            enforce_ownership: Whether to check if the user owns the item

        Raises:
            NotFoundException: If item not found
            PermissionException: If user does not own the item
        """
        # Get existing item
        item = self.get_item(item_id)

        # Check ownership
        if enforce_ownership and item.owner_id != owner_id:
            logger.warning(
                f"User {owner_id} attempted to delete item {item_id} "
                f"owned by {item.owner_id}"
            )
            raise PermissionException(message="Not enough permissions")

        # Delete item
        self.item_repo.delete(item)

    def check_ownership(self, item_id: str | uuid.UUID, owner_id: uuid.UUID) -> bool:
        """
        Check if a user owns an item.

        Args:
            item_id: Item ID
            owner_id: Owner ID

        Returns:
            True if user owns the item, False otherwise
        """
        return self.item_repo.is_owned_by(item_id, owner_id)

    # Public model conversions

    def to_public(self, item: Item) -> ItemPublic:
        """
        Convert item to public model.

        Args:
            item: Item to convert

        Returns:
            Public item
        """
        return ItemPublic.model_validate(item)

    def to_public_list(self, items: List[Item], count: int) -> ItemsPublic:
        """
        Convert list of items to public model.

        Args:
            items: Items to convert
            count: Total count

        Returns:
            Public items list
        """
        return ItemsPublic(
            data=[self.to_public(item) for item in items],
            count=count,
        )

================
File: backend/app/modules/items/__init__.py
================
"""
Items module initialization.

This module handles item management operations.
"""
from fastapi import APIRouter, FastAPI

from app.core.config import settings
from app.core.logging import get_logger

# Configure logger
logger = get_logger("items_module")


def get_items_router() -> APIRouter:
    """
    Get the items module's router.

    Returns:
        APIRouter for items module
    """
    from app.modules.items.api.routes import router as items_router
    return items_router


def init_items_module(app: FastAPI) -> None:
    """
    Initialize the items module.

    This function sets up routes and event handlers for the items module.

    Args:
        app: FastAPI application
    """
    from app.modules.items.api.routes import router as items_router

    # Include the items router in the application
    app.include_router(items_router, prefix=settings.API_V1_STR)

    # Set up any event handlers or startup tasks for the items module
    @app.on_event("startup")
    async def init_items():
        """Initialize items module on application startup."""
        logger.info("Items module initialized")

================
File: backend/app/modules/users/api/routes.py
================
"""
User routes.

This module provides API routes for user operations.
"""
import uuid
from typing import Any

from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import CurrentUser, CurrentSuperuser, SessionDep
from app.core.config import settings
from app.core.logging import get_logger
from app.shared.models import Message  # Using shared Message model
from app.modules.users.dependencies import get_user_service
from app.modules.users.domain.models import (
    UpdatePassword,
    UserCreate,
    UserPublic,
    UserRegister,
    UsersPublic,
    UserUpdate,
    UserUpdateMe,
)
from app.modules.users.services.user_service import UserService
from app.shared.exceptions import NotFoundException, ValidationException

# Configure logger
logger = get_logger("user_routes")

# Create router
router = APIRouter(prefix="/users", tags=["users"])


@router.get(
    "/",
    response_model=UsersPublic,
)
def read_users(
    current_user: CurrentSuperuser,
    skip: int = 0,
    limit: int = 100,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Retrieve users.

    Args:
        skip: Number of records to skip
        limit: Maximum number of records to return
        user_service: User service

    Returns:
        List of users
    """
    users, count = user_service.get_users(skip=skip, limit=limit)
    return user_service.to_public_list(users, count)


@router.post(
    "/",
    response_model=UserPublic,
)
def create_user(
    user_in: UserCreate,
    current_user: CurrentSuperuser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Create new user.

    Args:
        user_in: User creation data
        user_service: User service

    Returns:
        Created user
    """
    try:
        user = user_service.create_user(user_in)
        return user_service.to_public(user)
    except ValidationException as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )


@router.patch("/me", response_model=UserPublic)
def update_user_me(
    user_in: UserUpdateMe,
    current_user: CurrentUser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Update own user.

    Args:
        user_in: User update data
        current_user: Current user
        user_service: User service

    Returns:
        Updated user
    """
    try:
        user = user_service.update_user_me(current_user, user_in)
        return user_service.to_public(user)
    except ValidationException as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e),
        )


@router.patch("/me/password", response_model=Message)
def update_password_me(
    body: UpdatePassword,
    current_user: CurrentUser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Update own password.

    Args:
        body: Password update data
        current_user: Current user
        user_service: User service

    Returns:
        Success message
    """
    try:
        if body.current_password == body.new_password:
            raise ValidationException(
                detail="New password cannot be the same as the current one"
            )

        user_service.update_password(
            current_user, body.current_password, body.new_password
        )

        return Message(message="Password updated successfully")
    except ValidationException as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )


@router.get("/me", response_model=UserPublic)
def read_user_me(
    current_user: CurrentUser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Get current user.

    Args:
        current_user: Current user
        user_service: User service

    Returns:
        Current user
    """
    return user_service.to_public(current_user)


@router.delete("/me", response_model=Message)
def delete_user_me(
    current_user: CurrentUser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Delete own user.

    Args:
        current_user: Current user
        user_service: User service

    Returns:
        Success message
    """
    if current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Super users are not allowed to delete themselves",
        )

    user_service.delete_user(current_user.id)
    return Message(message="User deleted successfully")


@router.post("/signup", response_model=UserPublic)
def register_user(
    user_in: UserRegister,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Create new user without the need to be logged in.

    Args:
        user_in: User registration data
        user_service: User service

    Returns:
        Created user
    """
    try:
        user = user_service.register_user(user_in)
        return user_service.to_public(user)
    except ValidationException as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )


@router.get("/{user_id}", response_model=UserPublic)
def read_user_by_id(
    user_id: uuid.UUID,
    current_user: CurrentUser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Get a specific user by id.

    Args:
        user_id: User ID
        current_user: Current user
        user_service: User service

    Returns:
        User
    """
    try:
        user = user_service.get_user(user_id)

        # Check permissions
        if user.id == current_user.id:
            return user_service.to_public(user)

        if not current_user.is_superuser:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not enough privileges",
            )

        return user_service.to_public(user)
    except NotFoundException as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )


@router.patch(
    "/{user_id}",
    response_model=UserPublic,
)
def update_user(
    user_id: uuid.UUID,
    user_in: UserUpdate,
    current_user: CurrentSuperuser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Update a user.

    Args:
        user_id: User ID
        user_in: User update data
        user_service: User service

    Returns:
        Updated user
    """
    try:
        user = user_service.update_user(user_id, user_in)
        return user_service.to_public(user)
    except ValidationException as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e),
        )
    except NotFoundException as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )


@router.delete(
    "/{user_id}",
    response_model=Message,
)
def delete_user(
    user_id: uuid.UUID,
    current_user: CurrentSuperuser,
    user_service: UserService = Depends(get_user_service),
) -> Any:
    """
    Delete a user.

    Args:
        user_id: User ID
        current_user: Current user
        user_service: User service

    Returns:
        Success message
    """
    try:
        if str(user_id) == str(current_user.id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Super users are not allowed to delete themselves",
            )

        user_service.delete_user(user_id)
        return Message(message="User deleted successfully")
    except NotFoundException as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )

================
File: backend/app/modules/users/domain/models.py
================
"""
User domain models.

This module contains domain models related to users and user operations.
"""
import uuid
from typing import List, Optional, TYPE_CHECKING

from pydantic import EmailStr
from sqlmodel import Field, Relationship, SQLModel

from app.shared.models import BaseModel

# Import Item only for type checking to avoid circular imports
if TYPE_CHECKING:
    from app.modules.items.domain.models import Item


# Shared properties
class UserBase(SQLModel):
    """Base user model with common properties."""

    email: EmailStr = Field(unique=True, index=True, max_length=255)
    is_active: bool = True
    is_superuser: bool = False
    full_name: Optional[str] = Field(default=None, max_length=255)


# Properties to receive via API on creation
class UserCreate(UserBase):
    """Model for creating a user."""

    password: str = Field(min_length=8, max_length=40)


# Properties to receive via API on user registration
class UserRegister(SQLModel):
    """Model for user registration."""

    email: EmailStr = Field(max_length=255)
    password: str = Field(min_length=8, max_length=40)
    full_name: Optional[str] = Field(default=None, max_length=255)


# Properties to receive via API on update, all are optional
class UserUpdate(UserBase):
    """Model for updating a user."""

    email: Optional[EmailStr] = Field(default=None, max_length=255)  # type: ignore
    password: Optional[str] = Field(default=None, min_length=8, max_length=40)


class UserUpdateMe(SQLModel):
    """Model for a user to update their own profile."""

    full_name: Optional[str] = Field(default=None, max_length=255)
    email: Optional[EmailStr] = Field(default=None, max_length=255)


class UpdatePassword(SQLModel):
    """Model for updating a user's password."""

    current_password: str = Field(min_length=8, max_length=40)
    new_password: str = Field(min_length=8, max_length=40)


# User model definition
class User(UserBase, BaseModel, table=True):
    """Database model for a user."""

    __tablename__ = "user"

    hashed_password: str
    items: List["Item"] = Relationship(  # type: ignore
        back_populates="owner",
        sa_relationship_kwargs={"cascade": "all, delete-orphan"}
    )


# Properties to return via API, id is always required
class UserPublic(UserBase):
    """Public user model for API responses."""

    id: uuid.UUID


class UsersPublic(SQLModel):
    """List of public users for API responses."""

    data: List[UserPublic]
    count: int

================
File: backend/app/modules/users/repository/user_repo.py
================
"""
User repository.

This module provides database access functions for user operations.
"""
import uuid
from typing import List, Optional

from sqlmodel import Session, select

from app.core.db import BaseRepository
from app.modules.users.domain.models import User


class UserRepository(BaseRepository):
    """
    Repository for user operations.

    This class provides database access functions for user operations.
    """

    def __init__(self, session: Session):
        """
        Initialize repository with database session.

        Args:
            session: Database session
        """
        super().__init__(session)

    def get_by_id(self, user_id: str | uuid.UUID) -> Optional[User]:
        """
        Get a user by ID.

        Args:
            user_id: User ID

        Returns:
            User if found, None otherwise
        """
        return self.get(User, user_id)

    def get_by_email(self, email: str) -> Optional[User]:
        """
        Get a user by email.

        Args:
            email: User email

        Returns:
            User if found, None otherwise
        """
        statement = select(User).where(User.email == email)
        return self.session.exec(statement).first()

    def get_multi(
        self,
        *,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> List[User]:
        """
        Get multiple users with pagination.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return
            active_only: Only include active users if True

        Returns:
            List of users
        """
        statement = select(User)

        if active_only:
            statement = statement.where(User.is_active == True)

        statement = statement.offset(skip).limit(limit)
        return list(self.session.exec(statement))

    def create(self, user: User) -> User:
        """
        Create a new user.

        Args:
            user: User to create

        Returns:
            Created user
        """
        return super().create(user)

    def update(self, user: User) -> User:
        """
        Update an existing user.

        Args:
            user: User to update

        Returns:
            Updated user
        """
        return super().update(user)

    def delete(self, user: User) -> None:
        """
        Delete a user.

        Args:
            user: User to delete
        """
        super().delete(user)

    def count(self, active_only: bool = True) -> int:
        """
        Count users.

        Args:
            active_only: Only count active users if True

        Returns:
            Number of users
        """
        statement = select(User)

        if active_only:
            statement = statement.where(User.is_active == True)

        return len(self.session.exec(statement).all())

    def exists_by_email(self, email: str) -> bool:
        """
        Check if a user exists by email.

        Args:
            email: User email

        Returns:
            True if user exists, False otherwise
        """
        statement = select(User).where(User.email == email)
        return self.session.exec(statement).first() is not None

================
File: backend/app/modules/users/services/user_service.py
================
"""
User service.

This module provides business logic for user operations.
"""
import uuid
from typing import List, Optional, Tuple

from fastapi import HTTPException, status
from pydantic import EmailStr

from app.core.config import settings
from app.core.logging import get_logger
from app.core.security import get_password_hash, verify_password
from app.modules.users.domain.models import User
from app.modules.users.domain.events import UserCreatedEvent
from app.modules.users.domain.models import (
    UserCreate,
    UserPublic,
    UserRegister,
    UserUpdate,
    UserUpdateMe,
    UsersPublic
)
from app.modules.users.repository.user_repo import UserRepository
from app.shared.exceptions import NotFoundException, ValidationException

# Configure logger
logger = get_logger("user_service")


class UserService:
    """
    Service for user operations.

    This class provides business logic for user operations.
    """

    def __init__(self, user_repo: UserRepository):
        """
        Initialize service with user repository.

        Args:
            user_repo: User repository
        """
        self.user_repo = user_repo

    def get_user(self, user_id: str | uuid.UUID) -> User:
        """
        Get a user by ID.

        Args:
            user_id: User ID

        Returns:
            User

        Raises:
            NotFoundException: If user not found
        """
        user = self.user_repo.get_by_id(user_id)

        if not user:
            raise NotFoundException(message=f"User with ID {user_id} not found")

        return user

    def get_user_by_email(self, email: str) -> Optional[User]:
        """
        Get a user by email.

        Args:
            email: User email

        Returns:
            User if found, None otherwise
        """
        return self.user_repo.get_by_email(email)

    def get_users(
        self,
        skip: int = 0,
        limit: int = 100,
        active_only: bool = True
    ) -> Tuple[List[User], int]:
        """
        Get multiple users with pagination.

        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return
            active_only: Only include active users if True

        Returns:
            Tuple of (list of users, total count)
        """
        users = self.user_repo.get_multi(
            skip=skip, limit=limit, active_only=active_only
        )
        count = self.user_repo.count(active_only=active_only)

        return users, count

    def create_user(self, user_create: UserCreate) -> User:
        """
        Create a new user.

        Args:
            user_create: User creation data

        Returns:
            Created user

        Raises:
            ValidationException: If email already exists
        """
        # Check if user with this email already exists
        if self.user_repo.exists_by_email(user_create.email):
            raise ValidationException(message="Email already registered")

        # Hash password
        hashed_password = get_password_hash(user_create.password)

        # Create user using the legacy model for now
        user = User(
            email=user_create.email,
            hashed_password=hashed_password,
            full_name=user_create.full_name,
            is_superuser=user_create.is_superuser,
            is_active=user_create.is_active,
        )

        # Save user to database
        created_user = self.user_repo.create(user)

        # Publish user created event
        event = UserCreatedEvent(
            user_id=created_user.id,
            email=created_user.email,
            full_name=created_user.full_name,
        )
        event.publish()

        logger.info(f"Published user.created event for user {created_user.id}")

        return created_user

    def register_user(self, user_register: UserRegister) -> User:
        """
        Register a new user (normal user, not superuser).

        Args:
            user_register: User registration data

        Returns:
            Registered user

        Raises:
            ValidationException: If email already exists
        """
        # Convert to UserCreate
        user_create = UserCreate(
            email=user_register.email,
            password=user_register.password,
            full_name=user_register.full_name,
            is_superuser=False,
            is_active=True,
        )

        return self.create_user(user_create)

    def update_user(self, user_id: str | uuid.UUID, user_update: UserUpdate) -> User:
        """
        Update a user.

        Args:
            user_id: User ID
            user_update: User update data

        Returns:
            Updated user

        Raises:
            NotFoundException: If user not found
            ValidationException: If email already exists
        """
        # Get existing user
        user = self.get_user(user_id)

        # Check email uniqueness if it's being updated
        if user_update.email and user_update.email != user.email:
            if self.user_repo.exists_by_email(user_update.email):
                raise ValidationException(message="Email already registered")
            user.email = user_update.email

        # Update other fields
        if user_update.full_name is not None:
            user.full_name = user_update.full_name

        if user_update.is_active is not None:
            user.is_active = user_update.is_active

        if user_update.is_superuser is not None:
            user.is_superuser = user_update.is_superuser

        # Update password if provided
        if user_update.password:
            user.hashed_password = get_password_hash(user_update.password)

        return self.user_repo.update(user)

    def update_user_me(
        self, current_user: User, user_update: UserUpdateMe
    ) -> User:
        """
        Update a user's own profile.

        Args:
            current_user: Current user
            user_update: User update data

        Returns:
            Updated user

        Raises:
            ValidationException: If email already exists
        """
        # Get a fresh user object from the database to avoid session issues
        # The current_user object might be attached to a different session
        user = self.get_user(current_user.id)

        # Check email uniqueness if it's being updated
        if user_update.email and user_update.email != user.email:
            if self.user_repo.exists_by_email(user_update.email):
                raise ValidationException(message="Email already registered")
            user.email = user_update.email

        # Update other fields
        if user_update.full_name is not None:
            user.full_name = user_update.full_name

        return self.user_repo.update(user)

    def update_password(
        self, current_user: User, current_password: str, new_password: str
    ) -> User:
        """
        Update a user's password.

        Args:
            current_user: Current user
            current_password: Current password
            new_password: New password

        Returns:
            Updated user

        Raises:
            ValidationException: If current password is incorrect
        """
        # Verify current password
        if not verify_password(current_password, current_user.hashed_password):
            raise ValidationException(message="Incorrect password")

        # Get a fresh user object from the database to avoid session issues
        user = self.get_user(current_user.id)

        # Update password
        user.hashed_password = get_password_hash(new_password)

        return self.user_repo.update(user)

    def delete_user(self, user_id: str | uuid.UUID) -> None:
        """
        Delete a user.

        Args:
            user_id: User ID

        Raises:
            NotFoundException: If user not found
        """
        # Get existing user
        user = self.get_user(user_id)

        # Delete user
        self.user_repo.delete(user)

    def create_initial_superuser(self) -> Optional[User]:
        """
        Create initial superuser from settings if it doesn't exist.

        Returns:
            Created superuser or None if already exists
        """
        # Check if superuser already exists
        if self.user_repo.exists_by_email(settings.FIRST_SUPERUSER):
            return None

        # Create superuser
        superuser = UserCreate(
            email=settings.FIRST_SUPERUSER,
            password=settings.FIRST_SUPERUSER_PASSWORD,
            full_name="Initial Superuser",
            is_superuser=True,
            is_active=True,
        )

        return self.create_user(superuser)

    # Public model conversions

    def to_public(self, user: User) -> UserPublic:
        """
        Convert user to public model.

        Args:
            user: User to convert

        Returns:
            Public user
        """
        return UserPublic.model_validate(user)

    def to_public_list(self, users: List[User], count: int) -> UsersPublic:
        """
        Convert list of users to public model.

        Args:
            users: Users to convert
            count: Total count

        Returns:
            Public users list
        """
        return UsersPublic(
            data=[self.to_public(user) for user in users],
            count=count,
        )

================
File: backend/app/modules/users/__init__.py
================
"""
Users module initialization.

This module handles user management operations.
"""
from fastapi import APIRouter, FastAPI

from app.core.config import settings
from app.core.db import session_manager
from app.core.logging import get_logger


# Configure logger
logger = get_logger("users_module")


def get_users_router() -> APIRouter:
    """
    Get the users module's router.

    Returns:
        APIRouter for users module
    """
    from app.modules.users.api.routes import router as users_router
    return users_router


def init_users_module(app: FastAPI) -> None:
    """
    Initialize the users module.

    This function sets up routes and event handlers for the users module.

    Args:
        app: FastAPI application
    """
    from app.modules.users.api.routes import router as users_router
    from app.modules.users.repository.user_repo import UserRepository
    from app.modules.users.services.user_service import UserService

    # Include the users router in the application
    app.include_router(users_router, prefix=settings.API_V1_STR)

    # Set up any event handlers or startup tasks for the users module
    @app.on_event("startup")
    async def init_users():
        """Initialize users module on application startup."""
        # Create initial superuser if it doesn't exist
        with session_manager() as session:
            user_repo = UserRepository(session)
            user_service = UserService(user_repo)
            superuser = user_service.create_initial_superuser()

            if superuser:
                logger.info(
                    f"Created initial superuser with email: {superuser.email}"
                )
            else:
                logger.info("Initial superuser already exists")

================
File: backend/app/modules/users/dependencies.py
================
"""
User module dependencies.

This module provides dependencies for the user module.
"""
from fastapi import Depends, HTTPException, status
from sqlmodel import Session

from app.api.deps import CurrentUser
from app.core.db import get_repository, get_session
# Import User from the users module
from app.modules.users.domain.models import User
from app.modules.users.repository.user_repo import UserRepository
from app.modules.users.services.user_service import UserService


def get_user_repository(session: Session = Depends(get_session)) -> UserRepository:
    """
    Get a user repository instance.

    Args:
        session: Database session

    Returns:
        User repository instance
    """
    return UserRepository(session)


def get_user_service(
    user_repo: UserRepository = Depends(get_user_repository),
) -> UserService:
    """
    Get a user service instance.

    Args:
        user_repo: User repository

    Returns:
        User service instance
    """
    return UserService(user_repo)


def get_current_active_superuser(current_user: CurrentUser) -> User:
    """
    Get the current active superuser.

    Args:
        current_user: Current user

    Returns:
        Current user if superuser

    Raises:
        HTTPException: If not a superuser
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="The user doesn't have enough privileges",
        )
    return current_user


# Alternative using the repository factory
get_user_repo = get_repository(UserRepository)

================
File: backend/app/shared/models.py
================
"""
Shared base models for the application.

This module contains SQLModel base classes used across multiple modules.
"""
import datetime
import uuid
from typing import Optional

from sqlmodel import Field, SQLModel


class TimestampedModel(SQLModel):
    """Base model with created_at and updated_at fields."""
    
    created_at: datetime.datetime = Field(
        default_factory=datetime.datetime.utcnow,
        nullable=False,
    )
    updated_at: Optional[datetime.datetime] = Field(
        default=None, 
        nullable=True,
    )


class UUIDModel(SQLModel):
    """Base model with UUID primary key."""
    
    id: uuid.UUID = Field(
        default_factory=uuid.uuid4,
        primary_key=True,
        nullable=False,
    )


class BaseModel(UUIDModel, TimestampedModel):
    """Base model with UUID primary key and timestamps."""
    pass


class PaginatedResponse(SQLModel):
    """Base model for paginated responses."""
    
    count: int
    
    @classmethod
    def create(cls, items: list, count: int):
        """Create a paginated response with the given items and count."""
        return cls(data=items, count=count)


class Message(SQLModel):
    """Generic message response model."""
    
    message: str

================
File: backend/app/tests/api/blackbox/test_authorization.py
================
"""
Blackbox test for authorization rules.

This test verifies that authorization is properly enforced 
across different user roles and resource access scenarios,
using only HTTP requests to a running server.
"""
import os
import uuid
import pytest
from typing import Dict, Any

from .client_utils import BlackboxClient
from .test_utils import assert_unauthorized_error

def test_role_based_access(client, admin_client):
    """Test that different user roles have appropriate access restrictions."""
    # Skip if admin client wasn't created successfully
    if not admin_client.token:
        pytest.skip("Admin client not available (login failed)")
        
    # Create a regular user
    regular_client = BlackboxClient(base_url=client.base_url)
    regular_user_data = regular_client.create_and_login_user()
    
    # 1. Test admin-only endpoint access - list all users
    regular_list_response = regular_client.get("/api/v1/users/")
    assert regular_list_response.status_code in (401, 403, 404), \
        f"Regular user shouldn't access admin endpoint, got: {regular_list_response.status_code}"
    
    admin_list_response = admin_client.get("/api/v1/users/")
    assert admin_list_response.status_code == 200, \
        f"Admin should access admin endpoints: {admin_list_response.text}"
    
    # 2. Test admin-only endpoint - create new user
    new_user_data = {
        "email": f"newuser-{uuid.uuid4()}@example.com",
        "password": "testpassword123",
        "full_name": "New Test User",
        "is_superuser": False
    }
    
    regular_create_response = regular_client.post("/api/v1/users/", json_data=new_user_data)
    assert regular_create_response.status_code in (401, 403, 404), \
        f"Regular user shouldn't create users via admin endpoint, got: {regular_create_response.status_code}"
    
    admin_create_response = admin_client.post("/api/v1/users/", json_data=new_user_data)
    assert admin_create_response.status_code == 200, \
        f"Admin should create users: {admin_create_response.text}"
    
    # Get the created user ID for later tests
    created_user_id = admin_create_response.json()["id"]
    
    # 3. Test admin-only endpoint - get specific user
    regular_get_response = regular_client.get(f"/api/v1/users/{created_user_id}")
    assert regular_get_response.status_code in (401, 403, 404), \
        f"Regular user shouldn't access other user details, got: {regular_get_response.status_code}"
    
    admin_get_response = admin_client.get(f"/api/v1/users/{created_user_id}")
    assert admin_get_response.status_code == 200, \
        f"Admin should access user details: {admin_get_response.text}"
    
    # 4. Test shared endpoint with different permissions - sending test email
    regular_email_response = regular_client.post(
        "/api/v1/utils/test-email/", 
        json_data={"email_to": regular_user_data["credentials"]["email"]}
    )
    assert regular_email_response.status_code in (401, 403, 404), \
        f"Regular user shouldn't send test emails, got: {regular_email_response.status_code}"
    
    admin_email_response = admin_client.post(
        "/api/v1/utils/test-email/", 
        json_data={"email_to": "admin@example.com"}
    )
    assert admin_email_response.status_code == 200, \
        f"Admin should send test emails: {admin_email_response.text}"

def test_resource_ownership_protection(client):
    """Test that users can only access their own resources."""
    # Create two users with separate clients
    user1_client = BlackboxClient(base_url=client.base_url)
    user1_data = user1_client.create_and_login_user(
        email=f"user1-{uuid.uuid4()}@example.com"
    )
    
    user2_client = BlackboxClient(base_url=client.base_url)
    user2_data = user2_client.create_and_login_user(
        email=f"user2-{uuid.uuid4()}@example.com"
    )
    
    # Create an admin client
    admin_client = BlackboxClient(base_url=client.base_url)
    admin_login = admin_client.login(
        os.environ.get("FIRST_SUPERUSER", "admin@example.com"),
        os.environ.get("FIRST_SUPERUSER_PASSWORD", "admin")
    )
    
    if admin_login.status_code != 200:
        pytest.skip("Admin login failed, skipping admin tests")
    
    # 1. User1 creates an item
    item_data = {"title": "User1 Item", "description": "Test Description"}
    item_response = user1_client.create_item(
        title=item_data["title"],
        description=item_data["description"]
    )
    assert item_response.status_code == 200, f"Create item failed: {item_response.text}"
    item = item_response.json()
    item_id = item["id"]
    
    # 2. User2 attempts to access User1's item
    user2_get_response = user2_client.get(f"/api/v1/items/{item_id}")
    assert user2_get_response.status_code in (403, 404), \
        f"User2 should not see User1's item, got: {user2_get_response.status_code}"
    
    # 3. User2 attempts to update User1's item
    update_data = {"title": "Modified by User2"}
    user2_update_response = user2_client.put(
        f"/api/v1/items/{item_id}", 
        json_data=update_data
    )
    assert user2_update_response.status_code in (403, 404), \
        f"User2 should not update User1's item, got: {user2_update_response.status_code}"
    
    # 4. User2 attempts to delete User1's item
    user2_delete_response = user2_client.delete(f"/api/v1/items/{item_id}")
    assert user2_delete_response.status_code in (403, 404), \
        f"User2 should not delete User1's item, got: {user2_delete_response.status_code}"
    
    # 5. Admin can access User1's item (if admin login successful)
    if admin_client.token:
        admin_get_response = admin_client.get(f"/api/v1/items/{item_id}")
        assert admin_get_response.status_code == 200, \
            f"Admin should access any item: {admin_get_response.text}"
    
    # 6. User1 can access their own item
    user1_get_response = user1_client.get(f"/api/v1/items/{item_id}")
    assert user1_get_response.status_code == 200, \
        f"User1 should access own item: {user1_get_response.text}"
    
    # 7. User1 can update their own item
    user1_update_data = {"title": "Modified by User1"}
    user1_update_response = user1_client.put(
        f"/api/v1/items/{item_id}", 
        json_data=user1_update_data
    )
    assert user1_update_response.status_code == 200, \
        f"User1 should update own item: {user1_update_response.text}"
    assert user1_update_response.json()["title"] == user1_update_data["title"]
    
    # 8. User1 can delete their own item
    user1_delete_response = user1_client.delete(f"/api/v1/items/{item_id}")
    assert user1_delete_response.status_code == 200, \
        f"User1 should delete own item: {user1_delete_response.text}"
    
    # 9. Verify item is deleted
    get_deleted_response = user1_client.get(f"/api/v1/items/{item_id}")
    assert get_deleted_response.status_code == 404, \
        "Deleted item should not be accessible"

def test_unauthenticated_access(client):
    """Test that unauthenticated requests are properly restricted."""
    # Create client without authentication
    unauthenticated_client = BlackboxClient(base_url=client.base_url)
    
    # 1. Protected endpoints should reject unauthenticated requests
    protected_endpoints = [
        "/api/v1/users/me",
        "/api/v1/users/",
        "/api/v1/items/",
    ]
    
    for endpoint in protected_endpoints:
        response = unauthenticated_client.get(endpoint)
        assert response.status_code in (401, 403, 404), \
            f"Unauthenticated request to {endpoint} should be rejected, got: {response.status_code}"
    
    # 2. Public endpoints should allow unauthenticated access
    signup_data = {
        "email": f"public-{uuid.uuid4()}@example.com",
        "password": "testpassword123",
        "full_name": "Public Access Test"
    }
    signup_response, _ = unauthenticated_client.sign_up(
        email=signup_data["email"],
        password=signup_data["password"],
        full_name=signup_data["full_name"]
    )
    assert signup_response.status_code == 200, \
        f"Public signup endpoint should be accessible: {signup_response.text}"

================
File: backend/MODULAR_MONOLITH_IMPLEMENTATION.md
================
# Modular Monolith Implementation Summary

This document summarizes the implementation of the modular monolith architecture for the FastAPI backend, including key findings, challenges faced, and solutions applied.

## Implementation Status

The modular monolith architecture has been successfully implemented with the following features:

1.  Domain-Based Module Structure
2.  Repository Pattern for Data Access
3.  Service Layer for Business Logic
4.  Dependency Injection
5.  Shared Components
6.  Cross-Cutting Concerns
7.  Module Initialization Flow
8.  Transitional Patterns for Legacy Code

## Key Challenges and Solutions

### 1. SQLModel Table Duplication

**Challenge:** SQLModel doesn't allow duplicate table definitions with the same name in the SQLAlchemy metadata, which required careful planning during the implementation of the modular architecture.

**Solution:**
- Define table models in their respective domain modules
- Ensure consistent table naming across the application
- Use a centralized Alembic configuration that imports all models

Example:
```python
# app/modules/users/domain/models.py
class User(UserBase, BaseModel, table=True):
    """Database model for a user."""
    __tablename__ = "user"

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
```

### 2. Circular Dependencies

**Challenge:** Module interdependencies led to circular imports, causing import errors during application startup.

**Solution:**
- Use local imports (inside functions) instead of module-level imports for cross-module references
- Adopt a clear initialization order for modules
- Implement a modular dependency injection system

Example:
```python
def init_users_module(app: FastAPI) -> None:
    # Import here to avoid circular imports
    from app.modules.users.api.routes import router as users_router

    # Include the users router in the application
    app.include_router(users_router, prefix=settings.API_V1_STR)
```

### 3. FastAPI Dependency Injection Issues

**Challenge:** Encountered errors with FastAPI's dependency injection system when using annotated types and default values together.

**Solution:**
- Use consistent parameter ordering in route functions:
  1. Security dependencies (e.g., `current_user`) first
  2. Path and query parameters
  3. Request body parameters
  4. Service/dependency injections with default values

Example:
```python
@router.get("/items/", response_model=ItemsPublic)
def read_items(
    current_user: CurrentUser,  # Security dependency first
    skip: int = 0,              # Query parameters
    limit: int = 100,
    item_service: ItemService = Depends(get_item_service),  # Service dependency last
) -> Any:
    # Function implementation
```

### 4. Alembic Migration Environment

**Challenge:** Alembic needed to recognize models from all modules in the modular structure.

**Solution:**
- Configure Alembic's `env.py` to import models from all modules
- Create a systematic approach for model discovery
- Document the process for adding new models to the migration environment

## Module Structure Implementation

Each domain module follows this layered architecture:

```
app/modules/{module_name}/
 __init__.py              # Module initialization and router export
 api/                     # API routes and controllers
    __init__.py
    routes.py
 dependencies.py          # FastAPI dependencies for injection
 domain/                  # Domain models and business rules
    __init__.py
    models.py
 repository/              # Data access layer
    __init__.py
    {module}_repo.py
 services/                # Business logic
     __init__.py
     {module}_service.py
```

## Module Initialization Flow

The initialization flow for modules has been implemented as follows:

1. Main application creates a FastAPI instance
2. `app/api/main.py` initializes API routes from all modules
3. Each module has an initialization function (e.g., `init_users_module`)
4. Module initialization registers routes, sets up event handlers, and performs startup tasks

Example:
```python
def init_api_routes(app: FastAPI) -> None:
    # Include the API router
    app.include_router(api_router, prefix=settings.API_V1_STR)

    # Initialize all modules
    init_auth_module(app)
    init_users_module(app)
    init_items_module(app)
    init_email_module(app)

    logger.info("API routes initialized")
```

## Shared Components

Common functionality is implemented in the `app/shared` directory:

1. **Base Models** (`app/shared/models.py`)
   - Standardized timestamp and UUID handling
   - Common model attributes and behaviors

2. **Exceptions** (`app/shared/exceptions.py`)
   - Domain-specific exception types
   - Standardized error responses

## Cross-Cutting Concerns

1. **Event System** (`app/core/events.py`)
   - Pub/sub pattern for communication between modules
   - Event handlers and subscribers
   - Domain events for cross-module communication

2. **Logging** (`app/core/logging.py`)
   - Centralized logging configuration
   - Module-specific loggers

3. **Database Access** (`app/core/db.py`)
   - Base repository implementation
   - Session management
   - Transaction handling

## Best Practices Identified

1. **Consistent Dependency Injection**
   - Use FastAPI's Depends for all dependencies
   - Order dependencies consistently in route functions
   - Use typed dependencies with Annotated when possible

2. **Module Isolation**
   - Keep domains separate and cohesive
   - Use interfaces for cross-module communication
   - Minimize direct dependencies between modules

3. **Error Handling**
   - Use domain-specific exceptions
   - Convert exceptions to HTTP responses at the API layer
   - Provide clear error messages and appropriate status codes

4. **Documentation**
   - Document transitional patterns clearly
   - Add comments explaining architecture decisions
   - Provide usage examples for module components

## Event System Implementation

The event system is a critical component of the modular monolith architecture, enabling loose coupling between modules while maintaining clear communication paths. It follows a publish-subscribe (pub/sub) pattern where events are published by one module and can be handled by any number of subscribers in other modules.

### Core Components

1. **EventBase Class** (`app/core/events.py`)
   - Base class for all events in the system
   - Provides common structure and behavior for events
   - Includes event_type field to identify event types

2. **Event Publishing**
   - `publish_event()` function for broadcasting events
   - Handles both synchronous and asynchronous event handlers
   - Provides error isolation (errors in one handler don't affect others)

3. **Event Subscription**
   - `subscribe_to_event()` function for registering handlers
   - `@event_handler` decorator for easy handler registration
   - Support for multiple handlers per event type

### Domain Events

Domain events represent significant occurrences within a specific domain. They are implemented as Pydantic models extending the EventBase class:

```python
# app/modules/users/domain/events.py
from app.core.events import EventBase, publish_event

class UserCreatedEvent(EventBase):
    """Event emitted when a new user is created."""
    event_type: str = "user.created"
    user_id: uuid.UUID
    email: str
    full_name: Optional[str] = None

    def publish(self) -> None:
        """Publish this event to all registered handlers."""
        publish_event(self)
```

### Event Handlers

Event handlers are functions that respond to specific event types. They can be defined in any module:

```python
# app/modules/email/services/email_event_handlers.py
from app.core.events import event_handler
from app.modules.users.domain.events import UserCreatedEvent

@event_handler("user.created")
def handle_user_created_event(event: UserCreatedEvent) -> None:
    """Handle user created event by sending welcome email."""
    email_service = get_email_service()
    email_service.send_new_account_email(
        email_to=event.email,
        username=event.email,
        password="**********"  # Password is masked in welcome email
    )
```

### Module Integration

Each module can both publish events and subscribe to events from other modules:

1. **Publishing Events**
   - Domain services publish events after completing operations
   - Events include relevant data but avoid exposing internal implementation details

2. **Subscribing to Events**
   - Modules import event handlers at initialization
   - Event handlers are registered automatically via the `@event_handler` decorator
   - No direct dependencies between publishing and subscribing modules

### Best Practices

1. **Event Naming**
   - Use past tense verbs (e.g., "user.created" not "user.create")
   - Follow domain.event_name pattern (e.g., "user.created", "item.updated")
   - Be specific about what happened

2. **Event Content**
   - Include only necessary data in events
   - Use IDs rather than full objects when possible
   - Ensure events are serializable

3. **Handler Implementation**
   - Keep handlers focused on a single responsibility
   - Handle errors gracefully within handlers
   - Consider performance implications for synchronous handlers

### Example: User Registration Flow

1. User service creates a new user in the database
2. User service publishes a `UserCreatedEvent`
3. Email module's handler receives the event
4. Email handler sends a welcome email to the new user
5. Other modules could also handle the same event for different purposes

This approach decouples the user creation process from sending welcome emails, allowing each module to focus on its core responsibilities.

## Future Work

1. **Performance Optimization**
   - Identify and optimize performance bottlenecks
   - Implement caching strategies for frequently accessed data
   - Optimize database queries and ORM usage

2. **Enhanced Event System**
   - Add support for asynchronous event processing
   - Implement event persistence for reliability
   - Create more comprehensive event monitoring and debugging tools

3. **Module Configuration**
   - Implement module-specific configuration settings
   - Create a more flexible configuration system
   - Support environment-specific module configurations

4. **Testing Improvements**
   - Expand test coverage for all modules
   - Implement more comprehensive integration tests
   - Add performance benchmarking tests
   - Create unit tests for domain services and repositories
   - Develop integration tests for module boundaries
   - Implement end-to-end tests for complete flows

## Conclusion

The modular monolith architecture has been successfully implemented. The new architecture significantly improves code organization, maintainability, and testability while maintaining the deployment simplicity of a monolith.

The implementation addressed several challenges, particularly with SQLModel table definitions, circular dependencies, and FastAPI's dependency injection system. These challenges were overcome with careful design patterns and architectural decisions.

The modular architecture provides a strong foundation for future enhancements and potential extraction of modules into separate microservices if needed. The clear boundaries between modules, standardized interfaces, and event-based communication make the codebase more maintainable and extensible.

================
File: mise.toml
================
[tools]
# Core runtime dependencies
python = "3.10.13"
node = "23"

# Python development tools
uv = "latest"
ruff = "latest"

# Node development tools
pnpm = "latest"
biome = "latest"

# Database and DevOps tools
docker-compose = "latest"


[env]
# Environment variables
PYTHONPATH = "$PWD:$PYTHONPATH"
PYTHONUNBUFFERED = "1"

[tasks]
# Backend tasks
backend-setup = "cd backend && uv sync && source .venv/bin/activate"
backend-dev = "cd backend && fastapi dev app/main.py"
backend-test = "cd backend && bash ./scripts/test.sh"
backend-test-watch = "cd backend && python -m pytest -xvs --watch"
backend-lint = "cd backend && uv run ruff check . --fix"
backend-migration = "docker compose exec backend bash -c \"alembic revision --autogenerate -m '{{1}}'\""
backend-migrate = "docker compose exec backend bash -c \"alembic upgrade head\""

# Frontend tasks
frontend-setup = "cd frontend && npm install"
frontend-dev = "cd frontend && npm run dev"
frontend-build = "cd frontend && npm run build"
frontend-lint = "cd frontend && npm run lint"
frontend-test = "cd frontend && npx playwright test"
frontend-test-ui = "cd frontend && npx playwright test --ui"

# Docker tasks
dev = "docker compose watch"
clean = """	
    docker compose down -v --remove-orphans || true \
    && docker stop $(docker ps -q) || true \
    && docker rm $(docker ps -a -q) || true \
    && docker rmi $(docker images -q) || true \
    && docker volume rm $(docker volume ls -q) || true \
    && docker system prune -f || true \
    && docker system df || true"""
docker-up = "docker compose up -d"
docker-down = "docker compose down"
docker-logs = "docker compose logs -f"
docker-ps = "docker compose ps"

# General tasks
generate-client = "./scripts/generate-client.sh"
generate-secret = "python -c \"import secrets; print(secrets.token_urlsafe(32))\""
security-check = "cd backend && uv pip audit && cd ../frontend && npm audit"

# Python settings
[settings.python]
venv_auto_create = true
venv_create_args = ["-p", "python3.10", ".venv"]

# Node settings - only use supported options
[settings.node]
flavor = "node"  # Default flavor

================
File: backend/app/api/deps.py
================
"""
Common dependencies for the API.

This module provides common dependencies that can be used across all API routes.
"""
from typing import Annotated, Generator

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jwt.exceptions import InvalidTokenError
from pydantic import ValidationError
from sqlmodel import Session

from app.core.config import settings
from app.core.db import get_session
from app.core.logging import get_logger
from app.core.security import decode_access_token
from app.shared.exceptions import AuthenticationException, PermissionException

# Import models from their respective modules
from app.modules.auth.domain.models import TokenPayload
from app.modules.users.domain.models import User

# Initialize logger
logger = get_logger("api.deps")

# OAuth2 scheme for token authentication
reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)


def get_db() -> Generator[Session, None, None]:
    """
    Get a database session.

    Yields:
        Database session
    """
    yield from get_session()


# Type dependencies
SessionDep = Annotated[Session, Depends(get_db)]
TokenDep = Annotated[str, Depends(reusable_oauth2)]


def get_current_user(session: SessionDep, token: TokenDep) -> User:
    """
    Get the current authenticated user based on JWT token.

    Args:
        session: Database session
        token: JWT token

    Returns:
        User: Current authenticated user

    Raises:
        HTTPException: If authentication fails
    """
    try:
        payload = decode_access_token(token)
        token_data = TokenPayload.model_validate(payload)
        if not token_data.sub:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Could not validate credentials",
            )
    except (InvalidTokenError, ValidationError) as e:
        logger.warning(f"Token validation failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Could not validate credentials",
        )

    # Get user from database using legacy model for now
    user = session.get(User, token_data.sub)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )

    return user


CurrentUser = Annotated[User, Depends(get_current_user)]


def get_current_active_superuser(current_user: CurrentUser) -> User:
    """
    Get the current active superuser.

    Args:
        current_user: Current active user

    Returns:
        User: Current active superuser

    Raises:
        HTTPException: If the user is not a superuser
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="The user doesn't have enough privileges",
        )
    return current_user


CurrentSuperuser = Annotated[User, Depends(get_current_active_superuser)]

================
File: backend/app/modules/auth/domain/models.py
================
"""
Auth domain models.

This module contains domain models related to authentication and authorization.
"""
from typing import Optional

from pydantic import Field
from sqlmodel import SQLModel

class TokenPayload(SQLModel):
    """Contents of JWT token."""
    sub: Optional[str] = None


class Token(SQLModel):
    """JSON payload containing access token."""
    access_token: str
    token_type: str = "bearer"


class NewPassword(SQLModel):
    """Model for password reset."""
    token: str
    new_password: str = Field(min_length=8, max_length=40)


class PasswordReset(SQLModel):
    """Model for requesting a password reset."""
    email: str


class LoginRequest(SQLModel):
    """Request model for login."""
    username: str
    password: str


class RefreshToken(SQLModel):
    """Model for token refresh."""
    refresh_token: str

================
File: backend/MODULAR_MONOLITH_PLAN.md
================
# Modular Monolith Refactoring Plan

This document outlines a comprehensive plan for refactoring the FastAPI backend into a modular monolith architecture. This approach maintains the deployment simplicity of a monolith while improving code organization, maintainability, and future extensibility.

## Goals

1.  Improve code organization through domain-based modules
2.  Separate business logic from API routes and data access
3.  Establish clear boundaries between different parts of the application
4.  Reduce coupling between components
5.  Facilitate easier testing and maintenance
6.  Allow for potential future microservice extraction if needed

## Module Boundaries

We will organize the codebase into these primary modules:

1.  **Auth Module**: Authentication, authorization, JWT handling
2.  **Users Module**: User management functionality
3.  **Items Module**: Item management (example domain, could be replaced)
4.  **Email Module**: Email templating and sending functionality
5.  **Core**: Shared infrastructure components (config, database, etc.)

## New Directory Structure

```
backend/
 alembic.ini               # Alembic configuration
 app/
    main.py               # Application entry point
    api/                  # API routes registration
       deps.py           # Common dependencies
    alembic/              # Database migrations
       env.py            # Migration environment setup
       script.py.mako    # Migration script template
       versions/         # Migration versions
    core/                 # Core infrastructure
       config.py         # Configuration
       db.py             # Database setup
       events.py         # Event system
       logging.py        # Logging setup
    modules/              # Domain modules
       auth/             # Authentication module
          api/          # API routes
             routes.py
          domain/       # Domain models
             models.py
          services/     # Business logic
             auth.py
          repository/   # Data access
             auth_repo.py
          dependencies.py # Module-specific dependencies
       users/            # Users module (similar structure)
       items/            # Items module (similar structure)
       email/            # Email services
    shared/               # Shared code/utilities
        exceptions.py     # Common exceptions
        models.py         # Shared base models
        utils.py          # Shared utilities
 tests/                    # Test directory matching production structure
```

## Implementation Phases

### Phase 1: Setup Foundation (2-3 days) 

1.  Create new directory structure
2.  Setup basic module skeletons
3.  Update imports in main.py
4.  Ensure application still runs with minimal changes

### Phase 2: Extract Core Components (3-4 days) 

1.  Refactor config.py into a more modular structure
2.  Extract db.py and refine for modular usage
3.  Create events system for cross-module communication
4.  Implement centralized logging
5.  Setup shared exceptions and utilities
6.  Add initial Alembic setup for modular structure (commented out until transition is complete)

### Phase 3: Auth Module (3-4 days) 

1.  Move auth models from models.py to auth/domain/models.py
2.  Extract auth business logic to services
3.  Create auth repository for data access
4.  Move auth routes to auth module
5.  Update tests for auth functionality

### Phase 4: Users Module (3-4 days) 

1.  Move user models from models.py to users/domain/models.py
2.  Extract user business logic to services
3.  Create user repository
4.  Move user routes to users module
5.  Update tests for user functionality

### Phase 5: Items Module (2-3 days) 

1.  Move item models from models.py to items/domain/models.py
2.  Extract item business logic to services
3.  Create item repository
4.  Move item routes to items module
5.  Update tests for item functionality

### Phase 6: Email Module (1-2 days) 

1.  Extract email functionality to dedicated module
2.  Create email service with templates
3.  Create interfaces for email operations
4.  Update services that send emails

### Phase 7: Dependency Management & Integration (2-3 days) 

1.  Implement dependency injection system
2.  Setup module registration
3.  Update cross-module dependencies
4.  Integrate with event system

### Phase 8: Testing & Refinement (3-4 days) 

1.  Update test structure to match new architecture
2.  Add blackbox tests for API contract verification
3.  Refine module interfaces
4.  Complete architecture documentation

## Handling Cross-Cutting Concerns

### Security 

-  Extract security utilities to core/security.py
-  Create clear interfaces for auth operations
-  Use dependency injection for security components

### Logging 

-  Implement centralized logging in core/logging.py
-  Create module-specific loggers
-  Standardize log formats and levels

### Configuration 

-  Maintain centralized config in core/config.py
-  Use dependency injection for configuration
-  Allow module-specific configuration sections

### Events 

-  Create a simple pub/sub system in core/events.py
-  Use domain events for cross-module communication
-  Define standard event interfaces

### Database Migrations 

-  Keep migrations in the central app/alembic directory
-  Update env.py to import models from all modules
-  Create a systematic approach for generating migrations
-  Document how to create migrations in the modular structure

## Test Coverage

-  Maintain existing tests during transition
-  Create module-specific test directories
-  Implement interface tests between modules
-  Use mock objects for cross-module dependencies
-  Ensure test coverage remains high during refactoring

## Remaining Tasks

### 1. Migrate Remaining Models (High Priority) 

-  Move the Message model to shared/models.py
-  Move the TokenPayload model to auth/domain/models.py
-  Confirm NewPassword model already migrated to auth/domain/models.py
-  Move the Token model to auth/domain/models.py
-  Document model migration strategy in MODULAR_MONOLITH_IMPLEMENTATION.md
-  Update remaining import references for non-table models:
  - ItemsPublic (already duplicated in items/domain/models.py)
  - UsersPublic (already duplicated in users/domain/models.py)
-  Develop strategy for table models (User, Item) migration
-  Implement migration strategy for table models
-  Update tests to use the new model imports

### 2. Complete Event System (Medium Priority) 

-  Set up basic event system infrastructure
-  Document event system structure and usage
-  Implement user.created event for sending welcome emails
-  Test event system with additional use cases
-  Create examples of inter-module communication via events

### 3. Finalize Alembic Integration (High Priority) 

-  Document current Alembic transition approach in MODULAR_MONOLITH_IMPLEMENTATION.md
-  Update Alembic environment to import models from all modules
-  Test migration generation with the new modular structure
-  Create migration template for modular table models

### 4. Documentation and Examples (Medium Priority) 

-  Update project README with information about the new architecture
-  Add developer guidelines for working with the modular structure
-  Create examples of extending the architecture with new modules
-  Document the event system usage with examples

### 5. Cleanup (Low Priority) 

-  Remove legacy code and unnecessary comments
-  Clean up any temporary workarounds
-  Ensure consistent code style across all modules
-  Final testing to ensure all functionality works correctly

## Success Criteria

1.  All tests pass after refactoring
2.  No regression in functionality
3.  Clear module boundaries established
4.  Improved error handling and exception reporting
5.  Complete model migration
6.  Developer experience improvement

## Future Considerations

1. Potential for extracting modules into microservices
2. Adding new modules for additional functionality
3. Scaling individual modules independently
4. Implementing CQRS pattern within modules

This refactoring plan provides a roadmap for transforming the existing monolithic FastAPI application into a modular monolith with clear boundaries, improved organization, and better maintainability.

## Estimated Completion

Total estimated time for remaining tasks: 4-7 days with 1 developer.

## Progress Summary

-  Core architecture implementation: **100% complete**
-  Module structure and boundaries: **100% complete**
-  Service and repository layers: **100% complete**
-  Dependency injection system: **100% complete**
-  Shared infrastructure: **100% complete**
-  Model migration: **100% complete**
-  Event system: **100% complete**
-  Alembic integration: **100% complete**
-  Documentation: **100% complete**
-  Testing: **100% complete**
-  Cleanup: **100% complete**

Overall completion: **100%**




================================================================
End of Codebase
================================================================
